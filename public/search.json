[{"title":"A first look at C++ (1) copy 4","url":"/2023/01/18/A%20first%20look%20at%20C++%20(1)%20copy%204/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>4 程序流程结构<br>C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==</p>\n<p>顺序结构：程序按顺序执行，不发生跳转<br>选择结构：依据条件是否满足，有选择的执行相应功能<br>循环结构：依据条件是否满足，循环多次执行某段代码<br>4.1 选择结构<br>4.1.1 if 语句<br>作用：执行满足条件的语句</p>\n<p>if 语句的三种形式</p>\n<p>单行格式 if 语句</p>\n<p>多行格式 if 语句</p>\n<p>多条件的 if 语句</p>\n<p>单行格式 if 语句：if(条件){ 条件满足执行的语句 }</p>\n<p>![img](C:\\Users\\Zhenglin Li\\Desktop\\assets\\clip_image002.png)</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>//选择结构-单行if语句\n//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印\n\nint score = 0;\ncout &lt;&lt; &quot;请输入一个分数：&quot; &lt;&lt; endl;\ncin &gt;&gt; score;\n\ncout &lt;&lt; &quot;您输入的分数为： &quot; &lt;&lt; score &lt;&lt; endl;\n\n//if语句\n//注意事项，在if判断语句后面，不要加分号\nif (score &gt; 600)\n{\n    cout &lt;&lt; &quot;我考上了一本大学！！！&quot; &lt;&lt; endl;\n}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>注意：if 条件表达式后不要加分号</p>\n<p>多行格式 if 语句：if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };<br>![img](C:\\Users\\Zhenglin Li\\Desktop\\assets\\clip_image002-1541662519170.png)</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int score = 0;\n\ncout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;\n\ncin &gt;&gt; score;\n\nif (score &gt; 600)\n{\n    cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;我未考上一本大学&quot; &lt;&lt; endl;\n}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>多条件的 if 语句：if(条件 1){ 条件 1 满足执行的语句 }else if(条件 2){条件 2 满足执行的语句}… else{ 都不满足执行的语句}<br>![img](C:\\Users\\Zhenglin Li\\Desktop\\assets\\clip_image002-1541662566808.png)</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int score = 0;\n\ncout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;\n\ncin &gt;&gt; score;\n\nif (score &gt; 600)\n{\n    cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;\n}\nelse if (score &gt; 500)\n{\n    cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;\n}\nelse if (score &gt; 400)\n{\n    cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;\n}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>嵌套 if 语句：在 if 语句中，可以嵌套使用 if 语句，达到更精确的条件判断</p>\n<p>案例需求：</p>\n<p>提示用户输入一个高考考试分数，根据分数做如下判断<br>分数如果大于 600 分视为考上一本，大于 500 分考上二本，大于 400 考上三本，其余视为未考上本科；<br>在一本分数中，如果大于 700 分，考入北大，大于 650 分，考入清华，大于 600 考入人大。<br>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int score = 0;\n\ncout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;\n\ncin &gt;&gt; score;\n\nif (score &gt; 600)\n{\n    cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;\n    if (score &gt; 700)\n    {\n        cout &lt;&lt; &quot;我考上了北大&quot; &lt;&lt; endl;\n    }\n    else if (score &gt; 650)\n    {\n        cout &lt;&lt; &quot;我考上了清华&quot; &lt;&lt; endl;\n    }\n    else\n    {\n        cout &lt;&lt; &quot;我考上了人大&quot; &lt;&lt; endl;\n    }\n\n}\nelse if (score &gt; 500)\n{\n    cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;\n}\nelse if (score &gt; 400)\n{\n    cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;\n}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>练习案例： 三只小猪称体重</p>\n<p>有三只小猪 ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？![三只小猪](C:\\Users\\Zhenglin Li\\Desktop\\assets\\三只小猪.jpg)</p>\n<p>4.1.2 三目运算符<br>作用： 通过三目运算符实现简单的判断</p>\n<p>语法：表达式 1 ? 表达式 2 ：表达式 3</p>\n<p>解释：</p>\n<p>如果表达式 1 的值为真，执行表达式 2，并返回表达式 2 的结果；</p>\n<p>如果表达式 1 的值为假，执行表达式 3，并返回表达式 3 的结果。</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int a = 10;\nint b = 20;\nint c = 0;\n\nc = a &gt; b ? a : b;\ncout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\n\n//C++中三目运算符返回的是变量,可以继续赋值\n\n(a &gt; b ? a : b) = 100;\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\ncout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：和 if 语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p>\n<p>4.1.3 switch 语句<br>作用：执行多条件分支语句</p>\n<p>语法：</p>\n<p>C++<br>switch(表达式)</p>\n<p>{</p>\n<pre><code>case 结果1：执行语句;break;\n\ncase 结果2：执行语句;break;\n\n...\n\ndefault:执行语句;break;</code></pre><p>}<br>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>//请给电影评分\n//10 ~ 9   经典\n// 8 ~ 7   非常好\n// 6 ~ 5   一般\n// 5分以下 烂片\n\nint score = 0;\ncout &lt;&lt; &quot;请给电影打分&quot; &lt;&lt; endl;\ncin &gt;&gt; score;\n\nswitch (score)\n{\ncase 10:\ncase 9:\n    cout &lt;&lt; &quot;经典&quot; &lt;&lt; endl;\n    break;\ncase 8:\n    cout &lt;&lt; &quot;非常好&quot; &lt;&lt; endl;\n    break;\ncase 7:\ncase 6:\n    cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl;\n    break;\ndefault:\n    cout &lt;&lt; &quot;烂片&quot; &lt;&lt; endl;\n    break;\n}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>注意 1：switch 语句中表达式类型只能是整型或者字符型</p>\n<p>注意 2：case 里如果没有 break，那么程序会一直向下执行</p>\n<p>总结：与 if 语句比，对于多条件判断时，switch 的结构清晰，执行效率高，缺点是 switch 不可以判断区间</p>\n<p>4.2 循环结构<br>4.2.1 while 循环语句<br>作用：满足循环条件，执行循环语句</p>\n<p>语法：while(循环条件){ 循环语句 }</p>\n<p>解释：==只要循环条件的结果为真，就执行循环语句==</p>\n<p>![img](C:\\Users\\Zhenglin Li\\Desktop\\assets\\clip_image002-1541668640382.png)</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int num = 0;\nwhile (num &lt; 10)\n{\n    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;\n    num++;\n}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p>\n<p>while 循环练习案例：==猜数字==</p>\n<p>案例描述：系统随机生成一个 1 到 100 之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。</p>\n<p>![猜数字](C:\\Users\\Zhenglin Li\\Desktop\\assets\\猜数字.jpg)</p>\n<p>4.2.2 do…while 循环语句<br>作用： 满足循环条件，执行循环语句</p>\n<p>语法： do{ 循环语句 } while(循环条件);</p>\n<p>注意：与 while 的区别在于==do…while 会先执行一次循环语句==，再判断循环条件</p>\n<p>![img](C:\\Users\\Zhenglin Li\\Desktop\\assets\\clip_image002-1541671163478.png)</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int num = 0;\n\ndo\n{\n    cout &lt;&lt; num &lt;&lt; endl;\n    num++;\n\n} while (num &lt; 10);\n\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：与 while 循环区别在于，do…while 先执行一次循环语句，再判断循环条件</p>\n<p>练习案例：水仙花数</p>\n<p>案例描述：水仙花数是指一个 3 位数，它的每个位上的数字的 3 次幂之和等于它本身</p>\n<p>例如：1^3 + 5^3+ 3^3 = 153</p>\n<p>请利用 do…while 语句，求出所有 3 位数中的水仙花数</p>\n<p>4.2.3 for 循环语句<br>作用： 满足循环条件，执行循环语句</p>\n<p>语法：for(起始表达式;条件表达式;末尾循环体) { 循环语句; }</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>for (int i = 0; i &lt; 10; i++)\n{\n    cout &lt;&lt; i &lt;&lt; endl;\n}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>详解：</p>\n<p>![1541673704101](C:\\Users\\Zhenglin Li\\Desktop\\assets\\1541673704101.png)</p>\n<p>注意：for 循环中的表达式，要用分号进行分隔</p>\n<p>总结：while , do…while, for 都是开发中常用的循环语句，for 循环结构比较清晰，比较常用</p>\n<p>练习案例：敲桌子</p>\n<p>案例描述：从 1 开始数到数字 100， 如果数字个位含有 7，或者数字十位含有 7，或者该数字是 7 的倍数，我们打印敲桌子，其余数字直接打印输出。</p>\n<p>![timg](C:\\Users\\Zhenglin Li\\Desktop\\assets\\timg.gif)</p>\n<p>4.2.4 嵌套循环<br>作用： 在循环体中再嵌套一层循环，解决一些实际问题</p>\n<p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p>\n<p>![1541676003486](C:\\Users\\Zhenglin Li\\Desktop\\assets\\1541676003486.png)</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>//外层循环执行1次，内层循环执行1轮\nfor (int i = 0; i &lt; 10; i++)\n{\n    for (int j = 0; j &lt; 10; j++)\n    {\n        cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>练习案例：乘法口诀表</p>\n<p>案例描述：利用嵌套循环，实现九九乘法表</p>\n<p>![0006018857256120_b](C:\\Users\\Zhenglin Li\\Desktop\\assets\\0006018857256120_b.jpg)</p>\n<p>4.3 跳转语句<br>4.3.1 break 语句<br>作用: 用于跳出==选择结构==或者==循环结构==</p>\n<p>break 使用的时机：</p>\n<p>出现在 switch 条件语句中，作用是终止 case 并跳出 switch<br>出现在循环语句中，作用是跳出当前的循环语句<br>出现在嵌套循环中，跳出最近的内层循环语句<br>示例 1：</p>\n<p>C++<br>int main() {<br>//1、在 switch 语句中使用 break<br>cout &lt;&lt; “请选择您挑战副本的难度：” &lt;&lt; endl;<br>cout &lt;&lt; “1、普通” &lt;&lt; endl;<br>cout &lt;&lt; “2、中等” &lt;&lt; endl;<br>cout &lt;&lt; “3、困难” &lt;&lt; endl;</p>\n<pre><code>int num = 0;\n\ncin &gt;&gt; num;\n\nswitch (num)\n{\ncase 1:\n    cout &lt;&lt; &quot;您选择的是普通难度&quot; &lt;&lt; endl;\n    break;\ncase 2:\n    cout &lt;&lt; &quot;您选择的是中等难度&quot; &lt;&lt; endl;\n    break;\ncase 3:\n    cout &lt;&lt; &quot;您选择的是困难难度&quot; &lt;&lt; endl;\n    break;\n}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：</p>\n<p>C++<br>int main() {<br>//2、在循环语句中用 break<br>for (int i = 0; i &lt; 10; i++)<br>{<br>if (i == 5)<br>{<br>break; //跳出循环语句<br>}<br>cout &lt;&lt; i &lt;&lt; endl;<br>}</p>\n<pre><code>system(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 3：</p>\n<p>C++<br>int main() {<br>//在嵌套循环语句中使用 break，退出内层循环<br>for (int i = 0; i &lt; 10; i++)<br>{<br>for (int j = 0; j &lt; 10; j++)<br>{<br>if (j == 5)<br>{<br>break;<br>}<br>cout &lt;&lt; “*“ &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>}<br>system(“pause”);</p>\n<pre><code>return 0;</code></pre><p>}<br>4.3.2 continue 语句<br>作用：在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>for (int i = 0; i &lt; 100; i++)\n{\n    if (i % 2 == 0)\n    {\n        continue;\n    }\n    cout &lt;&lt; i &lt;&lt; endl;\n}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>注意：continue 并没有使整个循环终止，而 break 会跳出循环</p>\n<p>4.3.3 goto 语句<br>作用：可以无条件跳转语句</p>\n<p>语法： goto 标记;</p>\n<p>解释：如果标记的名称存在，执行到 goto 语句时，会跳转到标记的位置</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;\n\ngoto FLAG;\n\ncout &lt;&lt; &quot;2&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;3&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;4&quot; &lt;&lt; endl;\n\nFLAG:\n\ncout &lt;&lt; &quot;5&quot; &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>注意：在程序中不建议使用 goto 语句，以免造成程序流程混乱</p>\n<p>5 数组<br>5.1 概述<br>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p>\n<p>特点 1：数组中的每个==数据元素都是相同的数据类型==</p>\n<p>特点 2：数组是由==连续的内存==位置组成的</p>\n<p>![1541748375356](C:\\Users\\Zhenglin Li\\Desktop\\assets\\1541748375356.png)</p>\n<p>5.2 一维数组<br>5.2.1 一维数组定义方式<br>一维数组定义的三种方式：</p>\n<p>数据类型 数组名[ 数组长度 ];<br>数据类型 数组名[ 数组长度 ] = { 值 1，值 2 …};<br>数据类型 数组名[ ] = { 值 1，值 2 …};<br>示例</p>\n<p>C++<br>int main() {</p>\n<pre><code>//定义方式1\n//数据类型 数组名[元素个数];\nint score[10];\n\n//利用下标赋值\nscore[0] = 100;\nscore[1] = 99;\nscore[2] = 85;\n\n//利用下标输出\ncout &lt;&lt; score[0] &lt;&lt; endl;\ncout &lt;&lt; score[1] &lt;&lt; endl;\ncout &lt;&lt; score[2] &lt;&lt; endl;\n\n\n//第二种定义方式\n//数据类型 数组名[元素个数] =  {值1，值2 ，值3 ...};\n//如果{}内不足10个数据，剩余数据用0补全\nint score2[10] = { 100, 90,80,70,60,50,40,30,20,10 };\n\n//逐个输出\n//cout &lt;&lt; score2[0] &lt;&lt; endl;\n//cout &lt;&lt; score2[1] &lt;&lt; endl;\n\n//一个一个输出太麻烦，因此可以利用循环进行输出\nfor (int i = 0; i &lt; 10; i++)\n{\n    cout &lt;&lt; score2[i] &lt;&lt; endl;\n}\n\n//定义方式3\n//数据类型 数组名[] =  {值1，值2 ，值3 ...};\nint score3[] = { 100,90,80,70,60,50,40,30,20,10 };\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    cout &lt;&lt; score3[i] &lt;&lt; endl;\n}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结 1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p>\n<p>总结 2：数组中下标是从 0 开始索引</p>\n<p>5.2.2 一维数组数组名<br>一维数组名称的用途：</p>\n<p>可以统计整个数组在内存中的长度<br>可以获取数组在内存中的首地址<br>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>//数组名用途\n//1、可以获取整个数组占用内存空间大小\nint arr[10] = { 1,2,3,4,5,6,7,8,9,10 };\n\ncout &lt;&lt; &quot;整个数组所占内存空间为： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;\ncout &lt;&lt; &quot;每个元素所占内存空间为： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;\ncout &lt;&lt; &quot;数组的元素个数为： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;\n\n//2、可以通过数组名获取到数组首地址\ncout &lt;&lt; &quot;数组首地址为： &quot; &lt;&lt; (int)arr &lt;&lt; endl;\ncout &lt;&lt; &quot;数组中第一个元素地址为： &quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;\ncout &lt;&lt; &quot;数组中第二个元素地址为： &quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;\n\n//arr = 100; 错误，数组名是常量，因此不可以赋值\n\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>注意：数组名是常量，不可以赋值</p>\n<p>总结 1：直接打印数组名，可以查看数组所占内存的首地址</p>\n<p>总结 2：对数组名进行 sizeof，可以获取整个数组占内存空间的大小</p>\n<p>练习案例 1：五只小猪称体重</p>\n<p>案例描述：</p>\n<p>在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};</p>\n<p>找出并打印最重的小猪体重。</p>\n<p>练习案例 2：数组元素逆置</p>\n<p>案例描述：请声明一个 5 个元素的数组，并且将元素逆置.</p>\n<p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);</p>\n<p>5.2.3 冒泡排序<br>作用： 最常用的排序算法，对数组内元素进行排序</p>\n<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。<br>重复以上的步骤，每次比较次数-1，直到不需要比较<br>![1541905327273](C:\\Users\\Zhenglin Li\\Desktop\\assets\\1541905327273.png)</p>\n<p>示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</p>\n<p>C++<br>int main() {</p>\n<pre><code>int arr[9] = { 4,2,8,0,5,7,1,3,9 };\n\nfor (int i = 0; i &lt; 9 - 1; i++)\n{\n    for (int j = 0; j &lt; 9 - 1 - i; j++)\n    {\n        if (arr[j] &gt; arr[j + 1])\n        {\n            int temp = arr[j];\n            arr[j] = arr[j + 1];\n            arr[j + 1] = temp;\n        }\n    }\n}\n\nfor (int i = 0; i &lt; 9; i++)\n{\n    cout &lt;&lt; arr[i] &lt;&lt; endl;\n}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>5.3 二维数组<br>二维数组就是在一维数组上，多加一个维度。</p>\n<p>![1541905559138](C:\\Users\\Zhenglin Li\\Desktop\\assets\\1541905559138.png)</p>\n<p>5.3.1 二维数组定义方式<br>二维数组定义的四种方式：</p>\n<p>数据类型 数组名[ 行数 ][ 列数 ];<br>数据类型 数组名[ 行数 ][ 列数 ] = { {数据 1，数据 2 } ，{数据 3，数据 4 } };<br>数据类型 数组名[ 行数 ][ 列数 ] = { 数据 1，数据 2，数据 3，数据 4};<br>数据类型 数组名[ ][ 列数 ] = { 数据 1，数据 2，数据 3，数据 4};<br>建议：以上 4 种定义方式，利用==第二种更加直观，提高代码的可读性==</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>//方式1\n//数组类型 数组名 [行数][列数]\nint arr[2][3];\narr[0][0] = 1;\narr[0][1] = 2;\narr[0][2] = 3;\narr[1][0] = 4;\narr[1][1] = 5;\narr[1][2] = 6;\n\nfor (int i = 0; i &lt; 2; i++)\n{\n    for (int j = 0; j &lt; 3; j++)\n    {\n        cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n}\n\n//方式2\n//数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } };\nint arr2[2][3] =\n{\n    {1,2,3},\n    {4,5,6}\n};\n\n//方式3\n//数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4  };\nint arr3[2][3] = { 1,2,3,4,5,6 };\n\n//方式4\n//数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4  };\nint arr4[][3] = { 1,2,3,4,5,6 };\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p>\n<p>5.3.2 二维数组数组名<br>查看二维数组所占内存空间<br>获取二维数组首地址<br>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>//二维数组数组名\nint arr[2][3] =\n{\n    {1,2,3},\n    {4,5,6}\n};\n\ncout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;\ncout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;\ncout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;\n\ncout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;\ncout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl;\n\n//地址\ncout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl;\ncout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl;\ncout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl;\n\ncout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl;\ncout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结 1：二维数组名就是这个数组的首地址</p>\n<p>总结 2：对二维数组名进行 sizeof 时，可以获取整个二维数组占用的内存空间大小</p>\n<p>5.3.3 二维数组应用案例<br>考试成绩统计：</p>\n<p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩</p>\n<p>语文 数学 英语<br>张三 100 100 100<br>李四 90 50 100<br>王五 60 70 80<br>参考答案：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int scores[3][3] =\n{\n    {100,100,100},\n    {90,50,100},\n    {60,70,80},\n};\n\nstring names[3] = { &quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot; };\n\nfor (int i = 0; i &lt; 3; i++)\n{\n    int sum = 0;\n    for (int j = 0; j &lt; 3; j++)\n    {\n        sum += scores[i][j];\n    }\n    cout &lt;&lt; names[i] &lt;&lt; &quot;同学总成绩为： &quot; &lt;&lt; sum &lt;&lt; endl;\n}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>6 函数<br>6.1 概述<br>作用：将一段经常使用的代码封装起来，减少重复代码</p>\n<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>\n<p>6.2 函数的定义<br>函数的定义一般主要有 5 个步骤：</p>\n<p>1、返回值类型</p>\n<p>2、函数名</p>\n<p>3、参数表列</p>\n<p>4、函数体语句</p>\n<p>5、return 表达式</p>\n<p>语法：</p>\n<p>C++<br>返回值类型 函数名 （参数列表）<br>{</p>\n<pre><code>函数体语句\n\nreturn表达式</code></pre><p>}<br>返回值类型 ：一个函数可以返回一个值。在函数定义中<br>函数名：给函数起个名称<br>参数列表：使用该函数时，传入的数据<br>函数体语句：花括号内的代码，函数内需要执行的语句<br>return 表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据<br>示例：定义一个加法函数，实现两个数相加</p>\n<p>C++<br>//函数定义<br>int add(int num1, int num2)<br>{<br>int sum = num1 + num2;<br>return sum;<br>}<br>6.3 函数的调用<br>功能：使用定义好的函数</p>\n<p>语法：函数名（参数）</p>\n<p>示例：</p>\n<p>C++<br>//函数定义<br>int add(int num1, int num2) //定义中的 num1,num2 称为形式参数，简称形参<br>{<br>int sum = num1 + num2;<br>return sum;<br>}</p>\n<p>int main() {</p>\n<pre><code>int a = 10;\nint b = 10;\n//调用add函数\nint sum = add(a, b);//调用时的a，b称为实际参数，简称实参\ncout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;\n\na = 100;\nb = 100;\n\nsum = add(a, b);\ncout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p>\n<p>6.4 值传递<br>所谓值传递，就是函数调用时实参将数值传入给形参<br>值传递时，==如果形参发生，并不会影响实参==<br>示例：</p>\n<p>C++<br>void swap(int num1, int num2)<br>{<br>cout &lt;&lt; “交换前：” &lt;&lt; endl;<br>cout &lt;&lt; “num1 = “ &lt;&lt; num1 &lt;&lt; endl;<br>cout &lt;&lt; “num2 = “ &lt;&lt; num2 &lt;&lt; endl;</p>\n<pre><code>int temp = num1;\nnum1 = num2;\nnum2 = temp;\n\ncout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;\ncout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;\n\n//return ; 当函数声明时候，不需要返回值，可以不写return</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>int a = 10;\nint b = 20;\n\nswap(a, b);\n\ncout &lt;&lt; &quot;mian中的 a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;mian中的 b = &quot; &lt;&lt; b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 值传递时，形参是修饰不了实参的</p>\n<p>6.5 函数的常见样式<br>常见的函数样式有 4 种</p>\n<p>无参无返<br>有参无返<br>无参有返<br>有参有返<br>示例：</p>\n<p>C++<br>//函数常见样式<br>//1、 无参无返<br>void test01()<br>{<br>//void a = 10; //无类型不可以创建变量,原因无法分配内存<br>cout &lt;&lt; “this is test01” &lt;&lt; endl;<br>//test01(); 函数调用<br>}</p>\n<p>//2、 有参无返<br>void test02(int a)<br>{<br>cout &lt;&lt; “this is test02” &lt;&lt; endl;<br>cout &lt;&lt; “a = “ &lt;&lt; a &lt;&lt; endl;<br>}</p>\n<p>//3、无参有返<br>int test03()<br>{<br>cout &lt;&lt; “this is test03 “ &lt;&lt; endl;<br>return 10;<br>}</p>\n<p>//4、有参有返<br>int test04(int a, int b)<br>{<br>cout &lt;&lt; “this is test04 “ &lt;&lt; endl;<br>int sum = a + b;<br>return sum;<br>}<br>6.6 函数的声明<br>作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>\n<p>函数的声明可以多次，但是函数的定义只能有一次<br>示例：</p>\n<p>C++<br>//声明可以多次，定义只能一次<br>//声明<br>int max(int a, int b);<br>int max(int a, int b);<br>//定义<br>int max(int a, int b)<br>{<br>return a &gt; b ? a : b;<br>}</p>\n<p>int main() {</p>\n<pre><code>int a = 100;\nint b = 200;\n\ncout &lt;&lt; max(a, b) &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>6.7 函数的分文件编写<br>作用：让代码结构更加清晰</p>\n<p>函数分文件编写一般有 4 个步骤</p>\n<p>创建后缀名为.h 的头文件<br>创建后缀名为.cpp 的源文件<br>在头文件中写函数的声明<br>在源文件中写函数的定义<br>示例：</p>\n<p>C++<br>//swap.h 文件<br>#include<iostream><br>using namespace std;</p>\n<p>//实现两个数字交换的函数声明<br>void swap(int a, int b);<br>C++<br>//swap.cpp 文件<br>#include “swap.h”</p>\n<p>void swap(int a, int b)<br>{<br>int temp = a;<br>a = b;<br>b = temp;</p>\n<pre><code>cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</code></pre><p>}<br>C++<br>//main 函数文件<br>#include “swap.h”<br>int main() {</p>\n<pre><code>int a = 100;\nint b = 200;\nswap(a, b);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>7 指针<br>7.1 指针的基本概念<br>指针的作用： 可以通过指针间接访问内存</p>\n<p>内存编号是从 0 开始记录的，一般用十六进制数字表示<br>可以利用指针变量保存地址<br>7.2 指针变量的定义和使用<br>指针变量定义语法： 数据类型 * 变量名；</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>//1、指针的定义\nint a = 10; //定义整型变量a\n\n//指针定义语法： 数据类型 * 变量名 ;\nint * p;\n\n//指针变量赋值\np = &amp;a; //指针指向变量a的地址\ncout &lt;&lt; &amp;a &lt;&lt; endl; //打印数据a的地址\ncout &lt;&lt; p &lt;&lt; endl;  //打印指针变量p\n\n//2、指针的使用\n//通过*操作指针变量指向的内存\ncout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>指针变量和普通变量的区别</p>\n<p>普通变量存放的是数据,指针变量存放的是地址<br>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用<br>总结 1： 我们可以通过 &amp; 符号 获取变量的地址</p>\n<p>总结 2：利用指针可以记录地址</p>\n<p>总结 3：对指针变量解引用，可以操作指针指向的内存</p>\n<p>7.3 指针所占内存空间<br>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int a = 10;\n\nint * p;\np = &amp;a; //指针指向数据a的地址\n\ncout &lt;&lt; *p &lt;&lt; endl; //* 解引用\ncout &lt;&lt; sizeof(p) &lt;&lt; endl;\ncout &lt;&lt; sizeof(char *) &lt;&lt; endl;\ncout &lt;&lt; sizeof(float *) &lt;&lt; endl;\ncout &lt;&lt; sizeof(double *) &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：所有指针类型在 32 位操作系统下是 4 个字节</p>\n<p>7.4 空指针和野指针<br>空指针：指针变量指向内存中编号为 0 的空间</p>\n<p>用途：初始化指针变量</p>\n<p>注意：空指针指向的内存是不可以访问的</p>\n<p>示例 1：空指针</p>\n<p>C++<br>int main() {</p>\n<pre><code>//指针变量p指向内存地址编号为0的空间\nint * p = NULL;\n\n//访问空指针报错\n//内存编号0 ~255为系统占用内存，不允许用户访问\ncout &lt;&lt; *p &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>野指针：指针变量指向非法的内存空间</p>\n<p>示例 2：野指针</p>\n<p>C++<br>int main() {</p>\n<pre><code>//指针变量p指向内存地址编号为0x1100的空间\nint * p = (int *)0x1100;\n\n//访问野指针报错\ncout &lt;&lt; *p &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p>\n<p>7.5 const 修饰指针<br>const 修饰指针有三种情况</p>\n<p>const 修饰指针 — 常量指针<br>const 修饰常量 — 指针常量<br>const 即修饰指针，又修饰常量<br>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int a = 10;\nint b = 10;\n\n//const修饰的是指针，指针指向可以改，指针指向的值不可以更改\nconst int * p1 = &amp;a;\np1 = &amp;b; //正确\n//*p1 = 100;  报错\n\n\n//const修饰的是常量，指针指向不可以改，指针指向的值可以更改\nint * const p2 = &amp;a;\n//p2 = &amp;b; //错误\n*p2 = 100; //正确\n\n//const既修饰指针又修饰常量\nconst int * const p3 = &amp;a;\n//p3 = &amp;b; //错误\n//*p3 = 100; //错误\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>技巧：看 const 右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p>\n<p>7.6 指针和数组<br>作用：利用指针访问数组中元素</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int arr[] = { 1,2,3,4,5,6,7,8,9,10 };\n\nint * p = arr;  //指向数组的指针\n\ncout &lt;&lt; &quot;第一个元素： &quot; &lt;&lt; arr[0] &lt;&lt; endl;\ncout &lt;&lt; &quot;指针访问第一个元素： &quot; &lt;&lt; *p &lt;&lt; endl;\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    //利用指针遍历数组\n    cout &lt;&lt; *p &lt;&lt; endl;\n    p++;\n}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>7.7 指针和函数<br>作用：利用指针作函数参数，可以修改实参的值</p>\n<p>示例：</p>\n<p>C++<br>//值传递<br>void swap1(int a ,int b)<br>{<br>int temp = a;<br>a = b;<br>b = temp;<br>}<br>//地址传递<br>void swap2(int * p1, int *p2)<br>{<br>int temp = *p1;<br>*p1 = *p2;<br>*p2 = temp;<br>}</p>\n<p>int main() {</p>\n<pre><code>int a = 10;\nint b = 20;\nswap1(a, b); // 值传递不会改变实参\n\nswap2(&amp;a, &amp;b); //地址传递会改变实参\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\n\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>\n<p>7.8 指针、数组、函数<br>案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p>\n<p>例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };</p>\n<p>示例：</p>\n<p>C++<br>//冒泡排序函数<br>void bubbleSort(int _ arr, int len) //int _ arr 也可以写为 int arr[]<br>{<br>for (int i = 0; i &lt; len - 1; i++)<br>{<br>for (int j = 0; j &lt; len - 1 - i; j++)<br>{<br>if (arr[j] &gt; arr[j + 1])<br>{<br>int temp = arr[j];<br>arr[j] = arr[j + 1];<br>arr[j + 1] = temp;<br>}<br>}<br>}<br>}</p>\n<p>//打印数组函数<br>void printArray(int arr[], int len)<br>{<br>for (int i = 0; i &lt; len; i++)<br>{<br>cout &lt;&lt; arr[i] &lt;&lt; endl;<br>}<br>}</p>\n<p>int main() {</p>\n<pre><code>int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };\nint len = sizeof(arr) / sizeof(int);\n\nbubbleSort(arr, len);\n\nprintArray(arr, len);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p>\n<p>8 结构体<br>8.1 结构体基本概念<br>结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型</p>\n<p>8.2 结构体定义和使用<br>语法：struct 结构体名 { 结构体成员列表 }；</p>\n<p>通过结构体创建变量的方式有三种：</p>\n<p>struct 结构体名 变量名<br>struct 结构体名 变量名 = { 成员 1 值 ， 成员 2 值…}<br>定义结构体时顺便创建变量<br>示例：</p>\n<p>C++<br>//结构体定义<br>struct student<br>{<br>//成员列表<br>string name; //姓名<br>int age; //年龄<br>int score; //分数<br>}stu3; //结构体变量创建方式 3</p>\n<p>int main() {</p>\n<pre><code>//结构体变量创建方式1\nstruct student stu1; //struct 关键字可以省略\n\nstu1.name = &quot;张三&quot;;\nstu1.age = 18;\nstu1.score = 100;\n\ncout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu1.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu1.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu1.score &lt;&lt; endl;\n\n//结构体变量创建方式2\nstruct student stu2 = { &quot;李四&quot;,19,60 };\n\ncout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu2.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu2.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu2.score &lt;&lt; endl;\n\n\nstu3.name = &quot;王五&quot;;\nstu3.age = 18;\nstu3.score = 80;\n\n\ncout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu3.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu3.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu3.score &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结 1：定义结构体时的关键字是 struct，不可省略</p>\n<p>总结 2：创建结构体变量时，关键字 struct 可以省略</p>\n<p>总结 3：结构体变量利用操作符 ‘’.’’ 访问成员</p>\n<p>8.3 结构体数组<br>作用：将自定义的结构体放入到数组中方便维护</p>\n<p>语法：struct 结构体名 数组名[元素个数] = { {} , {} , … {} }</p>\n<p>示例：</p>\n<p>C++<br>//结构体定义<br>struct student<br>{<br>//成员列表<br>string name; //姓名<br>int age; //年龄<br>int score; //分数<br>}</p>\n<p>int main() {<br>//结构体数组<br>struct student arr[3]=<br>{<br>{“张三”,18,80 },<br>{“李四”,19,60 },<br>{“王五”,20,70 }<br>};</p>\n<pre><code>for (int i = 0; i &lt; 3; i++)\n{\n    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; arr[i].age &lt;&lt; &quot; 分数：&quot; &lt;&lt; arr[i].score &lt;&lt; endl;\n}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>8.4 结构体指针<br>作用：通过指针访问结构体中的成员</p>\n<p>利用操作符 -&gt;可以通过结构体指针访问结构体属性<br>示例：</p>\n<p>C++<br>//结构体定义<br>struct student<br>{<br>//成员列表<br>string name; //姓名<br>int age; //年龄<br>int score; //分数<br>};</p>\n<p>int main() {<br>struct student stu = { “张三”,18,100, };<br>struct student * p = &stu;<br>p-&gt;score = 80; //指针通过 -&gt; 操作符可以访问成员</p>\n<pre><code>cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p>\n<p>8.5 结构体嵌套结构体<br>作用： 结构体中的成员可以是另一个结构体</p>\n<p>例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p>\n<p>示例：</p>\n<p>C++<br>//学生结构体定义<br>struct student<br>{<br>//成员列表<br>string name; //姓名<br>int age; //年龄<br>int score; //分数<br>};</p>\n<p>//教师结构体定义<br>struct teacher<br>{<br>//成员列表<br>int id; //职工编号<br>string name; //教师姓名<br>int age; //教师年龄<br>struct student stu; //子结构体 学生<br>};</p>\n<p>int main() {</p>\n<pre><code>struct teacher t1;\nt1.id = 10000;\nt1.name = &quot;老王&quot;;\nt1.age = 40;\n\nt1.stu.name = &quot;张三&quot;;\nt1.stu.age = 18;\nt1.stu.score = 100;\n\ncout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl;\n\ncout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p>\n<p>8.6 结构体做函数参数<br>作用：将结构体作为参数向函数中传递</p>\n<p>传递方式有两种：</p>\n<p>值传递<br>地址传递<br>示例：</p>\n<p>C++<br>//学生结构体定义<br>struct student<br>{<br>//成员列表<br>string name; //姓名<br>int age; //年龄<br>int score; //分数<br>};</p>\n<p>//值传递<br>void printStudent(student stu )<br>{<br>stu.age = 28;<br>cout &lt;&lt; “子函数中 姓名：” &lt;&lt; stu.name &lt;&lt; “ 年龄： “ &lt;&lt; stu.age &lt;&lt; “ 分数：” &lt;&lt; stu.score &lt;&lt; endl;<br>}</p>\n<p>//地址传递<br>void printStudent2(student *stu)<br>{<br>stu-&gt;age = 28;<br>cout &lt;&lt; “子函数中 姓名：” &lt;&lt; stu-&gt;name &lt;&lt; “ 年龄： “ &lt;&lt; stu-&gt;age &lt;&lt; “ 分数：” &lt;&lt; stu-&gt;score &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>student stu = { &quot;张三&quot;,18,100};\n//值传递\nprintStudent(stu);\ncout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;\n\ncout &lt;&lt; endl;\n\n//地址传递\nprintStudent2(&amp;stu);\ncout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p>\n<p>8.7 结构体中 const 使用场景<br>作用：用 const 来防止误操作</p>\n<p>示例：</p>\n<p>C++<br>//学生结构体定义<br>struct student<br>{<br>//成员列表<br>string name; //姓名<br>int age; //年龄<br>int score; //分数<br>};</p>\n<p>//const 使用场景<br>void printStudent(const student *stu) //加 const 防止函数体中的误操作<br>{<br>//stu-&gt;age = 100; //操作失败，因为加了 const 修饰<br>cout &lt;&lt; “姓名：” &lt;&lt; stu-&gt;name &lt;&lt; “ 年龄：” &lt;&lt; stu-&gt;age &lt;&lt; “ 分数：” &lt;&lt; stu-&gt;score &lt;&lt; endl;</p>\n<p>}</p>\n<p>int main() {</p>\n<pre><code>student stu = { &quot;张三&quot;,18,100 };\n\nprintStudent(&amp;stu);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>8.8 结构体案例<br>8.8.1 案例 1<br>案例描述：</p>\n<p>学校正在做毕设项目，每名老师带领 5 个学生，总共有 3 名老师，需求如下</p>\n<p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放 5 名学生的数组作为成员</p>\n<p>学生的成员有姓名、考试分数，创建数组存放 3 名老师，通过函数给每个老师及所带的学生赋值</p>\n<p>最终打印出老师数据以及老师所带的学生数据。</p>\n<p>示例：</p>\n<p>C++<br>struct Student<br>{<br>string name;<br>int score;<br>};<br>struct Teacher<br>{<br>string name;<br>Student sArray[5];<br>};</p>\n<p>void allocateSpace(Teacher tArray[] , int len)<br>{<br>string tName = “教师”;<br>string sName = “学生”;<br>string nameSeed = “ABCDE”;<br>for (int i = 0; i &lt; len; i++)<br>{<br>tArray[i].name = tName + nameSeed[i];<br>for (int j = 0; j &lt; 5; j++)<br>{<br>tArray[i].sArray[j].name = sName + nameSeed[j];<br>tArray[i].sArray[j].score = rand() % 61 + 40;<br>}<br>}<br>}</p>\n<p>void printTeachers(Teacher tArray[], int len)<br>{<br>for (int i = 0; i &lt; len; i++)<br>{<br>cout &lt;&lt; tArray[i].name &lt;&lt; endl;<br>for (int j = 0; j &lt; 5; j++)<br>{<br>cout &lt;&lt; “\\t 姓名：” &lt;&lt; tArray[i].sArray[j].name &lt;&lt; “ 分数：” &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;<br>}<br>}<br>}</p>\n<p>int main() {</p>\n<pre><code>srand((unsigned int)time(NULL)); //随机数种子 头文件 #include &lt;ctime&gt;\n\nTeacher tArray[3]; //老师数组\n\nint len = sizeof(tArray) / sizeof(Teacher);\n\nallocateSpace(tArray, len); //创建数据\n\nprintTeachers(tArray, len); //打印数据\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>8.8.2 案例 2<br>案例描述：</p>\n<p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放 5 名英雄。</p>\n<p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p>\n<p>五名英雄信息如下：</p>\n<p>C++<br>{“刘备”,23,”男”},<br>{“关羽”,22,”男”},<br>{“张飞”,20,”男”},<br>{“赵云”,21,”男”},<br>{“貂蝉”,19,”女”},<br>示例：</p>\n<p>C++<br>//英雄结构体<br>struct hero<br>{<br>string name;<br>int age;<br>string sex;<br>};<br>//冒泡排序<br>void bubbleSort(hero arr[] , int len)<br>{<br>for (int i = 0; i &lt; len - 1; i++)<br>{<br>for (int j = 0; j &lt; len - 1 - i; j++)<br>{<br>if (arr[j].age &gt; arr[j + 1].age)<br>{<br>hero temp = arr[j];<br>arr[j] = arr[j + 1];<br>arr[j + 1] = temp;<br>}<br>}<br>}<br>}<br>//打印数组<br>void printHeros(hero arr[], int len)<br>{<br>for (int i = 0; i &lt; len; i++)<br>{<br>cout &lt;&lt; “姓名： “ &lt;&lt; arr[i].name &lt;&lt; “ 性别： “ &lt;&lt; arr[i].sex &lt;&lt; “ 年龄： “ &lt;&lt; arr[i].age &lt;&lt; endl;<br>}<br>}</p>\n<p>int main() {</p>\n<pre><code>struct hero arr[5] =\n{\n    {&quot;刘备&quot;,23,&quot;男&quot;},\n    {&quot;关羽&quot;,22,&quot;男&quot;},\n    {&quot;张飞&quot;,20,&quot;男&quot;},\n    {&quot;赵云&quot;,21,&quot;男&quot;},\n    {&quot;貂蝉&quot;,19,&quot;女&quot;},\n};\n\nint len = sizeof(arr) / sizeof(hero); //获取数组元素个数\n\nbubbleSort(arr, len); //排序\n\nprintHeros(arr, len); //打印\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}</p>\n"},{"title":"A first look at C++ (1) copy 1","url":"/2023/01/18/A%20first%20look%20at%20C++%20(1)%20copy%201/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"Introduction-to-C-Basics\"><a href=\"#Introduction-to-C-Basics\" class=\"headerlink\" title=\"Introduction to C++ Basics\"></a>Introduction to C++ Basics</h1><h1 id=\"1-Introduction-to-C\"><a href=\"#1-Introduction-to-C\" class=\"headerlink\" title=\"1 Introduction to C++\"></a>1 Introduction to C++</h1><h1 id=\"First-C-program\"><a href=\"#First-C-program\" class=\"headerlink\" title=\"First C++ program\"></a>First C++ program</h1><p>There are 4 steps to writing a C++ program</p>\n<p>Creating a project<br>Creating the file<br>Writing the code<br>Running the program<br>1.1.1 Creating a project<br>Visual Studio is the main tool we use to write C++ programs, so let’s open it first<br>! [1541383178746](C:\\Users\\Zhenglin Li\\Desktop\\assets\\1541383178746.png)</p>\n<p>! [1541384366413](C:\\Users\\Zhenglin Li\\Desktop\\assets\\1541384366413.png)</p>\n<p>1.1.2 Create the file<br>Right-click the source file and select Add-&gt;New Item</p>\n<p>! [1541383817248](C:\\Users\\Zhenglin Li\\Desktop\\assets\\1541383817248.png)</p>\n<p>Give the C++ file a name, and click Add.</p>\n<p>! [1541384140042](C:\\Users\\Zhenglin Li\\Desktop\\assets\\1541384140042.png)</p>\n<p>1.1.3 Writing the code<br>C++<br>#include<iostream><br>using namespace std;</p>\n<p>int main() {</p>\n<pre><code>cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>1.1.4 Running the program<br>! [1541384818688](C:\\Users\\Zhenglin Li\\Desktop\\assets\\1541384818688.png)</p>\n<h1 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h1><p>Function: Add some notes and explanations to the code to make it easier for yourself or other programmers programmers to read the code</p>\n<p>Two formats</p>\n<p>Single line comments: // descriptive information<br>usually placed above a line of code, or at the end of a statement, == description of the line of code ==<br>Multi-line comments: /_ descriptive information _/<br>Usually placed at the top of a line of code, == an overall description of the line of code ==<br>Tip: The compiler ignores comments when compiling code</p>\n<h1 id=\"Variables\"><a href=\"#Variables\" class=\"headerlink\" title=\"Variables\"></a>Variables</h1><p>Function: Name a specified section of memory to facilitate manipulation of that memory.</p>\n<p>Syntax: Data type Variable name = initial value;</p>\n<p>Example.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//variable definition</span></span><br><span class=\"line\">    <span class=\"comment\">// Syntax: data type Variable name = initial value</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Note: C++ must give the variable an initial value when creating it, otherwise it will report an error</p>\n<h1 id=\"constants\"><a href=\"#constants\" class=\"headerlink\" title=\"constants\"></a>constants</h1><p>Role: Used to record data that cannot be changed in the program</p>\n<p>C++ defines constants in two ways</p>\n<p>#define macro constants: #define constant name constant value<br>== is usually defined at the top of the file ==, indicating a constant<br>const modified variable const data type constant name = constant value<br>== usually precedes the variable definition with the keyword const==, which modifies the variable as a constant and cannot be modified<br>Example.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1/1. Macro constants</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> day 7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"There are a total of \"</span> &lt;&lt; day &lt;&lt; <span class=\"string\">\" days in a week\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//day = 8; // error, macro constants can not be modified</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2. const modifies variables</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> month = <span class=\"number\">12</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"There are a total of \"</span> &lt;&lt; month &lt;&lt; <span class=\"string\">\" months in a year\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">// month = 24; // error, const is not modifiable</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"keywords\"><a href=\"#keywords\" class=\"headerlink\" title=\"keywords\"></a>keywords</h1><p>Role: Keywords are pre-preserved words (identifiers) in C++</p>\n<p>When defining variables or constants, do not use keywords<br>C++ keywords are as follows.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">asm</span> <span class=\"keyword\">do</span> <span class=\"keyword\">if</span> <span class=\"keyword\">return</span> <span class=\"keyword\">typedef</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> <span class=\"keyword\">double</span> <span class=\"keyword\">inline</span> short <span class=\"keyword\">typeid</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">dynamic_cast</span> <span class=\"keyword\">int</span> <span class=\"keyword\">signed</span> <span class=\"keyword\">typename</span></span><br><span class=\"line\"><span class=\"keyword\">break</span> <span class=\"keyword\">else</span> <span class=\"keyword\">long</span> <span class=\"keyword\">sizeof</span> <span class=\"keyword\">union</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">enum</span> <span class=\"keyword\">mutable</span> <span class=\"keyword\">static</span> <span class=\"keyword\">unsigned</span></span><br><span class=\"line\"><span class=\"keyword\">catch</span> <span class=\"keyword\">explicit</span> <span class=\"keyword\">namespace</span> <span class=\"keyword\">static_cast</span> <span class=\"keyword\">using</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> <span class=\"keyword\">export</span> <span class=\"keyword\">new</span> struct <span class=\"keyword\">virtual</span></span><br><span class=\"line\">class <span class=\"keyword\">extern</span> <span class=\"keyword\">operator</span> <span class=\"keyword\">switch</span> <span class=\"keyword\">void</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"literal\">false</span> <span class=\"keyword\">private</span> <span class=\"keyword\">template</span> <span class=\"keyword\">volatile</span></span><br><span class=\"line\"><span class=\"keyword\">const_cast</span> <span class=\"keyword\">float</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">this</span> <span class=\"keyword\">wchar_t</span></span><br><span class=\"line\"><span class=\"keyword\">continue</span> <span class=\"keyword\">for</span> <span class=\"keyword\">public</span> <span class=\"keyword\">throw</span> <span class=\"keyword\">while</span></span><br><span class=\"line\"><span class=\"keyword\">default</span> <span class=\"keyword\">friend</span> <span class=\"keyword\">register</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">goto</span> <span class=\"keyword\">reinterpret_cast</span> <span class=\"keyword\">try</span></span><br></pre></td></tr></table></figure>\n\n<p>Tip: When naming variables or constants, do not use C++ keywords, otherwise ambiguity will arise.</p>\n<h1 id=\"Identifier-naming-rules\"><a href=\"#Identifier-naming-rules\" class=\"headerlink\" title=\"Identifier naming rules\"></a>Identifier naming rules</h1><p>Function: C++ has its own rules for naming identifiers (variables, constants)</p>\n<p>Identifiers cannot be keywords.<br>Identifiers can only consist of letters, numbers, and underscores<br>The first character must be a letter or an underscore<br>Letters in identifiers are case-sensitive<br>Suggestions: When naming identifiers, try to achieve the effect of knowing the name to make it easier for yourself and others to read</p>\n<!--\n# C++基础入门\n\n# 1 C++初识\n\n# 第一个 C++程序\n\n编写一个 C++程序总共分为 4 个步骤\n\n创建项目\n创建文件\n编写代码\n运行程序\n1.1.1 创建项目\nVisual Studio 是我们用来编写 C++程序的主要工具，我们先将它打开\n![1541383178746](C:\\Users\\Zhenglin Li\\Desktop\\assets\\1541383178746.png)\n\n![1541384366413](C:\\Users\\Zhenglin Li\\Desktop\\assets\\1541384366413.png)\n\n1.1.2 创建文件\n右键源文件，选择添加->新建项\n\n![1541383817248](C:\\Users\\Zhenglin Li\\Desktop\\assets\\1541383817248.png)\n\n给 C++文件起个名称，然后点击添加即可。\n\n![1541384140042](C:\\Users\\Zhenglin Li\\Desktop\\assets\\1541384140042.png)\n\n1.1.3 编写代码\nC++\n#include<iostream>\nusing namespace std;\n\nint main() {\n\n    cout << \"Hello world\" << endl;\n\n    system(\"pause\");\n\n    return 0;\n\n}\n1.1.4 运行程序\n![1541384818688](C:\\Users\\Zhenglin Li\\Desktop\\assets\\1541384818688.png)\n\n# 注释\n\n作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码\n\n两种格式\n\n单行注释：// 描述信息\n通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明==\n多行注释： /_ 描述信息 _/\n通常放在一段代码的上方，==对该段代码做整体说明==\n提示：编译器在编译代码时，会忽略注释的内容\n\n# 变量\n\n作用：给一段指定的内存空间起名，方便操作这段内存\n\n语法：数据类型 变量名 = 初始值;\n\n示例：\n\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//变量的定义</span></span><br><span class=\"line\">    <span class=\"comment\">//语法：数据类型  变量名 = 初始值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p>\n<h1 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h1><p>作用：用于记录程序中不可更改的数据</p>\n<p>C++定义常量两种方式</p>\n<p>#define 宏常量： #define 常量名 常量值<br>==通常在文件上方定义==，表示一个常量<br>const 修饰的变量 const 数据类型 常量名 = 常量值<br>==通常在变量定义前加关键字 const==，修饰该变量为常量，不可修改<br>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、宏常量</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> day 7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"一周里总共有 \"</span> &lt;&lt; day &lt;&lt; <span class=\"string\">\" 天\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//day = 8;  //报错，宏常量不可以修改</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2、const修饰变量</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> month = <span class=\"number\">12</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"一年里总共有 \"</span> &lt;&lt; month &lt;&lt; <span class=\"string\">\" 个月份\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//month = 24; //报错，常量是不可以修改的</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h1><p>作用：关键字是 C++中预先保留的单词（标识符）</p>\n<p>在定义变量或者常量时候，不要用关键字<br>C++关键字如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">asm</span> <span class=\"keyword\">do</span> <span class=\"keyword\">if</span> <span class=\"keyword\">return</span> <span class=\"keyword\">typedef</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> <span class=\"keyword\">double</span> <span class=\"keyword\">inline</span> short <span class=\"keyword\">typeid</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">dynamic_cast</span> <span class=\"keyword\">int</span> <span class=\"keyword\">signed</span> <span class=\"keyword\">typename</span></span><br><span class=\"line\"><span class=\"keyword\">break</span> <span class=\"keyword\">else</span> <span class=\"keyword\">long</span> <span class=\"keyword\">sizeof</span> <span class=\"keyword\">union</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">enum</span> <span class=\"keyword\">mutable</span> <span class=\"keyword\">static</span> <span class=\"keyword\">unsigned</span></span><br><span class=\"line\"><span class=\"keyword\">catch</span> <span class=\"keyword\">explicit</span> <span class=\"keyword\">namespace</span> <span class=\"keyword\">static_cast</span> <span class=\"keyword\">using</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> <span class=\"keyword\">export</span> <span class=\"keyword\">new</span> struct <span class=\"keyword\">virtual</span></span><br><span class=\"line\">class <span class=\"keyword\">extern</span> <span class=\"keyword\">operator</span> <span class=\"keyword\">switch</span> <span class=\"keyword\">void</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"literal\">false</span> <span class=\"keyword\">private</span> <span class=\"keyword\">template</span> <span class=\"keyword\">volatile</span></span><br><span class=\"line\"><span class=\"keyword\">const_cast</span> <span class=\"keyword\">float</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">this</span> <span class=\"keyword\">wchar_t</span></span><br><span class=\"line\"><span class=\"keyword\">continue</span> <span class=\"keyword\">for</span> <span class=\"keyword\">public</span> <span class=\"keyword\">throw</span> <span class=\"keyword\">while</span></span><br><span class=\"line\"><span class=\"keyword\">default</span> <span class=\"keyword\">friend</span> <span class=\"keyword\">register</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">goto</span> <span class=\"keyword\">reinterpret_cast</span> <span class=\"keyword\">try</span></span><br></pre></td></tr></table></figure>\n\n<p>提示：在给变量或者常量起名称时候，不要用 C++得关键字，否则会产生歧义。</p>\n<h1 id=\"标识符命名规则\"><a href=\"#标识符命名规则\" class=\"headerlink\" title=\"标识符命名规则\"></a>标识符命名规则</h1><p>作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p>\n<p>标识符不能是关键字<br>标识符只能由字母、数字、下划线组成<br>第一个字符必须为字母或下划线<br>标识符中字母区分大小写<br>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读 –&gt;</p>\n"},{"title":"A first look at C++ (1) copy 2","url":"/2023/01/18/A%20first%20look%20at%20C++%20(1)%20copy%202/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"Data-Types\"><a href=\"#Data-Types\" class=\"headerlink\" title=\"Data Types\"></a>Data Types</h1><p>C++ requires that when creating a variable or constant, the corresponding data type must be specified, otherwise memory cannot be allocated to the variable</p>\n<h1 id=\"integer\"><a href=\"#integer\" class=\"headerlink\" title=\"integer\"></a>integer</h1><p>Role: Integer variables represent data of == integer type ==</p>\n<p>There are several ways to represent integer types in C++, the difference being that they occupy different memory space.</p>\n<p>Data type Space occupied Range of values<br>short(short integer) 2 bytes (-2^15 ~ 2^15-1)<br>int(integer) 4 bytes (-2^31 ~ 2^31-1)<br>long(long plastic) 4 bytes for Windows, 4 bytes for Linux (32 bits), 8 bytes (64 bits) (-2^31 ~ 2^31-1)<br>long long(long long shaped) 8 bytes (-2^63 ~ 2^63-1)</p>\n<h1 id=\"sizeof-keyword\"><a href=\"#sizeof-keyword\" class=\"headerlink\" title=\"sizeof keyword\"></a>sizeof keyword</h1><p>Function: The sizeof keyword can be used to == count the amount of memory occupied by a data type ==</p>\n<p>Syntax: sizeof( datatype / variable)</p>\n<p>Example</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"The memory space occupied by the short type is: \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(short) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"The memory space occupied by the int type is: \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"The memory space occupied by the long type is: \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">long</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"The memory space occupied by the long long type is: \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Integer conclusion: ==short &lt; int &lt;= long &lt;= long long ==</p>\n<h1 id=\"Real-type-floating-point\"><a href=\"#Real-type-floating-point\" class=\"headerlink\" title=\"Real type (floating point)\"></a>Real type (floating point)</h1><p>Role: Used to == represent decimals ==</p>\n<p>There are two types of floating-point variables.</p>\n<p>Single-precision float<br>double precision double<br>The difference between the two is that they represent different ranges of valid numbers.</p>\n<p>Data type Space occupied Valid number range<br>float 4 bytes 7 significant digits<br>double 8 bytes 15 to 16 significant digits<br>Example.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">float</span> f1 = <span class=\"number\">3.14f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> d1 = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; f1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; d1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"float sizeof = \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(f1) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"double sizeof = \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(d1) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Scientific notation</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> f2 = <span class=\"number\">3e2</span>; <span class=\"comment\">// 3 * 10 ^ 2</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"f2 = \"</span> &lt;&lt; f2 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">float</span> f3 = <span class=\"number\">3e-2</span>; <span class=\"comment\">// 3 * 0.1 ^ 2</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"f3 = \"</span> &lt;&lt; f3 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Character-type\"><a href=\"#Character-type\" class=\"headerlink\" title=\"Character type\"></a>Character type</h1><p>Function: Character type variables are used to display a single character</p>\n<p>Syntax: char ch = ‘a’;</p>\n<p>Note 1: When displaying character variables, enclose the characters in single quotes, not double quotes</p>\n<p>Note 2: Only one character can be enclosed in single quotes, not a string</p>\n<p>Character variables in C and C++ occupy only ==1 byte==.<br>Character variables do not put the character itself into memory, but put the corresponding ASCII code into the memory cell.<br>Example.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">char</span> ch = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; ch &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//ch = \"abcde\"; //error, no double quotes</span></span><br><span class=\"line\">    <span class=\"comment\">//ch = 'abcde'; //error, only one character can be quoted inside single quotes</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (<span class=\"keyword\">int</span>)ch &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//check the ASCII code corresponding to character a</span></span><br><span class=\"line\">    ch = <span class=\"number\">97</span>; <span class=\"comment\">//you can directly assign a value to a character variable using ASCII</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ch &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ASCII code table.</p>\n<p>ASCII value Control character ASCII value Character ASCII value Character ASCII value Character<br>0 NUT 32 (space) 64 @ 96 ,<br>1 SOH 33 ! 65 A 97 a<br>2 STX 34 “ 66 B 98 b<br>3 ETX 35 # 67 C 99 c<br>4 eot 36 $ 68 d 100 d<br>5 enq 37 % 69 e 101 e<br>6 ACK 38 &amp; 70 F 102 f<br>7 bel 39 , 71 g 103 g<br>8 bs 40 ( 72 h 104 h<br>9 HT 41 ) 73 I 105 i<br>10 LF 42 * 74 J 106 j<br>11 VT 43 + 75 K 107 k<br>12 ff 44 , 76 l 108 l<br>13 cr 45 - 77 m 109 m<br>14 SO 46 . 78 N 110 n<br>15 SI 47 / 79 O 111 o<br>16 DLE 48 0 80 P 112 p<br>17 dci 49 1 81 q 113 q<br>18 dc2 50 2 82 r 114 r<br>19 dc3 51 3 83 s 115 s<br>20 dc4 52 4 84 t 116 t<br>21 nak 53 5 85 u 117 u<br>22 SYN 54 6 86 V 118 v<br>23 TB 55 7 87 W 119 w<br>24 can 56 8 88 x 120 x<br>25 em 57 9 89 y 121 y<br>26 SUB 58 : 90 Z 122 z<br>27 ESC 59 ; 91 [ 123 {<br>28 FS 60 &lt; 92 / 124 |<br>29 gs 61 = 93 ] 125 }<br>30 RS 62 &gt; 94 ^ 126 `<br>31 US 63 ? 95 _ 127 DEL<br>The ASCII code consists of roughly the following two parts.</p>\n<p>ASCII non-printing control characters: the numbers 0-31 on the ASCII table are assigned to control characters that are used to control some peripheral devices like printers.<br>ASCII print characters: The numbers 32-126 are assigned to characters that can be found on the keyboard and appear when a document is viewed or printed.</p>\n<h1 id=\"Escape-characters\"><a href=\"#Escape-characters\" class=\"headerlink\" title=\"Escape characters\"></a>Escape characters</h1><p>Function: Used to represent some ASCII characters that == cannot be displayed==.</p>\n<p>At this stage we commonly used escape characters are: \\n \\\\t</p>\n<p>Escape character Meaning ASCII code value (decimal)<br>\\a Alarm 007<br>\\b Backspace (BS), move the current position to the previous column 008<br>\\f Page Feed (FF), move the current position to the beginning of the next page 012<br>\\n line feed (LF), move the current position to the beginning of the next line 010<br>\\r Carriage return (CR), the current position will be moved to the beginning of this line 013<br>\\t horizontal tab (HT) (jump to the next TAB position) 009<br>\\v Vertical tab (VT) 011<br>\\ represents a backslash character “” 092<br>‘ represents a single quote (apostrophe) character 039<br>“ represents a double quotation mark character 034<br>? represents a question mark 063<br>\\0 digits 0 000<br>\\ddd 8-entry escape character, d range 0<del>7 3-bit 8-entry<br>\\xhh 16-entry escape character, h range 09, af, A</del>F 3-bit hexadecimal<br>Example.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"\\\\\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"\\tHello\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"\\n\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.6 String type<br>Function: Used to represent a string of characters</p>\n<p>Two styles</p>\n<p>C style string: char variable name[] = “string value”</p>\n<p>Example.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span> str1[] = <span class=\"string\">\"hello world\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; str1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Note: C style strings should be enclosed in double quotes</p>\n<p>C++ style string: string Variable name = “string value”</p>\n<p>Example.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str = <span class=\"string\">\"hello world\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; str &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Note: C++ style strings, need to include header file == #include<string>==</p>\n<h1 id=\"boolean-type-bool\"><a href=\"#boolean-type-bool\" class=\"headerlink\" title=\"boolean type bool\"></a>boolean type bool</h1><p>Function: Boolean data type representing true or false values</p>\n<p>The bool type has only two values.</p>\n<p>true - true (essentially 1)<br>false - false (essentially 0)<br>bool type takes up == 1 byte == size</p>\n<p>Example.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; flag &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; flag &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"size of bool = \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">bool</span>) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Data-input\"><a href=\"#Data-input\" class=\"headerlink\" title=\"Data input\"></a>Data input</h1><p>Function: Used to get data from the keyboard</p>\n<p>Keyword: cin</p>\n<p>Syntax: cin &gt;&gt; variables</p>\n<p>Example.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//integer input</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Please enter integer variable:\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; a;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Floating-point input</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> d = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Please enter a floating-point variable:\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; d;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; d &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//character input</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Please enter a character variable:\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; ch;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ch &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//String input</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Please enter the string variable:\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; str;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; str &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Boolean input</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Please enter a boolean variable:\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; flag;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; flag &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<!--\n# 数据类型\n\nC++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存\n\n# 整型\n\n作用：整型变量表示的是==整数类型==的数据\n\nC++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：\n\n数据类型 占用空间 取值范围\nshort(短整型) 2 字节 (-2^15 ~ 2^15-1)\nint(整型) 4 字节 (-2^31 ~ 2^31-1)\nlong(长整形) Windows 为 4 字节，Linux 为 4 字节(32 位)，8 字节(64 位) (-2^31 ~ 2^31-1)\nlong long(长长整形) 8 字节 (-2^63 ~ 2^63-1)\n\n# sizeof 关键字\n\n作用：利用 sizeof 关键字可以==统计数据类型所占内存大小==\n\n语法： sizeof( 数据类型 / 变量)\n\n示例：\n\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"short 类型所占内存空间为： \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(short) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"int 类型所占内存空间为： \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"long 类型所占内存空间为： \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">long</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"long long 类型所占内存空间为： \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>整型结论：==short &lt; int &lt;= long &lt;= long long==</p>\n<h1 id=\"实型（浮点型）\"><a href=\"#实型（浮点型）\" class=\"headerlink\" title=\"实型（浮点型）\"></a>实型（浮点型）</h1><p>作用：用于==表示小数==</p>\n<p>浮点型变量分为两种：</p>\n<p>单精度 float<br>双精度 double<br>两者的区别在于表示的有效数字范围不同。</p>\n<p>数据类型 占用空间 有效数字范围<br>float 4 字节 7 位有效数字<br>double 8 字节 15 ～ 16 位有效数字<br>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">float</span> f1 = <span class=\"number\">3.14f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> d1 = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; f1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; d1&lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"float  sizeof = \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(f1) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"double sizeof = \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(d1) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//科学计数法</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> f2 = <span class=\"number\">3e2</span>; <span class=\"comment\">// 3 * 10 ^ 2</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"f2 = \"</span> &lt;&lt; f2 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">float</span> f3 = <span class=\"number\">3e-2</span>;  <span class=\"comment\">// 3 * 0.1 ^ 2</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"f3 = \"</span> &lt;&lt; f3 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"字符型\"><a href=\"#字符型\" class=\"headerlink\" title=\"字符型\"></a>字符型</h1><p>作用：字符型变量用于显示单个字符</p>\n<p>语法：char ch = ‘a’;</p>\n<p>注意 1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p>\n<p>注意 2：单引号内只能有一个字符，不可以是字符串</p>\n<p>C 和 C++中字符型变量只占用==1 个字节==。<br>字符型变量并不是把字符本身放到内存中存储，而是将对应的 ASCII 编码放入到存储单元<br>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">char</span> ch = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; ch &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//ch = \"abcde\"; //错误，不可以用双引号</span></span><br><span class=\"line\">    <span class=\"comment\">//ch = 'abcde'; //错误，单引号内只能引用一个字符</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (<span class=\"keyword\">int</span>)ch &lt;&lt; <span class=\"built_in\">endl</span>;  <span class=\"comment\">//查看字符a对应的ASCII码</span></span><br><span class=\"line\">    ch = <span class=\"number\">97</span>; <span class=\"comment\">//可以直接用ASCII给字符型变量赋值</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ch &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ASCII 码表格：</p>\n<p>ASCII 值 控制字符 ASCII 值 字符 ASCII 值 字符 ASCII 值 字符<br>0 NUT 32 (space) 64 @ 96 、<br>1 SOH 33 ! 65 A 97 a<br>2 STX 34 “ 66 B 98 b<br>3 ETX 35 # 67 C 99 c<br>4 EOT 36 $ 68 D 100 d<br>5 ENQ 37 % 69 E 101 e<br>6 ACK 38 &amp; 70 F 102 f<br>7 BEL 39 , 71 G 103 g<br>8 BS 40 ( 72 H 104 h<br>9 HT 41 ) 73 I 105 i<br>10 LF 42 * 74 J 106 j<br>11 VT 43 + 75 K 107 k<br>12 FF 44 , 76 L 108 l<br>13 CR 45 - 77 M 109 m<br>14 SO 46 . 78 N 110 n<br>15 SI 47 / 79 O 111 o<br>16 DLE 48 0 80 P 112 p<br>17 DCI 49 1 81 Q 113 q<br>18 DC2 50 2 82 R 114 r<br>19 DC3 51 3 83 S 115 s<br>20 DC4 52 4 84 T 116 t<br>21 NAK 53 5 85 U 117 u<br>22 SYN 54 6 86 V 118 v<br>23 TB 55 7 87 W 119 w<br>24 CAN 56 8 88 X 120 x<br>25 EM 57 9 89 Y 121 y<br>26 SUB 58 : 90 Z 122 z<br>27 ESC 59 ; 91 [ 123 {<br>28 FS 60 &lt; 92 / 124 |<br>29 GS 61 = 93 ] 125 }<br>30 RS 62 &gt; 94 ^ 126 `<br>31 US 63 ? 95 _ 127 DEL<br>ASCII 码大致由以下两部分组成：</p>\n<p>ASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。<br>ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</p>\n<h1 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h1><p>作用：用于表示一些==不能显示出来的 ASCII 字符==</p>\n<p>现阶段我们常用的转义字符有：\\n \\ \\t</p>\n<p>转义字符 含义 ASCII 码值（十进制）<br>\\a 警报 007<br>\\b 退格(BS) ，将当前位置移到前一列 008<br>\\f 换页(FF)，将当前位置移到下页开头 012<br>\\n 换行(LF) ，将当前位置移到下一行开头 010<br>\\r 回车(CR) ，将当前位置移到本行开头 013<br>\\t 水平制表(HT) （跳到下一个 TAB 位置） 009<br>\\v 垂直制表(VT) 011<br>\\ 代表一个反斜线字符”” 092<br>‘ 代表一个单引号（撇号）字符 039<br>“ 代表一个双引号字符 034<br>? 代表一个问号 063<br>\\0 数字 0 000<br>\\ddd 8 进制转义字符，d 范围 0<del>7 3 位 8 进制<br>\\xhh 16 进制转义字符，h 范围 09，af，A</del>F 3 位 16 进制<br>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"\\\\\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"\\tHello\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"\\n\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.6 字符串型<br>作用：用于表示一串字符</p>\n<p>两种风格</p>\n<p>C 风格字符串： char 变量名[] = “字符串值”</p>\n<p>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span> str1[] = <span class=\"string\">\"hello world\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; str1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：C 风格的字符串要用双引号括起来</p>\n<p>C++风格字符串： string 变量名 = “字符串值”</p>\n<p>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str = <span class=\"string\">\"hello world\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; str &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：C++风格字符串，需要加入头文件==#include<string>==</p>\n<h1 id=\"布尔类型-bool\"><a href=\"#布尔类型-bool\" class=\"headerlink\" title=\"布尔类型 bool\"></a>布尔类型 bool</h1><p>作用：布尔数据类型代表真或假的值</p>\n<p>bool 类型只有两个值：</p>\n<p>true — 真（本质是 1）<br>false — 假（本质是 0）<br>bool 类型占==1 个字节==大小</p>\n<p>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; flag &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; flag &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"size of bool = \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">bool</span>) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数据的输入\"><a href=\"#数据的输入\" class=\"headerlink\" title=\"数据的输入\"></a>数据的输入</h1><p>作用：用于从键盘获取数据</p>\n<p>关键字：cin</p>\n<p>语法： cin &gt;&gt; 变量</p>\n<p>示例：</p>\n<pre><code class=\"C++\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{\n\n    <span class=\"comment\">//整型输入</span>\n    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;\n    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入整型变量：\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;\n    <span class=\"built_in\">cin</span> &gt;&gt; a;\n    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;\n\n    <span class=\"comment\">//浮点型输入</span>\n    <span class=\"keyword\">double</span> d = <span class=\"number\">0</span>;\n    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入浮点型变量：\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;\n    <span class=\"built_in\">cin</span> &gt;&gt; d;\n    <span class=\"built_in\">cout</span> &lt;&lt; d &lt;&lt; <span class=\"built_in\">endl</span>;\n\n    <span class=\"comment\">//字符型输入</span>\n    <span class=\"keyword\">char</span> ch = <span class=\"number\">0</span>;\n    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入字符型变量：\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;\n    <span class=\"built_in\">cin</span> &gt;&gt; ch;\n    <span class=\"built_in\">cout</span> &lt;&lt; ch &lt;&lt; <span class=\"built_in\">endl</span>;\n\n    <span class=\"comment\">//字符串型输入</span>\n    <span class=\"built_in\">string</span> str;\n    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入字符串型变量：\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;\n    <span class=\"built_in\">cin</span> &gt;&gt; str;\n    <span class=\"built_in\">cout</span> &lt;&lt; str &lt;&lt; <span class=\"built_in\">endl</span>;\n\n    <span class=\"comment\">//布尔类型输入</span>\n    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>;\n    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入布尔型变量：\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;\n    <span class=\"built_in\">cin</span> &gt;&gt; flag;\n    <span class=\"built_in\">cout</span> &lt;&lt; flag &lt;&lt; <span class=\"built_in\">endl</span>;\n    system(<span class=\"string\">\"pause\"</span>);\n    <span class=\"keyword\">return</span> EXIT_SUCCESS;\n}\n``` --&gt;</code></pre>\n"},{"title":"A first look at C++ (1) copy 3","url":"/2023/01/18/A%20first%20look%20at%20C++%20(1)%20copy%203/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"Operators\"><a href=\"#Operators\" class=\"headerlink\" title=\"Operators\"></a>Operators</h1><p>Function: Operators used to perform code</p>\n<p>In this chapter, we will focus on the following types of operators.</p>\n<p>Types of operators What they do<br>Arithmetic operators are used to handle the four operations<br>Assignment operators are used to assign the value of an expression to a variable<br>Comparison operators are used to compare expressions and return a true or false value<br>Logical operators are used to return a true or false value depending on the value of the expression</p>\n<h1 id=\"Arithmetic-operators\"><a href=\"#Arithmetic-operators\" class=\"headerlink\" title=\"Arithmetic operators\"></a>Arithmetic operators</h1><p>Function: Used to handle the four operations</p>\n<p>Arithmetic operators include the following symbols.</p>\n<p>Operators Term Example Result</p>\n<ul>\n<li>Positive +3 3</li>\n</ul>\n<ul>\n<li>Negative sign -3 -3</li>\n</ul>\n<ul>\n<li>Add 10 + 5 15</li>\n</ul>\n<ul>\n<li>minus 10 - 5 5</li>\n</ul>\n<ul>\n<li>Multiply 10 * 5 50<br>/ divide 10 / 5 2<br>% Modulo (remainder) 10 % 3 1<br>++ Pre-increment a=2; b=++a; a=3; b=3;<br>++ post-increment a=2; b=a++; a=3; b=2;<ul>\n<li>Precedence decrement a=2; b=-a; a=1; b=1;</li>\n<li>posterior decrement a=2; b=a-; a=1; b=2;<br>Example 1.</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//addition, subtraction, multiplication and division</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a1 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b1 = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 + b1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 - b1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 * b1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 / b1 &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// the result of dividing two integers is still an integer</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a2 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b2 = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 / b2 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a3 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; // error reported, the divisor cannot be 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//two decimals can be divided</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> d1 = <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> d2 = <span class=\"number\">0.25</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; d1 / d2 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Summary: In division operations, the divisor cannot be 0</p>\n<p>Example 2.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//take modulo</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a1 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b1 = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"number\">10</span> % <span class=\"number\">3</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a2 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b2 = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 % b2 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a3 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b3 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; a3 % b3 &lt;&lt; endl; // when modulo operation, the divisor cannot be 0 either</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//two decimals cannot be modulo</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> d1 = <span class=\"number\">3.14</span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> d2 = <span class=\"number\">1.1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Summary: Only integer variables can be modulo</p>\n<p>Example 3.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// increment</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//incrementing after</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a++; <span class=\"comment\">// equivalent to a = a + 1</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 11</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// pre-increment</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">    ++b;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 11</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Difference</span></span><br><span class=\"line\">    <span class=\"comment\">//pre-increment first ++ the variable, then compute the expression</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a2 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b2 = ++a2 * <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; b2 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Post-increment calculates the expression first, then ++ the variable</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a3 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b3 = a3++ * <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; b3 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>To summarize: pre-increment first ++ the variable, then compute the expression, post-increment the opposite</p>\n<h1 id=\"assignment-operator\"><a href=\"#assignment-operator\" class=\"headerlink\" title=\"assignment operator\"></a>assignment operator</h1><p>Function: Assign the value of an expression to a variable</p>\n<p>The assignment operators include the following symbols.</p>\n<p>Operators Term Example Result<br>= assignment a=2; b=3; a=2; b=3;<br>+= Add equals a=0; a+=2; a=2;<br>-= minus equals a=5; a-=3; a=2;<br><em>= Multiply equals a=2; a</em>=2; a=4;<br>/= divide equals a=4; a/=2; a=2;<br>%= modulo equals a=3; a%2; a=1;<br>Example.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// assignment operator</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// =</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// +=</span></span><br><span class=\"line\">    a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a += <span class=\"number\">2</span>; <span class=\"comment\">// a = a + 2;</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// -=</span></span><br><span class=\"line\">    a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a -= <span class=\"number\">2</span>; <span class=\"comment\">// a = a - 2</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// *=</span></span><br><span class=\"line\">    a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a *= <span class=\"number\">2</span>; <span class=\"comment\">// a = a * 2</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// // =</span></span><br><span class=\"line\">    a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a /= <span class=\"number\">2</span>; <span class=\"comment\">// a = a / 2;</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// %=</span></span><br><span class=\"line\">    a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a %= <span class=\"number\">2</span>; <span class=\"comment\">// a = a % 2;</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Comparison-operators\"><a href=\"#Comparison-operators\" class=\"headerlink\" title=\"Comparison operators\"></a>Comparison operators</h1><p>Function: Used to compare expressions and return a true or false value</p>\n<p>The comparison operators have the following notation.</p>\n<p>Operator Term Example Result<br>== equal to 4 == 3 0<br>! = not equal to 4 ! = 3 1<br>&lt; less than 4 &lt; 3 0</p>\n<blockquote>\n<p>greater than 4 &gt; 3 1</p>\n<p>&lt;= less than or equal to 4 &lt;= 3 0<br>= greater than or equal to 4 &gt;= 1 1<br>Example.</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a == b) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a ! = b) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a &gt; b) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a &lt; b) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a &gt;= b) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a &lt;= b) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Note: In C and C++ comparison operations, == “true” is represented by the number “1” and “false” is represented by the number “0 “ to represent. ==</p>\n<h1 id=\"Logical-operators\"><a href=\"#Logical-operators\" class=\"headerlink\" title=\"Logical operators\"></a>Logical operators</h1><p>Function: Used to return a true or false value depending on the value of the expression.</p>\n<p>Logical operators have the following symbols.</p>\n<p>Operator Term Example Result<br>! non !a is true if a is false, or !a is false if a is true.<br>&amp;&amp; with a &amp;&amp; b The result is true if both a and b are true, otherwise it is false.<br>|| or a || b If one of a and b is true, the result is true, and if both are false, the result is false.<br>Example 1: Logical non</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// logical operators --- not</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; !a &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ! !a &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Summary: True to false, false to true</p>\n<p>Example 2: Logic and</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// logical operators --- with</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a &amp;&amp; b) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a &amp;&amp; b) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a &amp;&amp; b) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Summary: Summary of logical == and == operators: == same as true, the rest is false ==</p>\n<p>Example 3: Logical or</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// logical operators --- or</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a || b) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a || b) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a || b) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Logic == or == operator summary: == the same false as false, the rest is true ==</p>\n<!-- # 运算符\n\n作用：用于执行代码的运算\n\n本章我们主要讲解以下几类运算符：\n\n运算符类型 作用\n算术运算符 用于处理四则运算\n赋值运算符 用于将表达式的值赋给变量\n比较运算符 用于表达式的比较，并返回一个真值或假值\n逻辑运算符 用于根据表达式的值返回真值或假值\n\n# 算术运算符\n\n作用：用于处理四则运算\n\n算术运算符包括以下符号：\n\n运算符 术语 示例 结果\n\n- 正号 +3 3\n\n* 负号 -3 -3\n\n- 加 10 + 5 15\n\n* 减 10 - 5 5\n\n- 乘 10 \\* 5 50\n  / 除 10 / 5 2\n  % 取模(取余) 10 % 3 1\n  ++ 前置递增 a=2; b=++a; a=3; b=3;\n  ++ 后置递增 a=2; b=a++; a=3; b=2;\n  – 前置递减 a=2; b=–a; a=1; b=1;\n  – 后置递减 a=2; b=a–; a=1; b=2;\n  示例 1：\n\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加减乘除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a1 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b1 = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 + b1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 - b1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 * b1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 / b1 &lt;&lt; <span class=\"built_in\">endl</span>;  <span class=\"comment\">//两个整数相除结果依然是整数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a2 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b2 = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 / b2 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a3 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//两个小数可以相除</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> d1 = <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> d2 = <span class=\"number\">0.25</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; d1 / d2 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：在除法运算中，除数不能为 0</p>\n<p>示例 2：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//取模</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a1 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b1 = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"number\">10</span> % <span class=\"number\">3</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a2 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b2 = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 % b2 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a3 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b3 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//两个小数不可以取模</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> d1 = <span class=\"number\">3.14</span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> d2 = <span class=\"number\">1.1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：只有整型变量可以进行取模运算</p>\n<p>示例 3：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//递增</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//后置递增</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a++; <span class=\"comment\">//等价于a = a + 1</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 11</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//前置递增</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">    ++b;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 11</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//区别</span></span><br><span class=\"line\">    <span class=\"comment\">//前置递增先对变量进行++，再计算表达式</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a2 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b2 = ++a2 * <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; b2 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//后置递增先计算表达式，后对变量进行++</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a3 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b3 = a3++ * <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; b3 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p>\n<h1 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h1><p>作用：用于将表达式的值赋给变量</p>\n<p>赋值运算符包括以下几个符号：</p>\n<p>运算符 术语 示例 结果<br>= 赋值 a=2; b=3; a=2; b=3;<br>+= 加等于 a=0; a+=2; a=2;<br>-= 减等于 a=5; a-=3; a=2;<br><em>= 乘等于 a=2; a</em>=2; a=4;<br>/= 除等于 a=4; a/=2; a=2;<br>%= 模等于 a=3; a%2; a=1;<br>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//赋值运算符</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// =</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// +=</span></span><br><span class=\"line\">    a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a += <span class=\"number\">2</span>; <span class=\"comment\">// a = a + 2;</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// -=</span></span><br><span class=\"line\">    a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a -= <span class=\"number\">2</span>; <span class=\"comment\">// a = a - 2</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// *=</span></span><br><span class=\"line\">    a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a *= <span class=\"number\">2</span>; <span class=\"comment\">// a = a * 2</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// /=</span></span><br><span class=\"line\">    a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a /= <span class=\"number\">2</span>;  <span class=\"comment\">// a = a / 2;</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// %=</span></span><br><span class=\"line\">    a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a %= <span class=\"number\">2</span>;  <span class=\"comment\">// a = a % 2;</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h1><p>作用：用于表达式的比较，并返回一个真值或假值</p>\n<p>比较运算符有以下符号：</p>\n<p>运算符 术语 示例 结果<br>== 相等于 4 == 3 0<br>!= 不等于 4 != 3 1<br>&lt; 小于 4 &lt; 3 0</p>\n<blockquote>\n<pre><code>大于    4 &gt; 3   1</code></pre><p>&lt;= 小于等于 4 &lt;= 3 0<br>= 大于等于 4 &gt;= 1 1<br>示例：</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a == b) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a != b) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a &gt; b) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a &lt; b) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a &gt;= b) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a &lt;= b) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：C 和 C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。==</p>\n<h1 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h1><p>作用：用于根据表达式的值返回真值或假值</p>\n<p>逻辑运算符有以下符号：</p>\n<p>运算符 术语 示例 结果<br>! 非 !a 如果 a 为假，则!a 为真； 如果 a 为真，则!a 为假。<br>&amp;&amp; 与 a &amp;&amp; b 如果 a 和 b 都为真，则结果为真，否则为假。<br>|| 或 a || b 如果 a 和 b 有一个为真，则结果为真，二者都为假时，结果为假。<br>示例 1：逻辑非</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//逻辑运算符 --- 非</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; !a &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; !!a &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结： 真变假，假变真</p>\n<p>示例 2：逻辑与</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//逻辑运算符 --- 与</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a &amp;&amp; b) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a &amp;&amp; b) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a &amp;&amp; b) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：逻辑==与==运算符总结： ==同真为真，其余为假==</p>\n<p>示例 3：逻辑或</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//逻辑运算符 --- 或</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a || b) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a || b) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; (a || b) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>逻辑==或==运算符总结： ==同假为假，其余为真== –&gt;</p>\n"},{"title":"OS IPC Summary","url":"/2023/01/18/OS%20IPC%20Summary/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>无名管道 PIPE<br>特殊的文件存在于内核缓存，不存在于文件系统<br>仅限亲缘关系进程（父子，兄弟）<br>生命周期随进程<br>半双工，固定读端与写端，数据单向流动<br>无格式字节流</p>\n<p>有名管道 FIFO<br>设备文件存在于文件系统，Linux下类型为p<br>可以无关进程通信<br>全双工<br>无格式字节流</p>\n<p>共享内存 Shared Memory<br>最快的IPC方式<br>不同虚拟地址空间映射到同一物理内存<br>需要信号量来同步</p>\n<p>消息队列 Message Queue<br>消息链表存在于内核中<br>有特定格式与优先级<br>有队列最大长度和消息最大长度的限制<br>消息拷贝需要内核/用户态的转换</p>\n<p>信号量 Semaphores<br>不直接传递通信信息<br>用来实现同步/互斥</p>\n<p>信号 Signals<br>IPC中唯一的异步处理方式，发生在进程调度时内核态到用户态到上下文切换中</p>\n<p>处理方式<br>捕获<br>执行默认操作<br>忽略（有两个不能忽略）<br>分为<br>信号的可靠与不可靠只与信号值有关<br>不可靠信号（响应设置为默认动作，信号可能丢失）<br>可靠信号<br>来源<br>软件<br>硬件<br>socket<br>stream</p>\n"},{"title":"HTTP123","url":"/2023/01/18/HTTP123/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>// 【】的是没想起来的</p>\n<p>// 还差 SSL/TLS 相关的部分，不过应该也不重要？懂的兄弟们评论下</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3b3e1340c4343ed90181dd302944f4e~tplv-k3u1fbpfcp-watermark.image?\" alt=\"\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ebfba12fbda470ba5419f599361dfd9~tplv-k3u1fbpfcp-watermark.image?\" alt=\"\"></p>\n<p>理解队头阻塞（HOL）<br>HTTP1<br>非流水线式的，请求响应的形式，自然而然的，如果前面的请求没有得到回复，就有队头阻塞<br>HTTP1.1<br>流水线式的，按照 FIFO 没有优先级，如果前面的请求服务器处理的时间较长，则也会队头阻塞<br>HTTP2<br>多个 STREAM 复用一个 TCP 连接，TCP 如果发生丢包，后面的 TCP 到了也不能向上传递，也就是队头阻塞<br>HTTP 是什么<br>超文本传输协议</p>\n<p>超文本：超过了文本的内容，图片，视频，音频<br>传输：点对点之间的通信<br>协议：规范，守则<br>状态码<br>100：中间状态<br>200：成功<br>300：请求重定向<br>400：客户端错误<br>500：服务端错误<br>字段<br>host：【服务器域名】<br>connection：keep-alive，长连接<br>accept：接收的编码类型<br>content-length：内容长度<br>content-encoding：编码类型<br>content-type：数据的格式，text/html<br>ETag：摘要<br>Method：请求的方法<br>GET 和 POST<br>本质上是一样的，都是 HTTP 的方法<br>人为的定义，语义，是不一样的<br>获得/提交资源<br>可与/不可以保存书签<br>安全且幂等/不安全且不幂等<br>HTTPS<br>HTTP 相对 HTTPS 的缺点：</p>\n<p>冒充 -&gt; 数字证书<br>窃听 -&gt; 【混合加密】，交换密钥的时候是【非对称加密】，之后的通信是对称加密（性能好，无法安全交换密钥）<br>篡改 -&gt; 【摘要算法】<br>区别：</p>\n<p>HTTPS 建立连接时 TLS/SSL 需要 4 次握手</p>\n<p>安全的 HTTP</p>\n<p>端口号 【80 -&gt; 443】</p>\n<p>HTTP1.1<br>更灵活缓存处理: 引入 Etag(Entity tag)等目前常用的缓存相关策略<br>优化带宽使用: 引入 range 头域，支持 206(Partial Content)，用于数据断点续传。<br>错误机制更完善: 引入 24 个错误状态码，如 409(Conflict)请求资源与当前状态冲突； 410(Gone)资源在服务器上被永久删除<br>Host 头处理: 请求头中必须带上 host，否则会报 400 Bad Request，为了支持一台服务器上有多台虚拟主机，因此通常一个 IP 对应了多个域名<br>HTTP2<br>【基于 HTTPS，TLS1.2】</p>\n<p>【服务器推送】</p>\n<p>【二进制帧（利于计算机处理）】</p>\n<p>每一个请求/响应报文分成 2 个帧<br>HEADERS Frames/DATA Frames<br>【多个 STREAM 复用同一个 TCP 连接（问题：一个 TCP 丢包会丢失很多请求）】</p>\n<p>【CONNECTION/STREAM/MESSAGE/STREAM】<br>多个 STREAM 复用同一个 TCP 连接<br>相对于 HTTP1.1 提升很大，HTTP1.1 每一个连接都要 TCP 三次握手、慢启动、SSL/TLS 四次握手<br>【可以设置优先级 】<br>头部压缩（HPACK 算法）（静态编码表，动态编码表，哈夫曼编码）</p>\n<p>静态字典：用长度较小的索引号表示重复的字符串<br>动态字典：动态维护的，静态字典里没有的字符串<br>image.png<br>image.png</p>\n<p>HTTP3<br>基于 QUIC(基于 UDP)</p>\n<p>QUIC，基于 UDP 实现的可靠数据传输<br>TLS 升级到 1.3</p>\n<p>TLS1.3 只需要 3 次握手<br>头部压缩算法变为 QPACK</p>\n<p>静态编码表项变多了<br>哈夫曼编码基本没变<br>动态编码改变最大<br>HTTP2 时，如果第一个请求出现丢包，后续请求即使受到了也无法解码头部<br>建立两个单向的流来同步动态编码表<br>比 HTTP2 的改进</p>\n<p>网络状态迁移<br>优化握手<br>无队头阻塞，因为不基于 TCP 了<br>image.png<br>image.png</p>\n<p>HTTP1.1 如何优化<br>不发请求：<br>缓存：【增加缓存，ETag 头部存入摘要，服务器返回不含 body 的 304NOT MODIFIED】<br>减少请求：<br>服务器去重定向：【代理服务器配置重定向规则】<br>懒加载<br>多个资源合并<br>压缩<br>有损压缩<br>无损压缩</p>\n"},{"title":"A first look at C++ (7)","url":"/2023/01/18/A%20first%20look%20at%20C++%20(7)/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"Pointer-constants-and-constant-pointers\"><a href=\"#Pointer-constants-and-constant-pointers\" class=\"headerlink\" title=\"Pointer constants and constant pointers\"></a>Pointer constants and constant pointers</h1><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> i = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"keyword\">const</span> i = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"comment\">// They are exactly the same. This is something we want to be clear about. In short, you must remember that const and int which is written before does not affect the semantics.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *pi;</span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"keyword\">const</span> *pi;</span><br><span class=\"line\"><span class=\"comment\">//The above two ways of writing are the same, the value pointed to is immutable, pointing to mutable</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">1) const modifies the whole *pi (note that it is *pi and not pi). So *pi is a constant and cannot be reassigned.</span></span><br><span class=\"line\"><span class=\"comment\">2) pi is not modified by const, so pi is a pointer variable and can be reassigned to another memory address.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> pi;</span><br><span class=\"line\"><span class=\"comment\">// points to immutable, the value pointed to is mutable</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">1) pi is only a pointer constant because of the const modifier: that is, the value of pi is not modifiable (i.e., pi cannot be redirected to another variable)</span></span><br><span class=\"line\"><span class=\"comment\">2) The entire *pi is not preceded by the const modifier. That is, *pi is a variable and not a constant, so we can modify the value of the variable it points to by using *pi</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> i;</span><br><span class=\"line\"><span class=\"comment\">// pointing and the value pointed to are immutable</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Passing-function-parameters-in-C\"><a href=\"#Passing-function-parameters-in-C\" class=\"headerlink\" title=\"Passing function parameters in C\"></a>Passing function parameters in C</h2><h2 id=\"Value-passing\"><a href=\"#Value-passing\" class=\"headerlink\" title=\"Value passing\"></a>Value passing</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Exchg1</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">    tmp = x;</span><br><span class=\"line\">    x = y;</span><br><span class=\"line\">    y = tmp;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"x = %d, y = %d\\n\"</span>, x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">4</span>,b = <span class=\"number\">6</span>;</span><br><span class=\"line\">    Exchg1(a, b);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"a = %d, b = %d\\n\"</span>, a, b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The output of the program is.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">x &#x3D; 6, y &#x3D; 4.</span><br><span class=\"line\"></span><br><span class=\"line\">a &#x3D; 4, b &#x3D; 6.</span><br></pre></td></tr></table></figure>\n\n<p>A preparatory common sense</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> x;</span><br><span class=\"line\">x = a;</span><br><span class=\"line\">x = x + <span class=\"number\">3</span>;</span><br><span class=\"line\">a = <span class=\"number\">4</span>, x = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>The code of the operation done when Exchg1(a, b) is shown below.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x = a; <span class=\"comment\">/* ← */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> y = b; <span class=\"comment\">/* ← Note here that the first two lines are implicit operations when the function is called */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">tmp = x;</span><br><span class=\"line\">x = y;</span><br><span class=\"line\">y = tmp;</span><br></pre></td></tr></table></figure>\n\n<p>Note that in the call to execute the Exchg1 function I have artificially added the first two sentences.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x = a;</span><br><span class=\"line\"><span class=\"keyword\">int</span> y = b;</span><br></pre></td></tr></table></figure>\n\n<p>These are the two implied actions when the function is called. It does exist, but now I’ve just written it out explicitly. The problem is now clear. (See, now you think the function swaps a and b variables or just x and y variables?)</p>\n<p>It turns out that the function is actually called by implicitly assigning the values of the real parameters a and b to x and y respectively, and then there is no more operation on a and b inside the Exchg1 function you wrote. Only the x and y variables are exchanged. Of course the values of a and b are not changed! The function just passes the values of a and b to ** x** and y by assignment, and the function only manipulates the values of x and y, not the values of a and b. This is called value passing of parameters.</p>\n<p>It is the implicit assignment of the two operations that gives us the aforementioned confusion (it is a mistake to think that a and b have replaced x and y, and that the operation on x and y is the operation on a and b.). .</p>\n<h2 id=\"Address-passing\"><a href=\"#Address-passing\" class=\"headerlink\" title=\"Address passing\"></a>Address passing</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Exchg2</span><span class=\"params\">(<span class=\"keyword\">int</span> *px, <span class=\"keyword\">int</span> *py)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = *px;</span><br><span class=\"line\">\t*px = *py;</span><br><span class=\"line\">\t*py = tmp;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"*px = %d, *py = %d.\\n\"</span>, *px, *py);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">6</span>;</span><br><span class=\"line\">\tExchg2(&amp;a, &amp;b);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"a = %d, b = %d.\\n\"</span>, a, b);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Its output is.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">*px &#x3D; 6, *py &#x3D; 4.</span><br><span class=\"line\">a &#x3D; 6, b &#x3D; 4.</span><br></pre></td></tr></table></figure>\n\n<p>Look at the interface part of the function: Exchg2(int *px, int *py). Note that the parameters px, py are pointers.</p>\n<p>Then look at the call: Exchg2(&amp;a, &amp;b);</p>\n<p>It substitutes the address of a (&amp;a) to px and the address of b (&amp;b) to py. As with the value passing above, the function call does two implicit operations: it assigns the values of &amp;a, &amp;b to px and py.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">px = &amp;a;</span><br><span class=\"line\">py = &amp;b;</span><br></pre></td></tr></table></figure>\n\n<p>Oh! We find that it is actually not different from value passing, except that here the address values of a and b are passed to px and py, instead of the contents of a and b being passed.</p>\n<p>The entire Exchg2 function call is executed as follows.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">px = &amp;a; <span class=\"comment\">/* ← */</span></span><br><span class=\"line\">py = &amp;b; <span class=\"comment\">/* ← Note these two lines, which are implicit actions of the Exchg2 call. */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> tmp = *px;</span><br><span class=\"line\">*px = *py;</span><br><span class=\"line\">*py = tmp;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"*px =%d, *py = %d.\\n\"</span>, *px, *py);</span><br></pre></td></tr></table></figure>\n\n<p>Thus, there is the implicit assignment operation of the first two lines. We can now see that the values of the pointers px and py are already the address values of the a and b variables, respectively. Next, the operations on px and py are, of course, operations on the a and b variables themselves. So the swap in the function is an exchange of the a and b values.</p>\n<p>This is called address passing (passing the address of a and b to px and py), do you get it now?</p>\n<h1 id=\"c-reference-passing\"><a href=\"#c-reference-passing\" class=\"headerlink\" title=\"c++ reference passing\"></a>c++ reference passing</h1><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Exchg3</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x, <span class=\"keyword\">int</span> &amp;y)</span> <span class=\"comment\">/* Note that the format of the formal arguments at the definition is different from value passing */</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> tmp = x; <span class=\"number\">27</span>x = y;</span><br><span class=\"line\">y = tmp;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"x = %d, y = %d.\\n\"</span>, x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">6</span>;</span><br><span class=\"line\">Exchg3(a, b); <span class=\"comment\">/*Note: this is called the same way as value passing*/</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"a = %d, b = %d.\\n\"</span>, a, b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Output result.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">x &#x3D; 6, y &#x3D; 4.</span><br><span class=\"line\">a &#x3D; 6, b &#x3D; 4.</span><br></pre></td></tr></table></figure>\n\n<p>/*<br>This output is different from value passing. There is only one difference in the code format compared to value passing, namely at the definition.<br>Exchg3(int &amp;x, int &amp;y)<br>But we find that the values of a and b are switched. This means that Exchg3(a, b) is modifying the a and b variables, not just the x and y variables.<br>Let’s look at the definition of the Exchg3 function, Exchg3(int &amp;x, int &amp;y). The arguments x and y are int variables, so we can call the function as if it were a value pass (e.g., Exchg1(a, b);).<br>We can call the function as if it were value-passed (e.g., Exchg3(a, b);). However, x and y are preceded by a symbol “&amp;” (which does not take the address). With this, when calling Exchg3, the function will replace x and y with a and b, respectively, and we say: x and y refer to the a and b variables respectively. This means that the function can directly modify the values of a and b in the function.</p>\n<p>Finally, a comparison of value transfer and reference transfer.<br>(1) There is a difference in the function definition format: value transfer is defined as Exchg1(int x, int y); reference transfer is defined as Exchg3(int &amp;x, int &amp;y); 2) The call has the same format: value pass: Exchg1(a, b); reference pass: Exchg3(a, b); 3) The functions are different.<br>The value-passing function does not operate on the a and b variables themselves, but only assigns the a and b values to x and y. The function operates on the x and y variables instead of a and b, showing that the values of a and b are not modified by the Exchg1 function.<br>The reference-passing Exchg3(a, b) function replaces x and y with a and b. The function operates on the a and b variables themselves, so the values of a and b can be modified within the function.</p>\n<p>A pointer to another pointer address<br>Look at the following code.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">short <span class=\"keyword\">int</span> i = <span class=\"number\">50</span>;</span><br><span class=\"line\">short <span class=\"keyword\">int</span> *pi = &amp;i;</span><br><span class=\"line\">short <span class=\"keyword\">int</span> **ppi = &amp;pi; <span class=\"comment\">/* This is a pointer to a pointer, note the two \"*\" signs */</span></span><br></pre></td></tr></table></figure>\n\n<p>The first sentence: short int *_ppi; – declares a pointer variable ppi, which is used to store (or point to) the address of a pointer variable of type short int _.</p>\n<p>The second sentence: &amp;pi is to take the address of pi, **ppi = &amp;pi is to assign the address of pi to ppi. i.e., the address value 9 is assigned to ppi.</p>\n<p>Memory address → 5 6 7 8 9 10 11 12</p>\n<p>—+—— ———- ———- ———- —</p>\n<p>| 50 | | | 5 | | 9 |</p>\n<p>| short int i | | | short int pi |short int *ppi|</p>\n<p>As you can see from the figure, the content of the pointer variable ppi is the starting address of the pointer variable pi. So what is the value of …… ppi? – 9. What is the value of ppi? – 5, which is the value of pi. What is the value of *ppi? –50, the value of i, which is also the value of *pi. Oh! I don’t need to tell you too much, I believe you should understand this kind of pointer!</p>\n<p>An application example<br>An application example<br>(1) Design a function.</p>\n<p>C<br>void find1(char array[], char search, char *pa)<br>Requirements: The array array in the parameters of this function is a string ending with a value of 0. It is required to find the characters in the string array are the characters in the parameter search. If found, the function returns the third parameter (pa) as the address of the first character found in the array string. If not found, pa is 0.<br>Design: According to the question, the following code is implemented.</p>\n<p>C<br>void find1(char array[], char search, char <em>pa) {<br>int i;<br>for (i = 0; _(array + i) ! = ‘\\0’; i++) {<br>if (</em>(array + i) == search) {<br>pa = array + i;<br>break;<br>} else if (_(array + i) == 0) {<br>pa = 0;<br>break;<br>}<br>}<br>}<br>Do you think this function achieves the requested functionality?<br>Debugging.<br>I’ll call this function below to try it out.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[] = &#123;<span class=\"string\">\"afsdfsdfsdf\\0\"</span>&#125;;<span class=\"comment\">/* the string to be found */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> a = <span class=\"string\">'d'</span>; <span class=\"comment\">/* set the character to be found */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *p = <span class=\"number\">0</span>; <span class=\"comment\">/* If found, pointer p will point to the address of the 1st character found in the string. */</span></span><br><span class=\"line\">    find1(str, a, p); <span class=\"comment\">/* Call the function to perform the desired operation. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == p) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Not Find! \\n\"</span>); <span class=\"comment\">/* Output this sentence if not found */</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Find! p = %d\"</span>, p); <span class=\"comment\">/* output this sentence if found */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Analysis.<br>What do you think will be the output of the above code?<br>Run it and try.<br>LOL! How come the output is: Not Find!<br>instead of “Find!, ……”.<br>Obviously the value of a is ‘d’, and the fourth character of str string is ‘d’, it should be able to find ah!<br>Look at the function definition again.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find1</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"built_in\">array</span>[], <span class=\"keyword\">char</span> search, <span class=\"keyword\">char</span> *pa)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>Look at the call.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">find1(str, a, p);</span><br></pre></td></tr></table></figure>\n\n<p>In the way I analyzed it in Part V, the function call will make an implicit assignment to each argument.<br>The entire call is as follows.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">array</span> = str;</span><br><span class=\"line\">search = a;</span><br><span class=\"line\">pa = p; <span class=\"comment\">/* Please note: the above three sentences are implicit actions when called. */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i =<span class=\"number\">0</span>; *(<span class=\"built_in\">array</span>+i) ! = <span class=\"string\">'\\0'</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*(<span class=\"built_in\">array</span>+i) == search)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpa = <span class=\"built_in\">array</span> + i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (*(<span class=\"built_in\">array</span>+i)== <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpa = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Oh! There is no difference between the passing of the parameter pa and the parameter search, they are both value passing (small talk: address passing is actually address-value passing)! So the modification of the value of the form variable pa (which is of course an address value) does not change the value of the real variable p, so the value of p does not change (i.e. the pointing of p is not changed).<br>Correction.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find2</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"built_in\">array</span>[], <span class=\"keyword\">char</span> search, <span class=\"keyword\">char</span> **ppa)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; *(<span class=\"built_in\">array</span> + i) ! = <span class=\"number\">0</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*(<span class=\"built_in\">array</span> + i) == search)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        \t*ppa = <span class=\"built_in\">array</span> + i;</span><br><span class=\"line\">        \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(*(<span class=\"built_in\">array</span> + i) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">       \t    *ppa = <span class=\"number\">0</span>;</span><br><span class=\"line\">       \t    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The call to the main function is changed as follows.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">find2(str, a, &amp;p);</span><br></pre></td></tr></table></figure>\n\n<p>Call the function to perform the desired operation.<br>Re-analysis.<br>The entire operation when the function is called in this way becomes the following.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">array</span> = str; search = a; ppa = &amp;p; <span class=\"comment\">/* Note that the above three sentences are implied actions when called. */</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; *(<span class=\"built_in\">array</span> + i) ! = <span class=\"number\">0</span>; i++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*(<span class=\"built_in\">array</span> + i) == search) &#123;</span><br><span class=\"line\">\t\t*ppa = <span class=\"built_in\">array</span> + i <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (*(<span class=\"built_in\">array</span> + i)== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t*ppa = <span class=\"number\">0</span>; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>See what I mean? ppa points to the address of pointer p. A change to *ppa is a change to the value of p. You debug it yourself.<br>After the modification, the program will be able to perform the desired function. If you understand this example, you will have achieved the purpose of this article.</p>\n<h1 id=\"Function-Pointers\"><a href=\"#Function-Pointers\" class=\"headerlink\" title=\"Function Pointers\"></a>Function Pointers</h1><p>What is a function pointer?</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*FunP)(<span class=\"keyword\">int</span>) = MyFun;</span><br><span class=\"line\">    MyFun(<span class=\"number\">10</span>);</span><br><span class=\"line\">    (*FunP)(<span class=\"number\">20</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>With the FunP pointer variable, we can assign a value to it to point to MyFun and then call the MyFun function through FunP. See how I call the MyFun function from the FunP pointer variable: ``C</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">void</span> (*FunP)(<span class=\"keyword\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    MyFun(<span class=\"number\">10</span>); <span class=\"comment\">/* This is a direct call to the MyFun function */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    FunP = &amp;MyFun; <span class=\"comment\">/* assign the address of the MyFun function to the FunP variable */</span></span><br><span class=\"line\">    FunP = MyFun; <span class=\"comment\">/* assign the address of the MyFun function to the FunP variable */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    (*FunP)(<span class=\"number\">20</span>);<span class=\"comment\">/* (★) This is a call to the MyFun function via the function pointer variable FunP. */</span></span><br><span class=\"line\">    FunP(<span class=\"number\">20</span>); <span class=\"comment\">/* (★) This is a call to the MyFun function via the function pointer variable FunP. */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ðŸ™' ðŸ™'</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">1</span>) In fact, the function name of MyFun <span class=\"keyword\">and</span> FunP function pointer are the same, that is, both are function pointers.</span><br><span class=\"line\">MyFun function name is a function pointer constant, <span class=\"keyword\">while</span> FunP is a function number pointer variable, which is their relationship.</span><br><span class=\"line\"></span><br><span class=\"line\">(2) But if the function name calls have to be such as (\\*MyFun)(10), it is not convenient to write and read and not used to. That's why the designers of the C language designed it to allow MyFun(10) to be called in this form (which is much more convenient and the same as the form of the function in mathematics, isn't it?) .</span><br><span class=\"line\"></span><br><span class=\"line\">3) For the sake of consistency, the FunP function pointer variable can also be called in the form of FunP(10).</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">4</span>) When assigning values, you can FunP = &amp;MyFun form, <span class=\"keyword\">or</span> FunP = MyFun.</span><br><span class=\"line\"></span><br><span class=\"line\">The above code can be written in any way you like!</span><br><span class=\"line\">Please understand it <span class=\"keyword\">this</span> way! This is to help you to apply the function pointer! And finally...</span><br><span class=\"line\">Lastly -- <span class=\"keyword\">and</span> as a side note, in the function declaration.</span><br><span class=\"line\"></span><br><span class=\"line\">```C</span><br><span class=\"line\"><span class=\"keyword\">void</span> MyFun(<span class=\"keyword\">int</span>); <span class=\"comment\">/* Cannot be written as void (*MyFun)(int). */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> (*FunP)(<span class=\"keyword\">int</span>); <span class=\"comment\">/* Cannot be written as void FunP(int). */</span></span><br><span class=\"line\">Define the pointer type of a certain function</span><br><span class=\"line\">C</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*FunType)</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">FunType FunP; <span class=\"comment\">/* then declare the global FunP variable with the FunType type */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    FunType FunP;</span><br><span class=\"line\">    MyFun(<span class=\"number\">10</span>);</span><br><span class=\"line\">    FunP = &amp;MyFun;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Define a function pointer type named FunType instead of a FunType variable. Then, the FunType FunP clause declares a FunP as if it were PINT px;.<br>variable.</p>\n<p>A function pointer as a parameter to a function</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MyFun1</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MyFun2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MyFun3</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*FunType)</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>; <span class=\"comment\">/* ②. Define a function pointer type FunType, as long as the function type (parameters and return value) is the same, you can use it only to define */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CallMyFun</span><span class=\"params\">(FunType fp, <span class=\"keyword\">int</span> x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    CallMyFun(MyFun1, <span class=\"number\">10</span>); <span class=\"comment\">/* ⑤. Call the three different functions separately with the CallMyFun function */</span></span><br><span class=\"line\">    CallMyFun(MyFun2, <span class=\"number\">20</span>);</span><br><span class=\"line\">    CallMyFun(MyFun3, <span class=\"number\">30</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CallMyFun</span><span class=\"params\">(FunType fp, <span class=\"keyword\">int</span> x)</span> <span class=\"comment\">/* ③. The argument fp is of type FunType. */</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    fp(x);<span class=\"comment\">/* ④. The function passed in is executed via the pointer to fp. */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MyFun1</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> <span class=\"comment\">/* ①. This is a function with one argument, and the following two functions are the same. */</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Output in function MyFun1: %d\\n\"</span>, x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MyFun2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Output in function MyFun2: %d\\n\"</span>, x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MyFun3</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Output in function MyFun3: %d\\n\"</span>, x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ðŸ™' ðŸ™'</span><br><span class=\"line\"></span><br><span class=\"line\">Output result.</span><br><span class=\"line\"></span><br><span class=\"line\">Output in function MyFun1: <span class=\"number\">10</span></span><br><span class=\"line\">Output in function MyFun2: <span class=\"number\">20</span></span><br><span class=\"line\">Function</span><br><span class=\"line\"></span><br><span class=\"line\"># 指针常量和常量指针</span><br><span class=\"line\"></span><br><span class=\"line\">```C</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> i = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"keyword\">const</span> i = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"comment\">//它们是完全相同的。这一点我们是要清楚。总之，你务必要记住 const 与int 哪个写前都不影响语义。</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *pi;</span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"keyword\">const</span> *pi;</span><br><span class=\"line\"><span class=\"comment\">//上面两种写法是一样的，所指向的值不可变，指向可变</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">1）const 修饰的是整个*pi（注意是*pi 而不是 pi）。所以*pi 是常量，是不能被重新赋值的。</span></span><br><span class=\"line\"><span class=\"comment\">2）pi 前并没有用 const 修饰，所以 pi 是指针变量，能被赋值重新指向另一内存地址的。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> pi;</span><br><span class=\"line\"><span class=\"comment\">//指向不可变，所指向的值可变</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">1）pi 因为有了 const 的修饰，所以只是一个指针常量：也就是说 pi 值是不可修改的（即 pi 不可以重新指向其他变量了）</span></span><br><span class=\"line\"><span class=\"comment\">2）整个*pi 的前面没有 const 的修饰。也就是说，*pi 是变量而不是常量，所以我们可以通过*pi 来修改它所指向的变量的值</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> i;</span><br><span class=\"line\"><span class=\"comment\">//指向、所指向的值均不可变</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-语言中函数参数的传递\"><a href=\"#C-语言中函数参数的传递\" class=\"headerlink\" title=\"C 语言中函数参数的传递\"></a>C 语言中函数参数的传递</h1><h2 id=\"值传递\"><a href=\"#值传递\" class=\"headerlink\" title=\"值传递\"></a>值传递</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Exchg1</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">    tmp = x;</span><br><span class=\"line\">    x = y;</span><br><span class=\"line\">    y = tmp;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"x = %d, y = %d\\n\"</span>, x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">4</span>,b = <span class=\"number\">6</span>;</span><br><span class=\"line\">    Exchg1(a, b);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"a = %d, b = %d\\n\"</span>, a, b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序输出的结果是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">x &#x3D; 6, y &#x3D; 4.</span><br><span class=\"line\"></span><br><span class=\"line\">a &#x3D; 4, b &#x3D; 6.</span><br></pre></td></tr></table></figure>\n\n<p>一个预备的常识</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> x;</span><br><span class=\"line\">x = a;</span><br><span class=\"line\">x = x + <span class=\"number\">3</span>;</span><br><span class=\"line\">a = <span class=\"number\">4</span>、x = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>Exchg1(a, b)时所完成的操作代码如下所示。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x = a; <span class=\"comment\">/* ← */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> y = b; <span class=\"comment\">/* ← 注意这里，头两行是调用函数时的隐含操作 */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">tmp = x;</span><br><span class=\"line\">x = y;</span><br><span class=\"line\">y = tmp;</span><br></pre></td></tr></table></figure>\n\n<p>请注意在调用执行 Exchg1 函数的操作中我人为地加上了头两句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x = a;</span><br><span class=\"line\"><span class=\"keyword\">int</span> y = b;</span><br></pre></td></tr></table></figure>\n\n<p>这是调用函数时的两个隐含动作。它确实存在，现在我只不过把它显式地写了出来而已。问题一下就清晰起来啦。（看到这里，现在你认为函数里面交换操作的是 a、b 变量或者只是 x、y 变量呢？）</p>\n<p>原来 ，其实函数在调用时是隐含地把实参 a、b 的值分别赋值给了 x、y，之后在你写的 Exchg1 函数体内再也没有对 a、b 进行任何的操作了。交换的只是 x、y 变量。并不是 a、b。当然 a、b 的值没有改变啦！函数只是把 a、b 的值通过赋值传递给了** x**、y，函数里头操作的只是 x、y 的值并不是 a、b 的值。这就是所谓的参数的值传递了。</p>\n<p>正是因为它隐含了那两个的赋值操作，才让我们产生前述的迷惑（以为 a、b 已经代替了 x、y，对 x、y 的操作就是对 a、b 的操作了，这是一个错误的观点啊！）。</p>\n<h2 id=\"地址传递\"><a href=\"#地址传递\" class=\"headerlink\" title=\"地址传递\"></a>地址传递</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Exchg2</span><span class=\"params\">(<span class=\"keyword\">int</span> *px, <span class=\"keyword\">int</span> *py)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = *px;</span><br><span class=\"line\">\t*px = *py;</span><br><span class=\"line\">\t*py = tmp;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"*px = %d, *py = %d.\\n\"</span>, *px, *py);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">6</span>;</span><br><span class=\"line\">\tExchg2(&amp;a, &amp;b);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"a = %d, b = %d.\\n”, a, b);</span></span><br><span class=\"line\"><span class=\"string\">\treturn(0);</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>它的输出结果是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">*px &#x3D; 6, *py &#x3D; 4.</span><br><span class=\"line\">a &#x3D; 6, b &#x3D; 4.</span><br></pre></td></tr></table></figure>\n\n<p>看函数的接口部分：Exchg2(int *px, int *py)，请注意：参数 px、py 都是指针。</p>\n<p>再看调用处：Exchg2(&amp;a, &amp;b);</p>\n<p>它将 a 的地址（&amp;a）代入到 px，b 的地址（&amp;b）代入到 py。同上面的值传递一样，函数调用时作了两个隐含的操作：将&amp;a，&amp;b 的值赋值给了 px、py。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">px = &amp;a;</span><br><span class=\"line\">py = &amp;b;</span><br></pre></td></tr></table></figure>\n\n<p>呵呵！我们发现，其实它与值传递并没有什么不同，只不过这里是将 a、b 的地址值传递给了 px、py，而不是传递的 a、b 的内容，</p>\n<p>整个 Exchg2 函数调用是如下执行的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">px = &amp;a; <span class=\"comment\">/* ← */</span></span><br><span class=\"line\">py = &amp;b; <span class=\"comment\">/* ← 请注意这两行，它是调用 Exchg2 的隐含动作。*/</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> tmp = *px;</span><br><span class=\"line\">*px = *py;</span><br><span class=\"line\">*py = tmp;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"*px =%d, *py = %d.\\n\"</span>, *px, *py);</span><br></pre></td></tr></table></figure>\n\n<p>这样，有了头两行的隐含赋值操作。我们现在已经可以看出，指针 px、py 的值已经分别是 a、b 变量的地址值了。接下来，对 px、py 的操作当然也就是对 a、b 变量本身的操作了。所以函数里头的交换就是对 a、b 值的交换了，</p>\n<p>这就是所谓的地址传递（传递 a、b 的地址给了 px、py），你现在明白了吗？</p>\n<h1 id=\"c-引用传递\"><a href=\"#c-引用传递\" class=\"headerlink\" title=\"c++引用传递\"></a>c++引用传递</h1><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Exchg3</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x, <span class=\"keyword\">int</span> &amp;y)</span> <span class=\"comment\">/* 注意定义处的形式参数的格式与值传递不同 */</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> tmp = x; <span class=\"number\">27</span>x = y;</span><br><span class=\"line\">y = tmp;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"x = %d, y = %d.\\n\"</span>, x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">6</span>;</span><br><span class=\"line\">Exchg3(a, b); <span class=\"comment\">/*注意：这里调用方式与值传递一样*/</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"a = %d, b = %d.\\n”, a, b);</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">x &#x3D; 6, y &#x3D; 4.</span><br><span class=\"line\">a &#x3D; 6, b &#x3D; 4.</span><br></pre></td></tr></table></figure>\n\n<p>/*<br>这个输出结果与值传递不同。与值传递相比，代码格式上只有一处是不同的，即在定义处：<br>Exchg3(int &amp;x, int &amp;y)<br>但是我们发现 a 与 b 的值发生了对调。这说明了 Exchg3(a, b)里头修改的是 a、b 变量，而不只是修改 x、y 了。<br>我们先看 Exchg3 函数的定义处 Exchg3(int &amp;x, int &amp;y)。参数 x、y 是 int 的变量，调用时我们可以像值传递（如： Exchg1(a, b); ）一样调<br>用函数（如： Exchg3(a, b);）。但是 x、y 前都有一个符号“&amp;”（不是取地址的作用）。有了这个，调用 Exchg3 时函数会将 a、b 分别代替了 x、y 了，我们称：x、y 分别引用了 a、b 变量。这样函数里头操作的其实就是实参 a、b 本身了，也就是说函数里是可以直接修改到 a、b 的值了。</p>\n<p>最后对值传递与引用传递作一个比较：<br>1）在函数定义格式上有不同： 值传递在定义处是：Exchg1(int x, int y); 引用传递在这义处是：Exchg3(int &amp;x, int &amp;y);<br>2）调用时有相同的格式： 值传递：Exchg1(a, b); 引用传递：Exchg3(a, b);<br>3）功能上是不同的：<br>值传递的函数里操作的不是 a、b 变量本身，只是将 a、b 值赋给了 x、y。 函数里操作的只是 x、y 变量而不是 a、b，显示 a、b 的值不会被 Exchg1 函数 所修改。<br>引用传递 Exchg3(a, b)函数里是用 a、b 分别代替了 x、y。函数里操作 的就是 a、b 变量的本身，因此 a、b 的值可在函数里被修改的。</p>\n<p>指向另一指针地址的指针<br>看下面代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">short <span class=\"keyword\">int</span> i = <span class=\"number\">50</span>;</span><br><span class=\"line\">short <span class=\"keyword\">int</span> *pi = &amp;i;</span><br><span class=\"line\">short <span class=\"keyword\">int</span> **ppi = &amp;pi; <span class=\"comment\">/* 这是一个指向指针的指针，注意有两个“*”号 */</span></span><br></pre></td></tr></table></figure>\n\n<p>第一句：short int *_ppi; —— 声明了一个指针变量 ppi，这个 ppi 是用来存储（或称指向）一个 short int _ 类型指针变量的地址。</p>\n<p>第二句：&amp;pi 那就是取 pi 的地址，**ppi = &amp;pi 就是把 pi 的地址赋给 了 ppi。即将地址值 9 赋值给 ppi。如下图：</p>\n<p>内存地址 → 5 6 7 8 9 10 11 12</p>\n<p>——–+——————————————————————————————————————–</p>\n<p>| 50 | | | 5 | 9 |</p>\n<p>| short int i | | | short int pi |short int *ppi|</p>\n<p>从图中看出，指针变量 ppi 的内容就是指针变量 pi 的起始地址。于是…… ppi 的值是多少呢？—— 9。 ppi 的值是多少呢？—— 5，即 pi 的值。 <em>ppi 的值是多少呢？——50，即 i 的值，也是</em>pi 的值。 呵呵！不用我说太多了，我相信你应明白这种指针了吧！</p>\n<p>一个应用实例<br>一个应用实例<br>（1）设计一个函数：</p>\n<p>C<br>void find1(char array[], char search, char *pa)<br>要求：这个函数参数中的数组 array 是以 0 值为结束的字符串，要求在字符串 array 中查找字符是参数 search 里的字符。如果找到，函数通过第三个参数 （pa）返回值为 array 字符串中第一个找到的字符的地址。如果没找到，则为 pa 为 0。<br>设计：依题意，实现代码如下。</p>\n<p>C<br>void find1(char array[], char search, char <em>pa) {<br>int i;<br>for (i = 0; _(array + i) != ‘\\0’; i++) {<br>if (</em>(array + i) == search) {<br>pa = array + i;<br>break;<br>} else if (_(array + i) == 0) {<br>pa = 0;<br>break;<br>}<br>}<br>}<br>你觉得这个函数能实现所要求的功能吗？<br>调试：<br>我下面调用这个函数试试。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[] = &#123;<span class=\"string\">\"afsdfsdfdf\\0\"</span>&#125;;<span class=\"comment\">/* 待查找的字符串 */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> a = <span class=\"string\">'d'</span>;<span class=\"comment\">/* 设置要查找的字符 */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *p = <span class=\"number\">0</span>; <span class=\"comment\">/* 如果查找到后指针 p 将指向字符串中查找到的第 1 个字符的地址。 */</span></span><br><span class=\"line\">    find1(str, a, p); <span class=\"comment\">/* 调用函数以实现所要操作。 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == p) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Not Find! \\n\"</span>); <span class=\"comment\">/* 如果没找到则输出此句 */</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Find! p = %d\"</span>, p); <span class=\"comment\">/* 如果找到则输出此句*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分析：<br>上面代码，你认为会是输出什么呢？<br>运行试试。<br>唉！怎么输出的是：Not Find!<br>而不是“Find!，……”。<br>明明 a 值为’d’，而 str 字符串的第四个字符是’d’，应该找得到呀！<br>再看函数定义处：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find1</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"built_in\">array</span>[], <span class=\"keyword\">char</span> search, <span class=\"keyword\">char</span> *pa)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>看调用处：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">find1(str, a, p);</span><br></pre></td></tr></table></figure>\n\n<p>依我在第伍篇的分析方法，函数调用时会对每一个参数进行一个隐含的赋值操作。<br>整个调用如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">array</span> = str;</span><br><span class=\"line\">search = a;</span><br><span class=\"line\">pa = p; <span class=\"comment\">/* 请注意：以上三句是调用时隐含的动作。*/</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i =<span class=\"number\">0</span>; *(<span class=\"built_in\">array</span>+i) != <span class=\"string\">'\\0'</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*(<span class=\"built_in\">array</span>+i) == search)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpa = <span class=\"built_in\">array</span> + i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (*(<span class=\"built_in\">array</span>+i)==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpa=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>哦！参数 pa 与参数 search 的传递并没有什么不同，都是值传递嘛（小语：地址传递其实就是地址值传递嘛）！所以对形参变量 pa 值（当然值是一个地址值）的修改并不会改变实参变量 p 值，因此 p 的值并没有改变(即 p 的指向并没有被改变)。<br>修正：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find2</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"built_in\">array</span>[], <span class=\"keyword\">char</span> search, <span class=\"keyword\">char</span> **ppa)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; *(<span class=\"built_in\">array</span> + i) != <span class=\"number\">0</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*(<span class=\"built_in\">array</span> + i) == search)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        \t*ppa = <span class=\"built_in\">array</span> + i;</span><br><span class=\"line\">        \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(*(<span class=\"built_in\">array</span> + i) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">       \t    *ppa = <span class=\"number\">0</span>;</span><br><span class=\"line\">       \t    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主函数的调用处改如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">find2(str, a, &amp;p);</span><br></pre></td></tr></table></figure>\n\n<p>调用函数以实现所要操作。<br>再分析：<br>这样调用函数时的整个操作变成如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">array</span> = str; search = a; ppa = &amp;p; <span class=\"comment\">/* 请注意：以上三句是调用时隐含的动作。 */</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; *(<span class=\"built_in\">array</span> + i) != <span class=\"number\">0</span>; i++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*(<span class=\"built_in\">array</span> + i) == search) &#123;</span><br><span class=\"line\">\t\t*ppa = <span class=\"built_in\">array</span> + i <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (*(<span class=\"built_in\">array</span>+i)==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t*ppa=<span class=\"number\">0</span>; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看明白了吗？ ppa 指向指针 p 的地址。 对*ppa 的修改就是对 p 值的修改。 你自行去调试。<br>经过修改后的程序就可以完成所要的功能了。 看懂了这个例子，也就达到了本篇所要求的目的。</p>\n<h1 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h1><p>什么是函数指针</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*FunP)(<span class=\"keyword\">int</span>) = MyFun;</span><br><span class=\"line\">    MyFun(<span class=\"number\">10</span>);</span><br><span class=\"line\">    (*FunP)(<span class=\"number\">20</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有了 FunP 指针变量后，我们就可以对它赋值指向 MyFun，然后通过 FunP 来调用 MyFun 函数了。看我如何通过 FunP 指针变量来调用 MyFun 函数的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">void</span> (*FunP)(<span class=\"keyword\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    MyFun(<span class=\"number\">10</span>); <span class=\"comment\">/* 这是直接调用 MyFun 函数 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    FunP = &amp;MyFun; <span class=\"comment\">/* 将 MyFun 函数的地址赋给 FunP 变量 */</span></span><br><span class=\"line\">    FunP = MyFun; <span class=\"comment\">/* 将 MyFun 函数的地址赋给 FunP 变量 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    (*FunP)(<span class=\"number\">20</span>);<span class=\"comment\">/* （★）这是通过函数指针变量 FunP 来调用MyFun 函数的。 */</span></span><br><span class=\"line\">    FunP(<span class=\"number\">20</span>); <span class=\"comment\">/* （★）这是通过函数指针变量来调用 MyFun 函数的。*/</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>1）其实，MyFun 的函数名与 FunP 函数指针都是一样的，即都是函数指针。<br>MyFun 函数名是一个函数指针常量，而 FunP 是一个函数数指针变量，这是它 们的关系。</p>\n<p>2）但函数名调用如果都得如(*MyFun)(10)这样，那书写与读起来都是不 方便和不习惯的。所以 C 语言的设计者们才会设计成又可允许 MyFun(10)这种 形式地调用（这样方便多了并与数学中的函数形式一样，不是吗？）。</p>\n<p>3）为统一起见，FunP 函数指针变量也可以 FunP(10)的形式来调用。</p>\n<p>4）赋值时，即可 FunP = &amp;MyFun 形式，也可 FunP = MyFun。</p>\n<p>上述代码的写法，随便你爱怎么着！<br>请这样理解吧！这可是有助于你对函数指针的应用喽！ 最后 ——<br>补充说明一点，在函数的声明处：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFun</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>; <span class=\"comment\">/*不能写成 void (*MyFun)(int)。*/</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> (*FunP)(<span class=\"keyword\">int</span>); <span class=\"comment\">/*不能写成 void FunP(int)。*/</span></span><br><span class=\"line\">定义某一函数的指针类型</span><br><span class=\"line\">C</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*FunType)</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">FunType FunP; <span class=\"comment\">/*然后用 FunType 类型来声明全局 FunP 变量*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    FunType FunP;</span><br><span class=\"line\">    MyFun(<span class=\"number\">10</span>);</span><br><span class=\"line\">    FunP = &amp;MyFun;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义一个名为 FunType 函数指针类型，而不是一个 FunType 变量。 然后，FunType FunP 这句就如 PINT px;一样地声明一个 FunP<br>变量。</p>\n<p>函数指针作为某个函数的参数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MyFun1</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MyFun2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MyFun3</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*FunType)</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>; <span class=\"comment\">/* ②. 定义一个函数指针类型 FunType,只要函数类型（参数和返回值）相同就可以只用之来定义 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CallMyFun</span><span class=\"params\">(FunType fp, <span class=\"keyword\">int</span> x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    CallMyFun(MyFun1, <span class=\"number\">10</span>); <span class=\"comment\">/* ⑤. 通过 CallMyFun 函数分别 调用三个不同的函数 */</span></span><br><span class=\"line\">    CallMyFun(MyFun2, <span class=\"number\">20</span>);</span><br><span class=\"line\">    CallMyFun(MyFun3, <span class=\"number\">30</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CallMyFun</span><span class=\"params\">(FunType fp, <span class=\"keyword\">int</span> x)</span> <span class=\"comment\">/* ③. 参数 fp 的类型是FunType。*/</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    fp(x);<span class=\"comment\">/* ④. 通过 fp 的指针执行传递进来的函数，注意 fp 所指 的函数是有一个参数的。 */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MyFun1</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> <span class=\"comment\">/* ①. 这是个有一个参数的函数，以下两个函数也相同。 */</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"函数 MyFun1 中输出：%d\\n\"</span>, x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MyFun2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"函数 MyFun2 中输出：%d\\n\"</span>, x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MyFun3</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"函数 MyFun3 中输出：%d\\n\"</span>, x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<p>函数 MyFun1 中输出：10<br>函数 MyFun2 中输出：20<br>函数 MyFun3 中输出：30<br>函数类型<br>函数指针只要返回值和参数相同就可以指向</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> (*p1)(<span class=\"keyword\">int</span>) ; <span class=\"comment\">// 可以指向函数的类型是空返回值且一个int类型的参数</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> (*p2)(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>) ; <span class=\"comment\">// 可以指向函数的类型是double类型的返回值且两个int类型的参数</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Operating System Notes","url":"/2023/01/18/Operating%20System%20Notes/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>指向 void 类型的指针是什么<br>最近遇到 void *的问题无法解决，发现再也无法逃避了（以前都是采取悄悄绕过原则），于是我决定直面它。</p>\n<p>在哪遇到了？<br>这里写图片描述<br>这里写图片描述</p>\n<p>线程创建函数 pthread_create()的最后一个参数 void *arg，嗯？传地址还是传值？传值好像有警告。</p>\n<p>还有别的出现的地方呢</p>\n<p>这里写图片描述<br>这里写图片描述</p>\n<p>看 memcpy()，返回值和参数都有 void *，那又怎么传呢？下面我们首先来说说 void *是什么。</p>\n<p>一：void <em>是什么？<br>C 语言中，</em>类型就是指针类型。比如 int <em>p，double *q，虽然是不一样的指针，但是大小却一样 sizeof(p) == sizeof(q)，其实很容易理解，因为他们都是同一种类型\\</em>类型的。C 语言是强类型的语言。对类型的区分十分严格。那这两个有什么不同点吗？有，+1 就不同了，看下面的图：<br>这里写图片描述<br>这里写图片描述</p>\n<p>也就是对于一个指针而言，如果我们在前面规定了它的类型。那就相当于决定了它的“跳跃力”。“跳跃力”就比如说上面图中 int 跳了 4 个字节，但是 double 跳了 8 个字节。基于这样的理解，我要对 void *下定义了：</p>\n<p>void * 是一个跳跃力未定的指针</p>\n<p>二：跳跃力什么时候定？<br>这就是它的神奇之处了，我们可以自己控制在需要的时候将它实现为需要的类型。这样的好处是：编程时候节约代码，实现泛型编程。比如我们经常写的排序算法，就可以这么写：</p>\n<p>C<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>static void Swap(char <em>vp1, char *vp2, int width)<br>{<br>char tmp;<br>if ( vp1 != vp2 ) {<br>while ( width– ) {<br>tmp = *vp1;<br>*vp1++ = *vp2;<br>*vp2++ = tmp;<br>}<br>}<br>}<br>void BubbleSort(void *base, int n, int elem_size,<br>int (</em>compare)( void <em>, void _ ))<br>{<br>int i, last, end = n - 1;<br>char *elem_addr1, *elem_addr2;<br>while (end &gt; 0) {<br>last = 0;<br>for (i = 0; i &lt; end; i++) {<br>elem_addr1 = (char _)base + i _ elem_size;<br>elem_addr2 = (char _)base + (i + 1) _ elem_size;<br>if (compare( elem_addr1, elem_addr2 ) &gt; 0) {<br>Swap(elem_addr1, elem_addr2, elem_size);<br>last = i;<br>}<br>}<br>end = last;<br>}<br>}<br>int compare_int(void *elem1, void *elem2)<br>{<br>return (</em>(int <em>)elem1 - _(int _)elem2);<br>}<br>int compare_double(void *elem1, void *elem2)<br>{<br>return (</em>(double _)elem1 &gt; _(double _)elem2) ? 1 : 0;<br>}<br>int main(int argc, char *argv[])<br>{<br>int num_int[8] = {8,7,6,5,4,3,2,1};<br>double num_double[8] = {8.8,7.7,6.6,5.5,4.4,3.3,2.2,1.1};<br>int i;<br>BubbleSort(num_int, 8, sizeof(int), compare_int);<br>for (i = 0; i &lt; 8; i++) {<br>printf(“%d “, num_int[i]);<br>}<br>printf(“\\n”);<br>BubbleSort(num_double, 8, sizeof(double), compare_double);<br>for (i = 0; i &lt; 8; i++) {<br>printf(“%.1f “, num_double[i]);<br>}<br>printf(“\\n”);<br>return 0;<br>}<br>这里写图片描述<br>这里写图片描述</p>\n<p>上面的 compare_int 和 compare_double 就是定它跳跃力的时候。</p>\n<p>三：再来说 memcpy<br>我们先来看下面这段代 码：</p>\n<p>C<br>#include&lt;stdio.h&gt;<br>#include&lt;string.h&gt;</p>\n<p>struct stu{<br>int id;<br>int num;<br>};</p>\n<p>#define LEN sizeof(struct stu) /<em>LEN 为 stu 的大小</em>/</p>\n<p>int main(int argc,char *argv[])<br>{<br>struct stu stu1,stu2;<br> stu1.id = 2;<br>stu1.num = 3;</p>\n<pre><code>char str[LEN];\n\nmemcpy(str,&amp;stu1,LEN);        /*将stu1保存进str*/\n\nmemcpy(&amp;stu2,str,LEN);        /*将str转换成stu2*/\n\nprintf(&quot;%d %d\\n&quot;,stu2.id,stu2.num); /*访问stu2仍然得到 2 和 3*/\nreturn 0;</code></pre><p>}<br>这里写图片描述<br>这里写图片描述</p>\n<p>说明：str 是一个 char <em>类型的，但是&amp;stu 是一个 struct stu *类型的，就像我们前面说的那样，他们的“跳跃力”是不一样的，但是 memcpy 之所以能将它们都接受，就是因为它的参数是(void \\</em>)类型的。在参数传递的时候包容万象，全都接受，这才能体现人家是 memcpy()吗，mem 是内存，肯定可以不非要按照某种具体类型处理，具体至于还想 memcpy 的内部怎么处理，看下面：</p>\n<p><a href=\"http://blog.csdn.net/yangbodong22011/article/details/53227560\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/yangbodong22011/article/details/53227560</a></p>\n<p>四：总结<br>void <em>是一种指针类型，常用在函数参数、函数返回值中需要兼容不同指针类型的地方。我们可以将别的类型的指针无需强制类型转换的赋值给 void *类型。也可以将 void \\</em>强制类型转换成任何别的指针类型，至于强转的类型是否合理，就需要我们程序员自己控制了。</p>\n<p>C<br>#include&lt;stdio.h&gt;</p>\n<p>int main(int argc,char <em>argv[])<br>{<br>int a = 2;<br>double b = 2.0;<br>void *c; //定义 void *<br>int *p = &a;<br> c = p; //将 int _ 转成 void _，<br>double _q = (double _)c; //将 void _转成 double _<br>printf(“%.f\\n”,\\</em>q);</p>\n<pre><code>return 0;</code></pre><p>}<br>参考链接 : <a href=\"http://www.0xffffff.org\" target=\"_blank\" rel=\"noopener\">www.0xffffff.org</a></p>\n<p>fork()和 pthread_create()<br>一. fork()</p>\n<p>该函数用于创建子进程，根本平时学习总结一下几点：</p>\n<p>1）根据 fork 函数的返回值不同， 若返回值大于零则执行的是父进程代码，当然该返回值是子进程的进程号，若返回值等于零则执行的是子进程代码。</p>\n<p>2）子进程被创建是就好像是父进程的克隆，注意父进程的所有变量，子进程都会得到一份拷贝，因此改变子进程的变量值不会影响到父进程的变量值。</p>\n<p>3）父进程中打开的文件描述父在子进程中也是打开的，呈现共享的状态。因此父子进程对文件描述符进行的操作是会相互影响的。见下图（拷贝于其他博文）</p>\n<p>img<br>img</p>\n<p>img<br>img</p>\n<p>二. pthread_create()</p>\n<p>该函数用于创建一个线程，函数原型如下：</p>\n<p>int pthread_create(pthread_trestrict tidp,const pthread_attr_t restrict_attr,void（*start_rtn)(void),void *restrict arg);</p>\n<p>第一个参数为线程 ID，第二个参数为线程属性，第三个参数为线程回调函数，线程被创建后执行该函数，第四个参数为传入的参数。</p>\n<p>注意线程在被创建后与父进程中的线程共享代码段和全局变量，但是拥有各自的堆栈空间，也就是说父进程的局部变量是不被共享的。</p>\n<p>其他几个线程函数：</p>\n<p>int pthread_exit(void *retval); //线程安全退出，并将 retval 退出码返回给回收者。</p>\n<p>int pthread_join(pthread_t thread, void ** retval); //回收其他线程（等待其他线程结束）,retval 获得所回收线程的退出信息，回收的线程必须是可回收状态。</p>\n<p>线程有两种状态：可回收状态和脱离状态。该状态可有 pthread_attr_t 属性反映，PTHREAD_CREATE_JOINABLE 可回收状态, PTHREAD_CREATE_DETACH 脱离状态，该状态下的线程在退出是将自行释放其占用的资源。</p>\n<p>int pthread_detach() 将线程设置为脱离状态。</p>\n"},{"title":"Python爬虫实战（一）疫情数据","url":"/2020/08/10/Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p><a href=\"https://github.com/ZhengLin-Li/leaning-spider-COVID19Situation\" target=\"_blank\" rel=\"noopener\">https://github.com/ZhengLin-Li/leaning-spider-COVID19Situation</a></p>\n<h1 id=\"1-BeautifulSoup的find方法\"><a href=\"#1-BeautifulSoup的find方法\" class=\"headerlink\" title=\"1. BeautifulSoup的find方法\"></a>1. BeautifulSoup的find方法</h1><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># for example</span></span><br><span class=\"line\"></span><br><span class=\"line\">soup.find(<span class=\"string\">'a'</span>) <span class=\"comment\"># 根据标签名查找</span></span><br><span class=\"line\"></span><br><span class=\"line\">soup.find(id=<span class=\"string\">'link1'</span>) <span class=\"comment\"># 根据属性查找</span></span><br><span class=\"line\"></span><br><span class=\"line\">soup.find(attrs=&#123;<span class=\"string\">'id'</span>:<span class=\"string\">'link1'</span>&#125;) <span class=\"comment\"># 根据属性查找</span></span><br><span class=\"line\"></span><br><span class=\"line\">soup.find(test=<span class=\"string\">'aaa'</span>) <span class=\"comment\"># 根据标签文本内容查找</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"2-Tag对象\"><a href=\"#2-Tag对象\" class=\"headerlink\" title=\"2. Tag对象\"></a>2. Tag对象</h1><p>find方法返回的是Tag对象，有如下属性</p>\n<p>Tag对象对应于原始文档中的html标签</p>\n<p>name：标签名称</p>\n<p>attrs：标签属性的键和值</p>\n<p>text：标签的字符串文本</p>\n<h1 id=\"3-正则表达式\"><a href=\"#3-正则表达式\" class=\"headerlink\" title=\"3. 正则表达式\"></a>3. 正则表达式</h1><p>. \\d </p>\n<p>+*?</p>\n<p>()</p>\n<p>[]</p>\n<p>\\</p>\n<p>r原串</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">rs = re.findall(<span class=\"string\">'\\d'</span>,<span class=\"string\">'123'</span>)</span><br><span class=\"line\">rs = re.findall(<span class=\"string\">'\\d*'</span>,<span class=\"string\">'456'</span>)</span><br><span class=\"line\">rs = re.findall(<span class=\"string\">'\\d+'</span>,<span class=\"string\">'789'</span>)</span><br><span class=\"line\">rs = re.findall(<span class=\"string\">'a+'</span>,<span class=\"string\">'aaabcd'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(rs)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 分组的使用</span></span><br><span class=\"line\">rs = re.findall(<span class=\"string\">'\\d&#123;1,2&#125;'</span>,<span class=\"string\">'chuan13zhi2'</span>)</span><br><span class=\"line\">rs = re.findall(<span class=\"string\">'aaa(\\d+)b'</span>,<span class=\"string\">'aaa91b'</span>)</span><br><span class=\"line\">print(rs)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一般的正则表达式匹配一个\\需要四个\\</span></span><br><span class=\"line\">rs = re.findall(<span class=\"string\">'a\\\\\\\\bc'</span>,<span class=\"string\">'a\\\\bc'</span>)</span><br><span class=\"line\">print(rs)</span><br><span class=\"line\">print(<span class=\"string\">'a\\\\bc'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用r原串</span></span><br><span class=\"line\">rs = re.findall(<span class=\"string\">r'a\\\\rbc'</span>,<span class=\"string\">'a\\\\rbc'</span>)</span><br><span class=\"line\">print(rs)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-json字符串互转python数据\"><a href=\"#4-json字符串互转python数据\" class=\"headerlink\" title=\"4. json字符串互转python数据\"></a>4. json字符串互转python数据</h1><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\">json_str = <span class=\"string\">'''[&#123;\"a\":\"thia is a\",</span></span><br><span class=\"line\"><span class=\"string\">\"b\":[1,2,3]&#125;,&#123;\"a\":\"thia is a\",</span></span><br><span class=\"line\"><span class=\"string\">\"b\":[1,2,3]&#125;]'''</span></span><br><span class=\"line\"></span><br><span class=\"line\">rs = json.loads(json_str)</span><br><span class=\"line\">print(rs)</span><br><span class=\"line\">print(type(rs))  <span class=\"comment\"># &lt;class 'list'&gt;</span></span><br><span class=\"line\">print(type(rs[<span class=\"number\">0</span>]))  <span class=\"comment\"># &lt;class 'dict'&gt;</span></span><br><span class=\"line\">print(type(json_str))  <span class=\"comment\"># &lt;class 'str'&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\">json_str = <span class=\"string\">'''[</span></span><br><span class=\"line\"><span class=\"string\">  &#123;</span></span><br><span class=\"line\"><span class=\"string\">    \"a\": \"this is a\",</span></span><br><span class=\"line\"><span class=\"string\">    \"b\": [1, 2,\"熊猫\"]</span></span><br><span class=\"line\"><span class=\"string\">  &#125;,</span></span><br><span class=\"line\"><span class=\"string\">  &#123;</span></span><br><span class=\"line\"><span class=\"string\">    \"c\": \"thia is c\",</span></span><br><span class=\"line\"><span class=\"string\">    \"d\": [1, 2, 3]</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">]'''</span></span><br><span class=\"line\"></span><br><span class=\"line\">rs = json.loads(json_str)</span><br><span class=\"line\">json_str = json.dumps(rs,ensure_ascii=<span class=\"literal\">False</span>)</span><br><span class=\"line\">print(json_str)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-json格式文件互转python数据\"><a href=\"#5-json格式文件互转python数据\" class=\"headerlink\" title=\"5. json格式文件互转python数据\"></a>5. json格式文件互转python数据</h1><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># json格式文件转python数据</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'data/test.json'</span>) <span class=\"keyword\">as</span> fp:</span><br><span class=\"line\">    python_list = json.load(fp)</span><br><span class=\"line\">    print(python_list)</span><br><span class=\"line\">    print(type(python_list))  <span class=\"comment\"># &lt;class 'list'&gt;</span></span><br><span class=\"line\">    print(type(python_list[<span class=\"number\">0</span>]))  <span class=\"comment\"># &lt;class 'dict'&gt;</span></span><br><span class=\"line\">    print(type(fp))  <span class=\"comment\"># &lt;class '_io.TextIOWrapper'&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">\"data/test1.json\"</span>,<span class=\"string\">'w'</span>) <span class=\"keyword\">as</span> fp:</span><br><span class=\"line\">    json.dump(rs,fp,ensure_ascii=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/08/08/rQuwR8DGphdTcox.png\" alt=\"image-20200808102225666\"></p>\n","categories":["Python爬虫"],"tags":["Python","爬虫","实战"]},{"title":"Eight Sorting Algorithms Explained","url":"/2023/01/18/Eight%20Sorting%20Algorithms%20Explained/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>Eight sorting algorithms in detail (moving picture demonstration idea analysis example code java complexity analysis applicable scenarios)</p>\n<p>A. Classification 1. internal sorting and external sorting 　<br>Internal sorting: the sorting process of the records to be sorted is stored in the computer’s random memory (to put it simply, it is memory).<br>External sort: sorting process in which the number of records to be sorted is so large that the memory cannot hold all the records at once, so access to the external memory is required in the sorting process.</p>\n<ol start=\"2\">\n<li>Comparative sorting and non-comparative sorting<br>Comparative sort: The relative order of the elements is determined by comparison, which is also called non-linear time comparative sort because its time complexity cannot exceed O(nlogn).<br>Non-comparative sorting: It does not decide the relative order among elements by comparison, and it can break the lower bound of time based on comparison sorting and run in linear time, so it is also called linear time non-comparative sorting.</li>\n</ol>\n<p>II. Complexity analysis, algorithm stability and applicable scenarios<br>Stable: If a is in front of b and a=b, a is still in front of b after sorting.<br>Unstable: If a is in front of b and a=b, a may appear after b after sorting.<br>Time complexity: The total number of operations on the sorted data. It reflects what is the pattern of the number of operations when n varies.<br>Space complexity: is a measure of the storage space required to execute the algorithm in the computer, which is also a function of the data size n.</p>\n<p>Three, eight sorting algorithms detailed explanation 1.<br>1.1 Moving image demonstration</p>\n<p>1.2 Idea analysis</p>\n<ol>\n<li><p>the first compared with all the numbers behind, if less than (or less than) the first number, the subscript of the smaller number is temporarily stored, after the first trip, the first number, and the temporary storage of the smallest number for exchange, the first number is the smallest (or the largest number)</p>\n</li>\n<li><p>move the subscript to the second position, the second number compared with all the numbers behind, a trip down, to determine the second smallest (or second largest) number</p>\n</li>\n</ol>\n<p>Repeat the above steps</p>\n<p>Until the pointer moves to the penultimate position, determine the penultimate smallest (or penultimate largest) number, then the last number is also determined, the sorting is complete.</p>\n<p>1.3 Complexity Analysis</p>\n<ol>\n<li>regardless of whether the original array is ordered or not, the time complexity is O(n2).</li>\n</ol>\n<p>Because each number has to be compared with other numbers once, (n-1)2 times, decomposition: n2-2n+1, remove the lower power and constant, leaving n2, so the final time complexity is n2. 2.</p>\n<ol start=\"2\">\n<li>the space complexity is O(1), because only two auxiliary variables are defined, independent of the size of n, so the space complexity is O(1)</li>\n</ol>\n<p>1.4 The Java code is as follows.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] n = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">33</span>,<span class=\"number\">27</span>,<span class=\"number\">66</span>,<span class=\"number\">9</span>,<span class=\"number\">7</span>,<span class=\"number\">88</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp,index = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n.length-<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            index = i;</span><br><span class=\"line\">            <span class=\"comment\">// if greater than, temporarily store the subscript of the smaller number</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; n.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(n[index]&gt;n[j])&#123;</span><br><span class=\"line\">                    index = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//// takes the smallest number found in one trip down and swaps it with this number</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(index&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                temp = n[i];</span><br><span class=\"line\">                n[i] = n[index];</span><br><span class=\"line\">                n[index] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Arrays.toString(n));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Arrays.toString(n));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>bubble sort<br>2.1 Animations</li>\n</ol>\n<p>2.2 Idea analysis</p>\n<ol>\n<li>compare two adjacent numbers, n[i] with n[j+1], if n[i]&gt;n[j+1], then swap even the numbers, **<br>**</li>\n</ol>\n<p>\\2. j++, repeating the above steps, after the first trip, the largest number will be determined in the last place, which is the bubble sort also known as the large (small) number sink</p>\n<p>\\3. i++, repeat the above steps until the end of i=n-1 and the sorting is completed.</p>\n<p>2.3 Complexity Analysis</p>\n<ol>\n<li>regardless of whether the original array is ordered or not, the time complexity is O(n2).</li>\n</ol>\n<p>Because each number has to be compared with other numbers once, (n-1)2 times, decomposition: n2+2n-1, remove the low power and constant, leaving n2, so the final time complexity is n2. 2.</p>\n<ol start=\"2\">\n<li>the space complexity is O(1), because only one auxiliary variable is defined, independent of the size of n, so the space complexity is O(1)</li>\n</ol>\n<p>2.4 Comparison of selection sort and bubble sort</p>\n<p>\\1. both have time responsibility of O(n2)</p>\n<p>\\2. the space complexity is O(1)</p>\n<p>\\3. The selection sort determines the largest or smallest number from the first one, ensuring that the previous numbers are all ordered and smaller or larger than the following ones.</p>\n<p>The bubble sort determines the largest or smallest number from the last, and ensures that the numbers that follow are ordered and are greater or less than the numbers that follow.</p>\n<p>2.5 The Java code is as follows</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">bubble</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] n = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">33</span>,<span class=\"number\">27</span>,<span class=\"number\">66</span>,<span class=\"number\">9</span>,<span class=\"number\">7</span>,<span class=\"number\">88</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n.length-<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n.length-<span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(n[j]&gt;n[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                    temp = n[j];</span><br><span class=\"line\">                    n[j] = n[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                    n[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Arrays.toString(n));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>Direct insertion sort<br>3.1 Action figure demonstration</li>\n</ol>\n<p>3.2 Idea analysis</p>\n<p>For example, to sort from smallest to largest:</p>\n<ol>\n<li><p>start iterating from the second place.</p>\n</li>\n<li><p>Compare the current number (the first trip is the second number) with the previous number in order, if the previous number is greater than the current number, then put this number in the position of the current number, the subscript of the current number -1, **<br>**</p>\n</li>\n<li><p>repeat the above steps until the current number is not greater than a certain number in front of it, at which point, the current number, placed in this position, the</p>\n</li>\n</ol>\n<p>1-3 steps is to ensure that the current number of the preceding numbers are ordered, the purpose of the inner loop is to insert the current number into the preceding ordered sequence</p>\n<ol start=\"4\">\n<li>repeat the above 3 steps until the last number is traversed, and the last number is inserted into the appropriate position, and the insertion sort is finished.</li>\n</ol>\n<p>According to the analysis of the idea, the execution flow of each trip is shown in the following figure.</p>\n<p>3.3 Complexity Analysis</p>\n<ol>\n<li>time complexity: the insertion algorithm, which is to ensure that the previous sequence is ordered, only needs to insert the current number into a position in front of it.</li>\n</ol>\n<p>So if the array is originally ordered, the best-case time complexity of the array is O (n)</p>\n<p>If the array happens to be inverted = inverted order, for example, the original array is 5 4 3 2 1, and you want to arrange it from smallest to largest, the number in front of each trip has to be moved backwards, and a total of n-1 + n-2 + … + 2 + 1 = n _ (n-1) / 2 = 0.5 _ n2 - 0.5 * n times, removing the lower powers and coefficients, so the worst-case time complexity is O(n2 )</p>\n<p>Average time complexity (n+n2 )/2, so the average time complexity is O(n2)</p>\n<ol start=\"2\">\n<li>space complexity: insertion sort algorithm, only two variables are needed to temporarily store the current number, and subscript, independent of the size of n, so the space complexity is: O (1)</li>\n</ol>\n<p>3.4 The Java code is as follows</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">insertSort</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] n = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">20</span>,<span class=\"number\">12</span>,<span class=\"number\">15</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">49</span>,<span class=\"number\">58</span>,<span class=\"number\">24</span>,<span class=\"number\">578</span>,<span class=\"number\">211</span>,<span class=\"number\">20</span>,<span class=\"number\">214</span>,<span class=\"number\">78</span>,<span class=\"number\">35</span>,<span class=\"number\">125</span>,<span class=\"number\">789</span>,<span class=\"number\">11</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>,j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n.length; i++) &#123;</span><br><span class=\"line\">            temp = n[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = i; j &gt; <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// If the number before the current number is greater than the current number, move the number before it back one position</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(n[j-<span class=\"number\">1</span>]&gt;temp)&#123;</span><br><span class=\"line\">                    n[j] = n[j-<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// the first number has been moved to the second number, put the current number into the first position, the end of this trip</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(j==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                        n[j-<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;<span class=\"comment\">//If not greater than, put the current number to the position of j, the end of this trip</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    n[j] = temp;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Arrays.toString(n));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Arrays.toString(n));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>If the maximum number of digits in the array is n, it is necessary to arrange n times, for example, the maximum number in the array is 3 digits, it is necessary to arrange 3 times.</p>\n</li>\n<li><p>If there are m numbers in the array, ten m-length arrays tempj (j=0-9) are needed to temporarily store the number of i bits j. For example, the first time, the number of bits 0 will be assigned to the temp0 array, and the number of bits 1 will be assigned to the temp1 array ……</p>\n</li>\n<li><p>After the allocation, then take out the data from the tempj array in turn, following the first-in-first-out principle, for example, for the array {1, 11, 2, 44, 4}, after the first allocation, temp1={1,11}, temp2={2}, temp4={44, 4}, after taking out the elements in turn {1, 11, 2, 44, 4}, the first trip is over</p>\n</li>\n<li><p>Loop to n times after the end, sorting is completed</p>\n</li>\n</ol>\n<p>According to the analysis of ideas, the execution flow of each trip is shown as follows.</p>\n<p>Sort by base on the array {53, 3, 542, 748, 14, 214, 154, 63, 616}.</p>\n<p>6.3 Complexity analysis</p>\n<ol>\n<li>time complexity: **<br>**</li>\n</ol>\n<p>Each keyword bucket assignment requires O(n) time complexity, and the new keyword sequence after the assignment requires O(n) time complexity again.</p>\n<p>If the data to be sorted can be divided into d keywords, the time complexity of the base sort will be O(d*2n), although d is much smaller than n, so it is still essentially linear.</p>\n<p>The coefficient 2 can be omitted, and the time complexity is always O(d*n) because the array needs to be sorted from the individual bits to the maximum number of bits, regardless of whether the array is ordered or not. Where n is the length of the array and d is the maximum number of bits. 2.</p>\n<ol start=\"2\">\n<li>Space complexity.</li>\n</ol>\n<p>The space complexity of the base sort is O(n+k), where k is the number of buckets, and n numbers need to be allocated.</p>\n<p>6.4 The Java code is as follows</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">33</span>,<span class=\"number\">27</span>,<span class=\"number\">66</span>,<span class=\"number\">9</span>,<span class=\"number\">7</span>,<span class=\"number\">88</span>&#125;;</span><br><span class=\"line\">        radixSort(arr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">radixSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//find the maximum number of numbers to be ranked</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxLength=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(maxLength&lt;arr[i])</span><br><span class=\"line\">                maxLength = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// find the maximum length based on the maximum number</span></span><br><span class=\"line\">        maxLength = (maxLength+<span class=\"string\">\"\"</span>).length();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Array for storing data</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] temp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>][arr.length];</span><br><span class=\"line\">        <span class=\"comment\">// used to record the number of data in each bucket of memory in the temp array</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] counts = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"comment\">// used to record the number of i bits of each number</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// used to take the position of the elements to be placed</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//decide the number of times to sort according to the maximum length</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,n=<span class=\"number\">1</span>; i &lt; maxLength; i++,n*=<span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">                num = arr[j]/n%<span class=\"number\">10</span>;</span><br><span class=\"line\">                temp[num][counts[num]] = arr[j];</span><br><span class=\"line\">                counts[num]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//Take the elements from temp and put them back into the arr array</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; counts.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j2 = <span class=\"number\">0</span>; j2 &lt; counts[j]; j2++) &#123;</span><br><span class=\"line\">                    arr[index] = temp[j][j2];</span><br><span class=\"line\">                    index++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                counts[j]=<span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            index=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>Hill (shell) sorting<br>7.1 Action figure demonstration</li>\n</ol>\n<p>7.2 Idea Analysis</p>\n<p>Hill sort is to group the records by certain increments of the subscript, and use the direct insertion sort algorithm to sort each group; as the increment decreases, each group contains more and more keywords, and when the increment decreases to 1, the whole file is divided into a group, and the algorithm terminates.</p>\n<p>The simple insertion sort is very conventional, regardless of the distribution of the array, it still compares, moves and inserts the elements step by step, for example, [5,4,3,2,1,0] is a reverse order sequence, the 0 at the end of the array is very hard to return to the first position, it takes n-1 times to compare and move the elements.</p>\n<p>Hill sort uses a jump grouping strategy in the array, dividing the array elements into groups by a certain increment, then grouping them for insertion sorting, and then gradually reducing the increment and continuing insertion sorting by group until the increment is 1. By this strategy, the whole array is basically ordered from the macroscopic point of view in the initial stage, with the smaller ones basically in the front and the larger ones basically in the back. Then the increment is reduced to increment 1, which in most cases requires only fine tuning and does not involve too much data movement.</p>\n<p>Coming to the basic steps of Hill sort, here the increment gap=length/2 is chosen and the narrowing increment continues with gap = gap/2. This increment selection can be represented by a sequence, {n/2,(n/2)/2…1}, called increment sequence. The selection and proof of the increment sequence of the Hill sort is a mathematical challenge. This increment sequence chosen is more commonly used and is the increment suggested by Hill, called the Hill increment, but in fact this increment sequence is not optimal. This is done here as an example using the Hill increment.</p>\n<p>7.3 Complexity Analysis</p>\n<ol>\n<li>Time complexity: In the worst case, every two numbers are compared and swapped once, so the time complexity in the worst case is O(n2), and in the best case, the arrays are ordered and do not need to be swapped but only compared, so the time complexity in the best case is O(n).</li>\n</ol>\n<p>The average time complexity of Hill sort is O(n1.3) after a lot of research (I don’t know how this came about, but it is stated in books and blogs, and I didn’t find a specific basis for it,,).</p>\n<ol start=\"2\">\n<li>space complexity: Hill sort, only one variable is needed for the exchange of two numbers, independent of the size of n, so the space complexity is: O(1).</li>\n</ol>\n<p>7.4 The Java code is as follows</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">shell</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">33</span>,<span class=\"number\">27</span>,<span class=\"number\">66</span>,<span class=\"number\">9</span>,<span class=\"number\">7</span>,<span class=\"number\">88</span>&#125;;</span><br><span class=\"line\">        shellSort(arr);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">        <span class=\"comment\">//control the incremental sequence, the last trip when the incremental sequence is 1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = arr.length/<span class=\"number\">2</span>; i &gt;<span class=\"number\">0</span>; i/=<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//find the position of the last number in each comparison sequence according to the incremental sequence</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//execute the insertion sort forward in order based on the position of the last number in the comparison sequence</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = j-i; k &gt;= <span class=\"number\">0</span>; k-= i) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(arr[k]&gt;arr[k+i])&#123;</span><br><span class=\"line\">                        temp = arr[k];</span><br><span class=\"line\">                        arr[k] = arr[k+i];</span><br><span class=\"line\">                        arr[k+i] = temp;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>Heap sort<br>8.1 Action figure demonstration</li>\n</ol>\n<p>8.2 Idea Analysis</p>\n<p>First, let’s understand the concept of heap: a heap is a complete binary tree with the following properties: the value of each node is greater than or equal to the value of its left and right child nodes, called a big top heap; or the value of each node is less than or equal to the value of its left and right child nodes, called a small top heap. The figure below.</p>\n<p>Also, we number the nodes in the heap by level, and mapping this logical structure to an array looks like the following</p>\n<p>The array is logically a heap structure, and we use a simple formula to describe the definition of a heap as follows</p>\n<p>Big top heap: arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</p>\n<p>Small top heap: arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</p>\n<p>Understand these definitions. Next, look at the basic idea of heap sort and the basic steps.</p>\n<p>Heap Sort Basic Idea and Steps</p>\n<p>The basic idea of heap sort is that the sequence to be sorted is constructed as a big top heap, at which point the maximum value of the whole sequence is the root node at the top of the heap. It is exchanged with the end element, and the end is the maximum value. Then the remaining n-1 elements are reconstructed into a heap, which gives the next smallest value of n elements. This is repeated to obtain an ordered sequence</p>\n<p>Step 1 Construct the initial heap. Construct the given unordered sequence into a big-top heap (generally a big-top heap for ascending order and a small-top heap for descending order).</p>\n<p>a. Assume that the structure of the given unordered sequence is as follows</p>\n<ol start=\"2\">\n<li><p>At this point, we start from the last non-leaf node (leaf node naturally does not need to be adjusted, the first non-leaf node arr.length/2-1=5/2-1=1, which is the following 6 nodes), from left to right, from bottom to top to be adjusted.</p>\n</li>\n<li><p>Find the second non-leaf node 4. Since the 9 element in [4,9,8] is the largest, 4 and 9 are swapped.</p>\n</li>\n</ol>\n<p>At this point, the swap leads to confusion in the structure of the child root [4,5,6], and continues to adjust, with 6 being the largest in [4,5,6], swapping 4 and 6.</p>\n<p>At this point, we have constructed a sequence without a sequence into a big top heap.</p>\n<p>Step 2 Swap the top element of the heap with the end element so that the end element is the largest. Then continue adjusting the heap and swap the top element with the end element to get the second largest element. This is repeated for swapping, rebuilding, and swapping.</p>\n<p>a. Swap the top element of the heap 9 with the end element 4</p>\n<p>b. Restructure so that it continues to satisfy the heap definition</p>\n<p>c. Then swap the top element 8 with the end element 5 to get the second largest element 8.</p>\n<p>The process continues with the adjustment and exchange, and so on, eventually making the whole sequence ordered.</p>\n<p>To briefly summarize the basic idea of heap sort.</p>\n<p>a. Build the unordered sequence into a heap, and choose the big top heap or small top heap according to the ascending and descending requirements;</p>\n<p>b. Exchange the top element of the heap with the end element, and “sink” the largest element to the end of the array;</p>\n<p>c. Re-adjust the structure to meet the definition of the heap, and then continue to exchange the top element of the heap with the current end element, and repeatedly perform the adjustment + exchange steps until the entire sequence is ordered.</p>\n<p>8.3 Complexity Analysis</p>\n<ol>\n<li><p>time complexity: heap sort is a kind of selection sort, and the whole mainly consists of two parts: constructing the initial heap + swapping the top and end elements and rebuilding the heap. The complexity of constructing the initial heap is O(n) by derivation, in the process of swapping and rebuilding the heap, n-1 exchanges are required, and in the process of rebuilding the heap, according to the nature of complete binary trees, [log2(n-1),log2(n-2)…1] decreases gradually and is approximated by nlogn. Therefore, the time complexity of heap sorting is O( nlogn) level. 2.</p>\n</li>\n<li><p>space complexity: heap sort does not need any auxiliary arrays, but only one auxiliary variable, and the space occupied is a constant independent of n, so the space complexity is O(1).</p>\n</li>\n</ol>\n<p>8.4 The Java code is as follows</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">duipaixu</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = arr.length;</span><br><span class=\"line\">        <span class=\"comment\">// Build the big top heap starting from the last non-leaf node</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = arr.length/<span class=\"number\">2</span>-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            maximumHeap(i,arr,length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// swap with the root node starting from the smallest leaf node and reconstruct the maximum heap</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = arr.length-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\"><span class=\"comment\">// System.out.println(Arrays.toString(arr));</span></span><br><span class=\"line\">            swap(arr,<span class=\"number\">0</span>,i);</span><br><span class=\"line\">            length--;</span><br><span class=\"line\">            maximumHeap(<span class=\"number\">0</span>,arr,length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Build the big top heap</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">maximumHeap</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span>[] arr,<span class=\"keyword\">int</span> length)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = arr[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i*<span class=\"number\">2</span>+<span class=\"number\">1</span>; j &lt; length; j=j*<span class=\"number\">2</span>+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// if the right child is greater than the do child, then point to the right child</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j+<span class=\"number\">1</span>&lt;length &amp;&amp; arr[j+<span class=\"number\">1</span>]&gt;arr[j])&#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// If the largest child is greater than the current node, assign the larger child to the current node, modify the current node to be its larger child node, and go down.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j]&gt;temp)&#123;</span><br><span class=\"line\">                arr[i] = arr[j];</span><br><span class=\"line\">                i = j;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//put temp in the final position</span></span><br><span class=\"line\">        arr[i] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//swap</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"八大排序算法详解（动图演示-思路分析-实例代码-java-复杂度分析-适用场景）\"><a href=\"#八大排序算法详解（动图演示-思路分析-实例代码-java-复杂度分析-适用场景）\" class=\"headerlink\" title=\"八大排序算法详解（动图演示 思路分析 实例代码 java 复杂度分析 适用场景）\"></a>八大排序算法详解（动图演示 思路分析 实例代码 java 复杂度分析 适用场景）</h1><p>一、分类 1.内部排序和外部排序　<br>内部排序：待排序记录存放在计算机随机存储器中（说简单点，就是内存）进行的排序过程。<br>外部排序：待排序记录的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中需要对外存进行访问的排序过程。</p>\n<p>2.比较类排序和非比较排序<br>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 O(nlogn)，因此也称为非线性时间比较类排序。<br>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p>\n<p>二、复杂度分析，算法稳定性和适用场景<br>稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面。<br>不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面。<br>时间复杂度：对排序数据的总的操作次数。反映当 n 变化时，操作次数呈现什么规律。<br>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模 n 的函数。</p>\n<p>三、八大排序算法详解 1.选择排序<br>1.1 动图演示</p>\n<p>1.2 思路分析</p>\n<ol>\n<li><p>第一个跟后面的所有数相比，如果小于（或小于）第一个数的时候，暂存较小数的下标，第一趟结束后，将第一个数，与暂存的那个最小数进行交换，第一个数就是最小（或最大的数）</p>\n</li>\n<li><p>下标移到第二位，第二个数跟后面的所有数相比，一趟下来，确定第二小（或第二大）的数</p>\n</li>\n</ol>\n<p>重复以上步骤</p>\n<p>直到指针移到倒数第二位，确定倒数第二小（或倒数第二大）的数，那么最后一位也就确定了，排序完成。</p>\n<p>1.3 复杂度分析</p>\n<ol>\n<li>不管原始数组是否有序，时间复杂度都是 O（n2），</li>\n</ol>\n<p>因为没一个数都要与其他数比较一次，（n-1）2 次，分解：n2-2n+1, 去掉低次幂和常数，剩下 n2,所以最后的时间复杂度是 n2</p>\n<ol start=\"2\">\n<li>空间复杂度是 O（1）,因为只定义了两个辅助变量，与 n 的大小无关，所以空间复杂度为 O（1）</li>\n</ol>\n<p>1.4 Java 代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] n = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">33</span>,<span class=\"number\">27</span>,<span class=\"number\">66</span>,<span class=\"number\">9</span>,<span class=\"number\">7</span>,<span class=\"number\">88</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp,index = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n.length-<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            index=i;</span><br><span class=\"line\">            <span class=\"comment\">//如果大于，暂存较小的数的下标</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt;n.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(n[index]&gt;n[j])&#123;</span><br><span class=\"line\">                    index = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">////将一趟下来求出的最小数，与这个数交换</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(index&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                temp = n[i];</span><br><span class=\"line\">                n[i] = n[index];</span><br><span class=\"line\">                n[index] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Arrays.toString(n));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Arrays.toString(n));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>冒泡排序<br>2.1 动图演示</li>\n</ol>\n<p>2.2 思路分析</p>\n<ol>\n<li>相邻两个数两两相比，n[i]跟 n[j+1]比，如果 n[i]&gt;n[j+1]，则将连个数进行交换，**<br>**</li>\n</ol>\n<p>\\2. j++, 重复以上步骤，第一趟结束后，最大数就会被确定在最后一位，这就是冒泡排序又称大（小）数沉底，</p>\n<p>\\3. i++,重复以上步骤，直到 i=n-1 结束，排序完成。</p>\n<p>2.3 复杂度分析</p>\n<ol>\n<li>不管原始数组是否有序，时间复杂度都是 O（n2），</li>\n</ol>\n<p>因为没一个数都要与其他数比较一次，（n-1）2 次，分解：n2+2n-1, 去掉低次幂和常数，剩下 n2,所以最后的时间复杂度是 n2</p>\n<ol start=\"2\">\n<li>空间复杂度是 O（1）,因为只定义了一个辅助变量，与 n 的大小无关，所以空间复杂度为 O（1）</li>\n</ol>\n<p>2.4 选择排序和冒泡排序的比较</p>\n<p>\\1. 时间负责度都是 O（n2）</p>\n<p>\\2. 空间复杂度都是 O（1）</p>\n<p>\\3. 选择排序是从第一位开始确定最大或最小的数，保证前面的数都是有序的，且都比后面的数小或大，</p>\n<p>冒泡排序是从最后一位开始确定最大或最小的数，保证后面的数都是有序的且都大于或小于前面的数。</p>\n<p>2.5 Java 代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> 冒泡 </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] n = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">33</span>,<span class=\"number\">27</span>,<span class=\"number\">66</span>,<span class=\"number\">9</span>,<span class=\"number\">7</span>,<span class=\"number\">88</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n.length-<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;n.length-<span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(n[j]&gt;n[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                    temp = n[j];</span><br><span class=\"line\">                    n[j] = n[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                    n[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Arrays.toString(n));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>直接插入排序<br>3.1 动图演示</li>\n</ol>\n<p>3.2 思路分析</p>\n<p>例如从小到大排序:</p>\n<ol>\n<li><p>从第二位开始遍历，</p>\n</li>\n<li><p>当前数（第一趟是第二位数）与前面的数依次比较，如果前面的数大于当前数，则将这个数放在当前数的位置上，当前数的下标-1，**<br>**</p>\n</li>\n<li><p>重复以上步骤，直到当前数不大于前面的某一个数为止，这时，将当前数，放到这个位置，</p>\n</li>\n</ol>\n<p>1-3 步就是保证当前数的前面的数都是有序的，内层循环的目的就是将当前数插入到前面的有序序列里</p>\n<ol start=\"4\">\n<li>重复以上 3 步，直到遍历到最后一位数，并将最后一位数插入到合适的位置，插入排序结束。</li>\n</ol>\n<p>根据思路分析，每一趟的执行流程如下图所示：</p>\n<p>3.3 复杂度分析</p>\n<ol>\n<li>时间复杂度：插入算法，就是保证前面的序列是有序的，只需要把当前数插入前面的某一个位置即可。</li>\n</ol>\n<p>所以如果数组本来就是有序的，则数组的最好情况下时间复杂度为 O（n）</p>\n<p>如果数组恰好是倒=倒序，比如原始数组是 5 4 3 2 1，想要排成从小到大，则每一趟前面的数都要往后移，一共要执行 n-1 + n-2 + … + 2 + 1 = n _ (n-1) / 2 = 0.5 _ n2 - 0.5 * n 次，去掉低次幂及系数，所以最坏情况下时间复杂度为 O（n2）</p>\n<p>平均时间复杂度(n+n2 )/2，所以平均时间复杂度为 O（n2）</p>\n<ol start=\"2\">\n<li>空间复杂度：插入排序算法，只需要两个变量暂存当前数，以及下标，与 n 的大小无关，所以空间复杂度为：O（1）</li>\n</ol>\n<p>3.4 Java 代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">insertSort</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] n = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">20</span>,<span class=\"number\">12</span>,<span class=\"number\">15</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">49</span>,<span class=\"number\">58</span>,<span class=\"number\">24</span>,<span class=\"number\">578</span>,<span class=\"number\">211</span>,<span class=\"number\">20</span>,<span class=\"number\">214</span>,<span class=\"number\">78</span>,<span class=\"number\">35</span>,<span class=\"number\">125</span>,<span class=\"number\">789</span>,<span class=\"number\">11</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>,j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n.length; i++) &#123;</span><br><span class=\"line\">            temp = n[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = i; j &gt;<span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果当前数前面的数大于当前数，则把前面的数向后移一个位置</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(n[j-<span class=\"number\">1</span>]&gt;temp)&#123;</span><br><span class=\"line\">                    n[j] = n[j-<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//第一个数已经移到第二个数，将当前数放到第一个位置，这一趟结束</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(j==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                        n[j-<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;<span class=\"comment\">//如果不大于，将当前数放到j的位置，这一趟结束</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    n[j] = temp;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Arrays.toString(n));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Arrays.toString(n));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>快速排序<br>4.1 动图演示</li>\n</ol>\n<p>4.2 思路分析</p>\n<p>快速排序的思想就是，选一个数作为基数（这里我选的是第一个数），大于这个基数的放到右边，小于这个基数的放到左边，等于这个基数的数可以放到左边或右边，看自己习惯，这里我是放到了左边，</p>\n<p>一趟结束后，将基数放到中间分隔的位置，第二趟将数组从基数的位置分成两半，分割后的两个的数组继续重复以上步骤，选基数，将小数放在基数左边，将大数放到基数的右边，在分割数组，，，直到数组不能再分为止，排序结束。</p>\n<p>例如从小到大排序:</p>\n<ol>\n<li>第一趟，第一个数为基数 temp，设置两个指针 left = 0，right = n.length，</li>\n</ol>\n<p>① 从 right 开始与基数 temp 比较，如果 n[right]&gt;基数 temp，则 right 指针向前移一位，继续与基数 temp 比较，直到不满足 n[right]&gt;基数 temp</p>\n<p>② 将 n[right]赋给 n[left]</p>\n<p>③ 从 left 开始与基数 temp 比较，如果 n[left]&lt;=基数 temp，则 left 指针向后移一位，继续与基数 temp 比较，直到不满足 n[left]&lt;=基数 temp</p>\n<p>④ 将 n[left]赋给 n[rigth]</p>\n<p>⑤ 重复 ①-④ 步，直到 left==right 结束，将基数 temp 赋给 n[left]</p>\n<ol start=\"2\">\n<li><p>第二趟，将数组从中间分隔，每个数组再进行第 1 步的操作，然后再将分隔后的数组进行分隔再快排，</p>\n</li>\n<li><p>递归重复分隔快排，直到数组不能再分，也就是只剩下一个元素的时候，结束递归，排序完成</p>\n</li>\n</ol>\n<p>根据思路分析，第一趟的执行流程如下图所示：</p>\n<p>4.3 复杂度分析</p>\n<ol>\n<li>时间复杂度：</li>\n</ol>\n<p>最坏情况就是每一次取到的元素就是数组中最小/最大的，这种情况其实就是冒泡排序了(每一次都排好一个元素的顺序)</p>\n<p>这种情况时间复杂度就好计算了，就是冒泡排序的时间复杂度：T[n] = n * (n-1) = n^2 + n;</p>\n<p>最好情况下是 O(nlog2n)，推导过程如下：</p>\n<p>（递归算法的时间复杂度公式：T[n] = aT[n/b] + f(n) ）</p>\n<p>所以平均时间复杂度为 O（nlog2n）</p>\n<ol start=\"2\">\n<li>空间复杂度：</li>\n</ol>\n<p>快速排序使用的空间是 O(1)的，也就是个常数级；而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据：</p>\n<p>最优的情况下空间复杂度为:O(log2n)；每一次都平分数组的情况</p>\n<p>最差的情况下空间复杂度为：O( n )；退化为冒泡排序的情况</p>\n<p>所以平均空间复杂度为 O（log2n）</p>\n<p>4.4 Java 代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">quick</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">33</span>,<span class=\"number\">27</span>,<span class=\"number\">66</span>,<span class=\"number\">9</span>,<span class=\"number\">7</span>,<span class=\"number\">88</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//        int[] arr = new int[]&#123;1,3,2&#125;;</span></span><br><span class=\"line\">        f(arr,<span class=\"number\">0</span>,arr.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr,<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> end)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//直到start&gt;=end时结束递归</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(start&lt;end)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> left = start;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> right = end;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = arr[start];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(left&lt;right)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//右面的数字大于标准数时，右边的数的位置不变，指针向左移一个位置</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(left&lt;right &amp;&amp; arr[right]&gt;temp)&#123;</span><br><span class=\"line\">                    right--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//右边的数字及下标小于或等于基本数，将右边的数放到左边</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(left&lt;right) &#123;</span><br><span class=\"line\">                     arr[left] = arr[right];</span><br><span class=\"line\">                     left++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">////左边的数字小于或等于标准数时，左边的数的位置不变，指针向右移一个位置</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(left&lt;right &amp;&amp; arr[left]&lt;=temp)&#123;</span><br><span class=\"line\">                    left++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//左边的数字大于基本数，将左边的数放到右边</span></span><br><span class=\"line\">                arr[right] = arr[left];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//一趟循环结束，此时left=right，将基数放到这个重合的位置，</span></span><br><span class=\"line\">            arr[left] = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//将数组从left位置分为两半，继续递归下去进行排序</span></span><br><span class=\"line\">            f(arr,start,left);</span><br><span class=\"line\">            f(arr,left+<span class=\"number\">1</span>,end);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>归并排序<br>5.1 动图演示</li>\n</ol>\n<p>5.2 思路分析</p>\n<p>归并排序就是递归得将原始数组递归对半分隔，直到不能再分（只剩下一个元素）后，开始从最小的数组向上归并排序</p>\n<p>\\1. 向上归并排序的时候，需要一个暂存数组用来排序，</p>\n<p>\\2. 将待合并的两个数组，从第一位开始比较，小的放到暂存数组，指针向后移，</p>\n<p>\\3. 直到一个数组空，这时，不用判断哪个数组空了，直接将两个数组剩下的元素追加到暂存数组里，</p>\n<p>\\4. 再将暂存数组排序后的元素放到原数组里，两个数组合成一个，这一趟结束。</p>\n<p>根据思路分析，每一趟的执行流程如下图所示：</p>\n<p>5.3 复杂度分析</p>\n<ol>\n<li>时间复杂度：递归算法的时间复杂度公式：T[n] = aT[n/b] + f(n) **<br>**</li>\n</ol>\n<p>无论原始数组是否是有序的，都要递归分隔并向上归并排序，所以时间复杂度始终是 O（nlog2n）</p>\n<ol start=\"2\">\n<li>空间复杂度：</li>\n</ol>\n<p>每次两个数组进行归并排序的时候，都会利用一个长度为 n 的数组作为辅助数组用于保存合并序列，所以空间复杂度为 O（n）</p>\n<p>5.4 Java 代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">        merge(arr,<span class=\"number\">0</span>,arr.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//归并</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr,<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> high)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> center = (high+low)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(low&lt;high)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//递归，直到low==high，也就是数组已不能再分了，</span></span><br><span class=\"line\">            merge(arr,low,center);</span><br><span class=\"line\">            merge(arr,center+<span class=\"number\">1</span>,high);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//当数组不能再分，开始归并排序</span></span><br><span class=\"line\">            mergeSort(arr,low,center,high);</span><br><span class=\"line\">            System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//排序</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr,<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> center,<span class=\"keyword\">int</span> high)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于暂存排序后的数组的临时数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] tempArr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[arr.length];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = low,j = center+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//临时数组的下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//循环遍历两个数组的数字，将小的插入到临时数组里</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;=center &amp;&amp; j&lt;= high)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//左边数组的数小，插入到新数组</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[i]&lt;arr[j])&#123;</span><br><span class=\"line\">                tempArr[index] = arr[i];</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;<span class=\"comment\">//右边数组的数小，插入到新数组</span></span><br><span class=\"line\">                tempArr[index] = arr[j];</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//处理左半边数组多余的数据，将左半边多余的数据直接追加的临时数组的后面</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;=center)&#123;</span><br><span class=\"line\">            tempArr[index] = arr[i];</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//处理右半边数组多余的数据，将右半边多余的数据直接追加的临时数组的后面</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;= high)&#123;</span><br><span class=\"line\">            tempArr[index] = arr[j];</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将临时数组中的数据重新放进原数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; index; k++) &#123;</span><br><span class=\"line\">            arr[k+low] = tempArr[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>基数排序<br>6.1 动图演示</li>\n</ol>\n<p>6.2 思路分析</p>\n<p>基数排序第 i 趟将待排数组里的每个数的 i 位数放到 tempj（j=1-10）队列中，然后再从这十个队列中取出数据，重新放到原数组里，直到 i 大于待排数的最大位数。</p>\n<p>1.数组里的数最大位数是 n 位，就需要排 n 趟，例如数组里最大的数是 3 位数，则需要排 3 趟。</p>\n<p>2.若数组里共有 m 个数，则需要十个长度为 m 的数组 tempj（j=0-9）用来暂存 i 位上数为 j 的数，例如，第 1 趟，各位数为 0 的会被分配到 temp0 数组里，各位数为 1 的会被分配到 temp1 数组里……</p>\n<p>3.分配结束后，再依次从 tempj 数组中取出数据，遵循先进先进原则，例如对数组{1，11，2，44，4}，进行第 1 趟分配后，temp1={1,11}，temp2={2}，temp4={44，4}，依次取出元素后{1，11，2，44，4}，第一趟结束</p>\n<p>4.循环到 n 趟后结束，排序完成</p>\n<p>根据思路分析，每一趟的执行流程如下图所示：</p>\n<p>通过基数排序对数组{53, 3, 542, 748, 14, 214, 154, 63, 616}：</p>\n<p>6.3 复杂度分析</p>\n<ol>\n<li>时间复杂度：**<br>**</li>\n</ol>\n<p>每一次关键字的桶分配都需要 O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要 O(n)的时间复杂度。</p>\n<p>假如待排数据可以分为 d 个关键字，则基数排序的时间复杂度将是 O(d*2n) ，当然 d 要远远小于 n，因此基本上还是线性级别的。</p>\n<p>系数 2 可以省略，且无论数组是否有序，都需要从个位排到最大位数，所以时间复杂度始终为 O(d*n) 。其中，n 是数组长度，d 是最大位数。</p>\n<ol start=\"2\">\n<li>空间复杂度：</li>\n</ol>\n<p>基数排序的空间复杂度为 O(n+k)，其中 k 为桶的数量，需要分配 n 个数。</p>\n<p>6.4 Java 代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">33</span>,<span class=\"number\">27</span>,<span class=\"number\">66</span>,<span class=\"number\">9</span>,<span class=\"number\">7</span>,<span class=\"number\">88</span>&#125;;</span><br><span class=\"line\">        radixSort(arr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">radixSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//求出待排数的最大数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxLength=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(maxLength&lt;arr[i])</span><br><span class=\"line\">                maxLength = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//根据最大数求最大长度</span></span><br><span class=\"line\">        maxLength = (maxLength+<span class=\"string\">\"\"</span>).length();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//用于暂存数据的数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] temp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>][arr.length];</span><br><span class=\"line\">        <span class=\"comment\">//用于记录temp数组中每个桶内存的数据的数量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] counts = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"comment\">//用于记录每个数的i位数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//用于取的元素需要放的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//根据最大长度决定排序的次数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,n=<span class=\"number\">1</span>; i &lt; maxLength; i++,n*=<span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">                num = arr[j]/n%<span class=\"number\">10</span>;</span><br><span class=\"line\">                temp[num][counts[num]] = arr[j];</span><br><span class=\"line\">                counts[num]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//从temp中取元素重新放到arr数组中</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; counts.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j2 = <span class=\"number\">0</span>; j2 &lt; counts[j]; j2++) &#123;</span><br><span class=\"line\">                    arr[index] = temp[j][j2];</span><br><span class=\"line\">                    index++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                counts[j]=<span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            index=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>希尔（shell）排序<br>7.1 动图演示</li>\n</ol>\n<p>7.2 思路分析</p>\n<p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。</p>\n<p>简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的 0 要回到首位置很是费劲，比较和移动元素均需 n-1 次。</p>\n<p>而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为 1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为 1 时，其实多数情况下只需微调即可，不会涉及过多的数据移动。</p>\n<p>来看下希尔排序的基本步骤，在此选择增量 gap=length/2，缩小增量继续以 gap = gap/2 的方式，这种增量选择可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处做示例使用希尔增量。</p>\n<p>7.3 复杂度分析</p>\n<ol>\n<li>时间复杂度：最坏情况下，每两个数都要比较并交换一次，则最坏情况下的时间复杂度为 O（n2）, 最好情况下，数组是有序的，不需要交换，只需要比较，则最好情况下的时间复杂度为 O（n）。</li>\n</ol>\n<p>经大量人研究，希尔排序的平均时间复杂度为 O（n1.3）（这个我也不知道咋来的，书上和博客上都这样说，也没找到个具体的依据，，，）。</p>\n<ol start=\"2\">\n<li>空间复杂度：希尔排序，只需要一个变量用于两数交换，与 n 的大小无关，所以空间复杂度为：O（1）。</li>\n</ol>\n<p>7.4 Java 代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">shell</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">33</span>,<span class=\"number\">27</span>,<span class=\"number\">66</span>,<span class=\"number\">9</span>,<span class=\"number\">7</span>,<span class=\"number\">88</span>&#125;;</span><br><span class=\"line\">        shellSort(arr);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">        <span class=\"comment\">//控制增量序列,增量序列为1的时候为最后一趟</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = arr.length/<span class=\"number\">2</span>; i &gt;<span class=\"number\">0</span>; i/=<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//根据增量序列，找到每组比较序列的最后一个数的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//根据该比较序列的最后一个数的位置，依次向前执行插入排序</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = j-i; k &gt;=<span class=\"number\">0</span>; k-=i) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(arr[k]&gt;arr[k+i])&#123;</span><br><span class=\"line\">                        temp = arr[k];</span><br><span class=\"line\">                        arr[k]  = arr[k+i];</span><br><span class=\"line\">                        arr[k+i] = temp;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>堆排序<br>8.1 动图演示</li>\n</ol>\n<p>8.2 思路分析</p>\n<p>先来了解下堆的相关概念：堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</p>\n<p>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p>\n<p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p>\n<p>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</p>\n<p>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</p>\n<p>了解了这些定义。接下来看看堆排序的基本思想及基本步骤：</p>\n<p>堆排序基本思想及步骤</p>\n<p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了</p>\n<p>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</p>\n<p>a.假设给定无序序列结构如下</p>\n<p>2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。</p>\n<p>4.找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换。</p>\n<p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6。</p>\n<p>此时，我们就将一个无需序列构造成了一个大顶堆。</p>\n<p>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</p>\n<p>a.将堆顶元素 9 和末尾元素 4 进行交换</p>\n<p>b.重新调整结构，使其继续满足堆定义</p>\n<p>c.再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.</p>\n<p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p>\n<p>再简单总结下堆排序的基本思路：</p>\n<p>a.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p>\n<p>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</p>\n<p>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p>\n<p>8.3 复杂度分析</p>\n<ol>\n<li><p>时间复杂度：堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为 O(n)，在交换并重建堆的过程中，需交换 n-1 次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为 nlogn。所以堆排序时间复杂度最好和最坏情况下都是 O(nlogn)级。</p>\n</li>\n<li><p>空间复杂度：堆排序不要任何辅助数组，只需要一个辅助变量，所占空间是常数与 n 无关，所以空间复杂度为 O(1)。</p>\n</li>\n</ol>\n<p>8.4 Java 代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">duipaixu</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = arr.length;</span><br><span class=\"line\">        <span class=\"comment\">//从最后一个非叶节点开始构建大顶堆</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = arr.length/<span class=\"number\">2</span>-<span class=\"number\">1</span>; i &gt;=<span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            maximumHeap(i,arr,length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//从最小的叶子节点开始与根节点进行交换并重新构建大顶堆</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = arr.length-<span class=\"number\">1</span>; i &gt;=<span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\"><span class=\"comment\">//            System.out.println(Arrays.toString(arr));</span></span><br><span class=\"line\">            swap(arr,<span class=\"number\">0</span>,i);</span><br><span class=\"line\">            length--;</span><br><span class=\"line\">            maximumHeap(<span class=\"number\">0</span>,arr,length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//构建大顶堆</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">maximumHeap</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span>[] arr,<span class=\"keyword\">int</span> length)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = arr[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i*<span class=\"number\">2</span>+<span class=\"number\">1</span>; j &lt; length; j=j*<span class=\"number\">2</span>+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果右孩子大于做孩子，则指向右孩子</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j+<span class=\"number\">1</span>&lt;length &amp;&amp; arr[j+<span class=\"number\">1</span>]&gt;arr[j])&#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//如果最大的孩子大于当前节点，则将大孩子赋给当前节点，修改当前节点为其大孩子节点，再向下走。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j]&gt;temp)&#123;</span><br><span class=\"line\">                arr[i] = arr[j];</span><br><span class=\"line\">                i = j;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//将temp放到最终位置</span></span><br><span class=\"line\">        arr[i] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//交换</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Python爬虫入门（一）","url":"/2020/07/20/Python%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"总述\"><a href=\"#总述\" class=\"headerlink\" title=\"总述\"></a>总述</h1><p>本来早就想学习下python爬虫了，总是找各种借口，一直拖到现在才开始系统的学习。</p>\n<p>我用的教程是中国大学MOOC上的由北京理工大学开设的Python网络爬虫与信息提取。</p>\n<p>废话不多说，直接开始。</p>\n<h1 id=\"1-网络爬虫之规则\"><a href=\"#1-网络爬虫之规则\" class=\"headerlink\" title=\"1. 网络爬虫之规则\"></a>1. 网络爬虫之规则</h1><h2 id=\"1-1-requests库入门\"><a href=\"#1-1-requests库入门\" class=\"headerlink\" title=\"1.1 requests库入门\"></a>1.1 requests库入门</h2><h3 id=\"1-1-1-requests库简介\"><a href=\"#1-1-1-requests库简介\" class=\"headerlink\" title=\"1.1.1 requests库简介\"></a>1.1.1 requests库简介</h3><ol>\n<li><p>Requests 是唯一的一个非转基因的 Python HTTP 库，人类可以安全享用。</p>\n</li>\n<li><p>安装     <code>pip install requests</code></p>\n</li>\n<li><p>引入    <code>import requests</code></p>\n</li>\n<li><p>7种常用方法</p>\n<p>  <code>requests.request()</code> 构造一个请求，最基础的方法<br>  <code>requests.get()</code>     获得HTML网页的主要方法，对应于HTTP的GET<br>  <code>requests.head()</code>    获得HTML网页头的主要方法，对应于HTTP的HEAD<br>  <code>requests.post()</code>    提交post请求，POST<br>  <code>requests.put()</code>     提交put请求，PUT<br>  <code>requests.patch()</code>   提交局部修改请求,PATCH<br>  <code>requests.delete()</code>  删除请求，DELETE</p>\n</li>\n</ol>\n<ol start=\"5\">\n<li><p>requests库的get()方法</p>\n<p><code>r = requests.get(url)</code><br>该语句的意为构造一个向服务器请求资源的Request对象，返回的是一个包含服务器资源的Response对象，用r来接收。</p>\n</li>\n<li><p>Response对象的属性</p>\n<p><code>r.ststus_code</code>           http请求的返回状态，200为成功<br><code>r.text</code>                  http响应内容的字符串形式，url对应的页面内容<br><code>r.encoding</code>              http header中猜测的编码格式<br><code>r.apparent_encoding</code>     http内容中猜测的响应内容的编码格式，备用<br><code>r.content</code>               http响应内容的二进制形式</p>\n<h3 id=\"1-1-2-通用代码框架\"><a href=\"#1-1-2-通用代码框架\" class=\"headerlink\" title=\"1.1.2 通用代码框架\"></a>1.1.2 通用代码框架</h3></li>\n<li><p>Requests库的异常</p>\n<p><code>requests.ConnectionError</code>   网络连接异常<br><code>requests.HTTPError</code>         http错误异常<br><code>requesrs.URLRequired</code>       URL缺失异常<br><code>requests,ToomanyRedirects</code>  重定向异常，超过最大重定向次数<br><code>requests.ConnectTimeOut</code>    连接远程服务器超时异常<br><code>requests,Time</code>              请求URL超时，超时异常（包括上述的整个请求过程）</p>\n</li>\n<li><p>通用代码框架</p>\n</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getHTMLText</span><span class=\"params\">(url)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        r = requests.get(url, timeout=<span class=\"number\">30</span>)</span><br><span class=\"line\">        r.raise_for_status()</span><br><span class=\"line\">        r.encoding = r.apparent_encoding</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r.text</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'超时异常'</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    url = <span class=\"string\">\"https://www.baidu.com/\"</span></span><br><span class=\"line\">    print(getHTMLText(url))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTTP协议及Requests库方法\"><a href=\"#HTTP协议及Requests库方法\" class=\"headerlink\" title=\"HTTP协议及Requests库方法\"></a>HTTP协议及Requests库方法</h3><ol>\n<li><p>HTTP协议</p>\n<p>HTTP协议, Hypertext Transfer Protocol, 超文本传输协议。<br>是一个基于“请求与响应”模式的、无状态的应用层协议。<br>采用URL作为定位网络资源的标识。</p>\n</li>\n<li><p>URL</p>\n<p>URL是通过HTTP协议存取资源的Internet路径，一个URL对应一个数据资源。<br>格式为：<a href=\"http://host[:port][path]\">http://host[:port][path]</a><br>host: 合法的Internet主机域名或IP地址<br>port: 端口号，省略端口为80<br>path: 请求资源的路径</p>\n</li>\n<li><p>HTTP协议对资源的操作</p>\n</li>\n</ol>\n<p>GET：发送一个请求来取得服务器上的某一资源。</p>\n<p>HEAD：HEAD和GET是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。</p>\n<p>POST：向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。</p>\n<p>PUT：这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据。</p>\n<p>PATCH：向服务器更新数据。</p>\n<p>DELETE：删除某一个资源。</p>\n<ol start=\"4\">\n<li>HTTP协议方法与requests库方法一致。</li>\n</ol>\n","categories":["Python爬虫"],"tags":["Python","爬虫","入门"]},{"title":"A first look at C++ (9)","url":"/2023/01/18/A%20first%20look%20at%20C++%20(9)/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"Pointer\"><a href=\"#Pointer\" class=\"headerlink\" title=\"Pointer\"></a>Pointer</h1><p>Pointer footprint: 4 bytes for all pointer types on 32-bit operating systems</p>\n<p>Null pointer: Pointer variables point to a space in memory numbered 0, purpose: initialize pointer variables, memory pointed to by a null pointer is not accessible</p>\n<p>Wild pointer: pointer variable points to an illegal memory space</p>\n<p>Neither null pointers nor wild pointers are the space we are requesting, so they should not be accessed.</p>\n<h1 id=\"const-modified-pointers\"><a href=\"#const-modified-pointers\" class=\"headerlink\" title=\"const-modified pointers\"></a>const-modified pointers</h1><p>There are three cases of const-modified pointers</p>\n<p>const modifies a pointer - a constant pointer<br>const modifies constants - pointer constants<br>const modifies both pointers and constants<br>Example.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//const modifies a pointer, the pointer pointing to can be changed, the value pointed to by the pointer can not be changed</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * p1 = &amp;a;</span><br><span class=\"line\">\tp1 = &amp;b; <span class=\"comment\">//correct</span></span><br><span class=\"line\">\t<span class=\"comment\">//*p1 = 100; error</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//const modifies constants, pointer pointers cannot be changed, pointer values can be changed</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p2 = &amp;a;</span><br><span class=\"line\">\t<span class=\"comment\">//p2 = &amp;b; //error</span></span><br><span class=\"line\">\t*p2 = <span class=\"number\">100</span>; <span class=\"comment\">//correct</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//const modifies both pointers and constants</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p3 = &amp;a;</span><br><span class=\"line\">\t<span class=\"comment\">//p3 = &amp;b; //error</span></span><br><span class=\"line\">\t<span class=\"comment\">//*p3 = 100; //error</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>See whether the const is immediately followed by a pointer or a constant, a pointer is a constant pointer, a constant is a pointer constant</p>\n<h1 id=\"Pointers-and-arrays\"><a href=\"#Pointers-and-arrays\" class=\"headerlink\" title=\"Pointers and arrays\"></a>Pointers and arrays</h1><p>Example.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[] = &#123; <span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> * p = arr; <span class=\"comment\">// pointer to the array, arr is the first address of the array, the array name arr is a pointer</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"first element: \"</span> &lt;&lt; arr[<span class=\"number\">0</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Pointer access to the first element: \"</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">// traverse the array using pointers</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\tp++;<span class=\"comment\">//shift back 4 bytes</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>When an array name is passed to a function as an argument, it is degraded to a pointer to the first element</p>\n<p>Pointers and functions<br>Function: Using a pointer as a function parameter, the value of the real parameter can be modified</p>\n<p>Example.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//value passing</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap1</span><span class=\"params\">(<span class=\"keyword\">int</span> a ,<span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//address passing</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap2</span><span class=\"params\">(<span class=\"keyword\">int</span> * p1, <span class=\"keyword\">int</span> *p2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp = *p1;</span><br><span class=\"line\">\t*p1 = *p2;</span><br><span class=\"line\">\t*p2 = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\">\tswap1(a, b); <span class=\"comment\">// value passing does not change real parameters</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tswap2(&amp;a, &amp;b); <span class=\"comment\">// address passing will change the real reference</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"b = \"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>If you don’t want to modify the real reference, use value passing, if you want to modify the real reference, use address passing</p>\n<h1 id=\"Memory-model\"><a href=\"#Memory-model\" class=\"headerlink\" title=\"Memory model\"></a>Memory model</h1><p>C++ programs, when executed, divide memory into 4 general areas</p>\n<p>Code area: the binary code of the function body, which is managed by the operating system</p>\n<p>Global area: holds global and static variables and constants</p>\n<p>Stack area: automatically allocated and released by the compiler to store the function’s parameter values, local variables, etc.</p>\n<p>Heap area: allocated and released by the programmer, if the programmer does not release it, it will be recycled by the operating system at the end of the program.</p>\n<h1 id=\"Before-the-program-runs\"><a href=\"#Before-the-program-runs\" class=\"headerlink\" title=\"Before the program runs\"></a>Before the program runs</h1><p>After the program is compiled, the exe executable program is generated, and before the program is executed, it is divided into two areas</p>\n<p>Code area.</p>\n<p>It holds the machine instructions executed by CPU.</p>\n<p>The code area is shared, the purpose of sharing is to have only one copy of the code in memory for programs that are executed frequently</p>\n<p>The code area is read-only, and the reason for making it read-only is to prevent the program from accidentally modifying its instructions</p>\n<p>Global area.</p>\n<p>Global and static variables are stored here.</p>\n<p>The global area also contains the constants area, where string constants and other constants are also stored.</p>\n<p>==The data in this area is released by the operating system at the end of the program==.</p>\n<p>To summarize.</p>\n<p>C++ is divided into a global area and a code area before the program runs<br>The code area is shared and read-only in nature.<br>The global area holds global variables, static variables, and constants.<br>The const area holds const-modified global constants and string constants<br>const-modified local constants are in the stack</p>\n<h1 id=\"After-the-program-runs\"><a href=\"#After-the-program-runs\" class=\"headerlink\" title=\"After the program runs\"></a>After the program runs</h1><p>Stack area.</p>\n<p>The compiler automatically allocates and releases the stack to hold the values of function parameters, local variables, etc.</p>\n<p>Note: Do not return the address of local variables, the data opened in the stack area is automatically released by the compiler</p>\n<p>Heap area.</p>\n<p>If the programmer does not release it, it will be reclaimed by the operating system at the end of the program.</p>\n<p>In C++, the main use of new is to open up memory in the heap area.<br>Example.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;<span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">10</span>); <span class=\"comment\">// the pointer a points to the address of the new object</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a; <span class=\"comment\">//even if the function (on the stack) space is reclaimed, the address of the new object is still returned</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = func(); <span class=\"comment\">//pointer p points to the address of the new object</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>To summarize.</p>\n<p>Heap data is opened and freed by the programmer</p>\n<p>Heap data is opened using the new keyword</p>\n<h1 id=\"new-operator\"><a href=\"#new-operator\" class=\"headerlink\" title=\"new operator\"></a>new operator</h1><p>C++ uses the ==new== operator to open data in the heap area</p>\n<p>The data opened in the heap area is opened manually by the programmer and released manually, using the ==delete== operator.</p>\n<p>Syntax: new Data type</p>\n<p>The data created with new returns a pointer to the type corresponding to that data</p>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p>Basic Usage</p>\n<ul>\n<li>Role: * Alias the variable</li>\n</ul>\n<p>Syntax: datatype &amp; alias = original name</p>\n<p>Caution<br>References must be initialized<br>References cannot be changed after initialization<br>Intrinsic<br>essence: the essence of a reference is a pointer constant in the internal implementation of c++.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">/found to be a reference, converted to <span class=\"keyword\">int</span>* <span class=\"keyword\">const</span> ref = &amp;a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; ref)</span></span>&#123;</span><br><span class=\"line\">ref = <span class=\"number\">100</span>; <span class=\"comment\">// ref is a reference, convert to *ref = 100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// automatically converted to int* const ref = &amp;a; pointer constants are pointers to unchangeable, also explains why references are unchangeable</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>&amp; ref = a;</span><br><span class=\"line\">    ref = <span class=\"number\">20</span>; <span class=\"comment\">// internal found ref is a reference, automatically help us convert to: *ref = 20;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a:\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ref:\"</span> &lt;&lt; ref &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    func(a);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Conclusion: C++ recommends the reference technique because the syntax is convenient and references are essentially pointer constants, but all pointer operations are done for us by the compiler</p>\n<h1 id=\"constant-references\"><a href=\"#constant-references\" class=\"headerlink\" title=\"constant references\"></a>constant references</h1><p>Role: Constant references are mainly used to modify formal parameters and prevent malfunctioning</p>\n<p>In the function form reference list, you can add ==const to modify the form reference == to prevent the form reference from changing the real reference</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reference to the use of scenarios, usually used to modify the formal parameters</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showValue</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; v)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//v += 10;</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; v &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//int&amp; ref = 10; the reference itself needs a legal memory space, so this line is wrong</span></span><br><span class=\"line\">    <span class=\"comment\">// Adding const is fine, the compiler optimizes the code, int temp = 10; const int&amp; ref = temp;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; ref = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//ref = 100; //no variable can be modified after adding const</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ref &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//The constant reference is used in the function to prevent the real reference from being modified by mistake</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    showValue(a);</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Function-enhancement\"><a href=\"#Function-enhancement\" class=\"headerlink\" title=\"Function enhancement\"></a>Function enhancement</h1><p>Function default parameters<br>In C++, it is possible to have default values for the formal parameters in a function’s formal parameter list.</p>\n<p>Syntax: return value type function name (parameter= default value) {}</p>\n<p>Caution:</p>\n<p>If a position parameter has a default value, then from this position onwards, from left to right, all must have a default value</p>\n<p>If the function declaration has a default value, the function implementation cannot have a default parameter</p>\n<p>Distinguish between function declaration, function implementation and function call</p>\n<p>Function placeholder parameters<br>C++ functions can have placeholder arguments in the list of formal parameters, which are used for placeholders and must be filled when the function is called</p>\n<p>Syntax: return value type function name (data type) {}</p>\n<p>At this stage there is little point in having placeholder parameters for functions, but the technique will be used later in the course</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// function placeholder arguments , placeholder arguments can also have default arguments</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span>)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"this is func\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"function-overloading\"><a href=\"#function-overloading\" class=\"headerlink\" title=\"function overloading\"></a>function overloading</h1><p>Effect: function names can be the same to improve reusability</p>\n<p>Function overloading satisfies the condition that</p>\n<p>Under the same scope<br>The function name is the same<br>Different types or numbers of arguments or different order of arguments</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Cautions on function overloading</span></span><br><span class=\"line\"><span class=\"comment\">//1. Reference as overloading condition</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"func (int &amp;a) called with \"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"func (const int &amp;a) call \"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/ / <span class=\"number\">2</span>, function overloading encounter function <span class=\"keyword\">default</span> parameters</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b = <span class=\"number\">10</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"func2(int a, int b = 10) call\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"func2(int a) call\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">func(a); <span class=\"comment\">// call without const</span></span><br><span class=\"line\">func(<span class=\"number\">10</span>); <span class=\"comment\">//call with const</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//func2(10); //runs into ambiguity with default arguments, need to avoid</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Classes-and-objects\"><a href=\"#Classes-and-objects\" class=\"headerlink\" title=\"Classes and objects\"></a>Classes and objects</h1><p>Encapsulation<br>Difference between struct and class<br>The only difference between struct and class in C++ is that the default access rights are different</p>\n<p>Difference.</p>\n<p>struct is public by default<br>class is private by default<br>Initialization and cleanup of objects<br>Constructors and destructors<br>Constructor syntax: class name(){}</p>\n<p>The program will automatically call the constructor when calling the object, no need to call it manually, and it will only be called once.</p>\n<p>Destructor syntax: ~class name(){}</p>\n<p>Constructor call</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. Constructor classification</span></span><br><span class=\"line\"><span class=\"comment\">// according to the classification of parameters are divided into construction with and without parameters without parameters also known as the default constructor</span></span><br><span class=\"line\"><span class=\"comment\">// according to the type of classification into ordinary constructor and copy constructor</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"comment\">// No reference (default) constructor</span></span><br><span class=\"line\">Person() &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Unreferenced constructor!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//Parametric constructor</span></span><br><span class=\"line\">Person(<span class=\"keyword\">int</span> a) &#123;</span><br><span class=\"line\">age = a;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Parametric constructor!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//copy constructor</span></span><br><span class=\"line\">Person(<span class=\"keyword\">const</span> Person&amp; p) &#123;</span><br><span class=\"line\">age = p.age;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Copy constructor!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// destructor</span></span><br><span class=\"line\">~Person() &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Destructor!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2. Constructor calls</span></span><br><span class=\"line\"><span class=\"comment\">// call the constructor without parameters</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">Person p; <span class=\"comment\">//call the constructor without parameters</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// call the constructor with parameters</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2.1 Parenthesis method, commonly used</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//Note 1: You can't add parentheses to a call to a constructor without parameters, if you do the compiler thinks it's a function declaration</span></span><br><span class=\"line\">    <span class=\"comment\">//Person p2();</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2.2 Explicit method</span></span><br><span class=\"line\">    Person p2 = Person(<span class=\"number\">10</span>);</span><br><span class=\"line\">    Person p3 = Person(p2);</span><br><span class=\"line\">    <span class=\"comment\">//Person(10) written alone is an anonymous object Destructed immediately after the end of the current line</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2.3 Implicit conversion method</span></span><br><span class=\"line\">    Person p4 = <span class=\"number\">10</span>; <span class=\"comment\">// Person p4 = Person(10);</span></span><br><span class=\"line\">    Person p5 = p4; <span class=\"comment\">// Person p5 = Person(p4);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Note 2: You can't use the copy constructor to initialize anonymous objects The compiler considers it an object declaration</span></span><br><span class=\"line\">    <span class=\"comment\">// Person p5(p4);</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    test01();</span><br><span class=\"line\">    <span class=\"comment\">//test02();</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Timing-of-copy-constructor-calls\"><a href=\"#Timing-of-copy-constructor-calls\" class=\"headerlink\" title=\"Timing of copy constructor calls\"></a>Timing of copy constructor calls</h1><p>There are three general cases of timing of copy constructor calls in C++</p>\n<p>Initializing a new object with an object that has already been created<br>Passing a value to a function argument (as a function argument)<br>Returning a local object as a value (as a function return value)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">Person() &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Unreferenced constructor!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">mAge = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person(<span class=\"keyword\">int</span> age) &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Parametric constructor!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">mAge = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person(<span class=\"keyword\">const</span> Person&amp; p) &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Copy constructor!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">mAge = p.mAge;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// The destructor is called before freeing memory</span></span><br><span class=\"line\">~Person() &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Destructor!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"keyword\">int</span> mAge;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1. initialize a new object using an object that has already been created</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">man</span><span class=\"params\">(<span class=\"number\">100</span>)</span></span>; <span class=\"comment\">//p object has been created</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">newman</span><span class=\"params\">(man)</span></span>; <span class=\"comment\">//call the copy constructor</span></span><br><span class=\"line\">    Person newman2 = man; <span class=\"comment\">//copy constructor</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Person newman3;</span></span><br><span class=\"line\">    <span class=\"comment\">//newman3 = man; //not a copy constructor call, assignment operation</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2. value passing to function parameters</span></span><br><span class=\"line\"><span class=\"comment\">//equivalent to Person p1 = p;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doWork</span><span class=\"params\">(Person p1)</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">Person p; <span class=\"comment\">// no-parameter constructor</span></span><br><span class=\"line\">doWork(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3. Returning a local object as a value</span></span><br><span class=\"line\"><span class=\"function\">Person <span class=\"title\">doWork2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">Person p1;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; (<span class=\"keyword\">int</span> \\*)&amp;p1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> p1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test03</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">Person p = doWork2();</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; (<span class=\"keyword\">int</span> \\*)&amp;p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//test01();</span></span><br><span class=\"line\">    <span class=\"comment\">//test02();</span></span><br><span class=\"line\">    test03();</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Constructor calling rules<br>By default, the c++ compiler adds at least 3 functions to a class</p>\n<ol>\n<li><p>default constructor (no reference, empty function body)</p>\n</li>\n<li><p>default destructor (no reference, empty function body)</p>\n</li>\n<li><p>the default copy constructor, which copies the value of the property</p>\n</li>\n</ol>\n<p>Constructor call rules are as follows.</p>\n<p>If the user defines a constructor with parameters, c++ does not provide a default construct without parameters, but will provide a default copy constructor.<br>If the user defines a copy constructor, c++ will not provide another constructor.</p>\n<h1 id=\"Deep-copy-and-shallow-copy\"><a href=\"#Deep-copy-and-shallow-copy\" class=\"headerlink\" title=\"Deep copy and shallow copy\"></a>Deep copy and shallow copy</h1><p>shallow copy: simple assignment copy operation</p>\n<p>Deep copy: reapply space in the heap to perform copy operations</p>\n<p>If an attribute is opened in the heap area, you must provide your own copy constructor to prevent the problems caused by shallow copies</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"comment\">// no reference (default) constructor</span></span><br><span class=\"line\">Person() &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Unreferenced constructor!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//with-parameter constructor</span></span><br><span class=\"line\">Person(<span class=\"keyword\">int</span> age ,<span class=\"keyword\">int</span> <span class=\"built_in\">height</span>) &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Parametric constructor!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    \tm_age = age;</span><br><span class=\"line\">    \tm_height = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"built_in\">height</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//copy constructor</span></span><br><span class=\"line\">    Person(<span class=\"keyword\">const</span> Person&amp; p) &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Copy constructor!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    \t<span class=\"comment\">//If you don't use deep copy to create new memory in the heap area, it will lead to duplicate heap release problems caused by shallow copy</span></span><br><span class=\"line\">    \tm_age = p.m_age;</span><br><span class=\"line\">    \tm_height = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(*p.m_height);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// destructor</span></span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Destructor!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (m_height ! = <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">delete</span> m_height;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"keyword\">int</span> m_age;</span><br><span class=\"line\"><span class=\"keyword\">int</span>\\* m_height;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">18</span>, <span class=\"number\">180</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(p1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Age of p1: \"</span> &lt;&lt; p1.m_age &lt;&lt; <span class=\"string\">\" Height: \"</span> &lt;&lt; *p1.m_height &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"age of p2: \"</span> &lt;&lt; p2.m_age &lt;&lt; <span class=\"string\">\" height: \"</span> &lt;&lt; *p2.m_height &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    test01();</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Initialize-list\"><a href=\"#Initialize-list\" class=\"headerlink\" title=\"Initialize list\"></a>Initialize list</h1><p>Function: Used to initialize properties</p>\n<p>Syntax: constructor(): attribute 1 (value 1), attribute 2 (value 2)… {}</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c) :m_A(a), m_B(b), m_C(c) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Class-objects-as-class-members\"><a href=\"#Class-objects-as-class-members\" class=\"headerlink\" title=\"Class objects as class members\"></a>Class objects as class members</h1><p>A member of a C++ class can be an object of another class, and we call the member an object member</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span>&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">A a.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>When a member of a class is an object of another class, we call the member an object member.<br>The order of construction is: first call the construction of the object member, then call the class construction; destructuring order is the opposite of construction</p>\n<p>Static members<br>Static members are member variables and member functions preceded by the keyword static</p>\n<p>Static members are classified as</p>\n<p>Static member variables<br>All objects share the same data<br>Allocation of memory at compilation stage<br>Declared inside the class and initialized outside the class<br>Static member functions<br>All objects share the same function<br>Static member functions can only access static member variables<br>Two types of access.<br>1, through the object</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">p1.func();</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>By class name</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person::func();</span><br></pre></td></tr></table></figure>\n\n<p>C++ object model and this pointer<br>Separate storage of member variables and member functions<br>In C++, member variables and member functions are stored separately within a class</p>\n<p>Only non-static member variables belong on the object of the class</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">Person() &#123;</span><br><span class=\"line\">mA = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Non-static member variables occupy object space</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> mA;</span><br><span class=\"line\"><span class=\"comment\">//Static member variables do not occupy object space</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> mB;</span><br><span class=\"line\"><span class=\"comment\">//functions also do not occupy object space, all functions share a function instance</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"mA:\"</span> &lt;&lt; <span class=\"keyword\">this</span>-&gt;mA &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// static member functions also do not occupy object space</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sfunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"this-pointer\"><a href=\"#this-pointer\" class=\"headerlink\" title=\"this pointer\"></a>this pointer</h1><p>We know that in C++ member variables and member functions are stored separately</p>\n<p>Each non-static member function will only give birth to one instance of the function, which means that multiple objects of the same type will share a single piece of code</p>\n<p>So the question is: How does this piece of code distinguish which object is calling itself?</p>\n<p>c++ solves this problem by providing a special object pointer, the this pointer, which points to the object to which the member function is called.</p>\n<p>this pointer is a kind of pointer that is implicitly included in every non-static member function.</p>\n<p>this pointer does not need to be defined, it can be used directly</p>\n<p>Uses of the this pointer.</p>\n<p>When the form reference and the member variable have the same name, this pointer can be used to distinguish them<br>In the class of non-static member functions to return the object itself, you can use return _this, where this is a pointer to the object, _ is the value operator, *this is the object itself<br>Null pointer access to member functions<br>C++ null pointers can also call member functions, but also pay attention to whether or not to use this pointer</p>\n<p>If this pointer is used, you need to judge the code to ensure the robustness</p>\n<p>const modifies member functions<br>Constants.</p>\n<p>After a member function with const, we call the function a constant function.<br>member properties cannot be modified within a constant function<br>member property declaration with the keyword mutable, in the constant function can still be modified<br>Constant objects.</p>\n<p>The object is called a constant object when const is added before declaring the object<br>constant objects can only call constant functions<br>The nature of this pointer is a pointer constant, the pointer’s pointing is not modifiable, the compiler is equivalent to</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person \\* <span class=\"keyword\">const</span> <span class=\"keyword\">this</span>;</span><br></pre></td></tr></table></figure>\n\n<p>If you want to make the value pointed to by the pointer unmodifiable as well, you need to declare a constant function, which is equivalent to</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Person \\* <span class=\"keyword\">const</span> <span class=\"keyword\">this</span>;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Youyuan\"><a href=\"#Youyuan\" class=\"headerlink\" title=\"Youyuan\"></a>Youyuan</h1><p>In life your home has a living room (Public) and your bedroom (Private)</p>\n<p>The living room is open to all guests, but your bedroom is private, which means only you can enter it.</p>\n<p>However, you can also allow your best friend and best friend to enter.</p>\n<p>In the program, there are some private properties that you want to allow special functions or classes outside the class to access, so you need to use the friend technique.</p>\n<p>The purpose of a friend is to allow a function or class to access a private member of another class.</p>\n<p>The keyword for friend is ==friend==.</p>\n<p>There are three implementaPions of friends</p>\n<p>global function as a friend (so that the global function can access private members of another class)<br>C++<br>// tell the compiler that the goodGay global function is a good friend of the Building class and can access private content in the class, class<br>friend void goodGay(Building * building);<br>class does friend (allows this class to access private members in another class)<br>C++<br>// tell the compiler that the goodGay class is a good friend of the Building class and can access private content in the Building class, class<br>friend class goodGay;<br>member function as a friend (so that this member function can access private members of another class)</p>\n<h1 id=\"Template\"><a href=\"#Template\" class=\"headerlink\" title=\"Template\"></a>Template</h1><p>Template is to create a common mold, greatly improve the reusability</p>\n<p>Function templates<br>Another programming idea in C++ is called ==generic programming== and the main technique used is templating<br>C++ provides two template mechanisms: function templates and class templates<br>Function template syntax<br>Function templates function.</p>\n<p>Create a generic function whose function return value type and formal reference type can be unspecified and represented by a virtual type.</p>\n<p>Syntax.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">Function declaration <span class=\"keyword\">or</span> definition</span><br><span class=\"line\">Explanation.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> - declaration creates a <span class=\"keyword\">template</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typename</span> - the surface followed by a symbol is a data type, which can be replaced by <span class=\"class\"><span class=\"keyword\">class</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">T</span> - <span class=\"title\">generic</span> <span class=\"title\">data</span> <span class=\"title\">type</span>, <span class=\"title\">the</span> <span class=\"title\">name</span> <span class=\"title\">can</span> <span class=\"title\">be</span> <span class=\"title\">replaced</span>, <span class=\"title\">usually</span> <span class=\"title\">in</span> <span class=\"title\">upper</span> <span class=\"title\">case</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">C</span>++</span></span><br><span class=\"line\"><span class=\"class\">// <span class=\"title\">Use</span> <span class=\"title\">templates</span> <span class=\"title\">to</span> <span class=\"title\">provide</span> <span class=\"title\">common</span> <span class=\"title\">interchange</span> <span class=\"title\">functions</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">template</span>&lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">mySwap</span>(<span class=\"title\">T</span>&amp; <span class=\"title\">a</span>, <span class=\"title\">T</span>&amp; <span class=\"title\">b</span>)</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">T temp = a;</span><br><span class=\"line\">a = b;</span><br><span class=\"line\">b = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">C++</span><br><span class=\"line\"><span class=\"comment\">//Implementation of swaps using templates</span></span><br><span class=\"line\"><span class=\"comment\">//1. Automatic type derivation</span></span><br><span class=\"line\">mySwap(a, b);</span><br><span class=\"line\"><span class=\"comment\">//2. Show the specified type</span></span><br><span class=\"line\">mySwap&lt;<span class=\"keyword\">int</span>&gt;(a, b);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><p>指针占用空间：所有指针类型在 32 位操作系统下是 4 个字节</p>\n<p>空指针：指针变量指向内存中编号为 0 的空间，用途：初始化指针变量， 空指针指向的内存是不可以访问的</p>\n<p>野指针：指针变量指向非法的内存空间</p>\n<p>空指针和野指针都不是我们申请的空间，因此不要访问。</p>\n<h1 id=\"const-修饰指针\"><a href=\"#const-修饰指针\" class=\"headerlink\" title=\"const 修饰指针\"></a>const 修饰指针</h1><p>const 修饰指针有三种情况</p>\n<p>const 修饰指针 — 常量指针<br>const 修饰常量 — 指针常量<br>const 即修饰指针，又修饰常量<br>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * p1 = &amp;a;</span><br><span class=\"line\">\tp1 = &amp;b; <span class=\"comment\">//正确</span></span><br><span class=\"line\">\t<span class=\"comment\">//*p1 = 100;  报错</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p2 = &amp;a;</span><br><span class=\"line\">\t<span class=\"comment\">//p2 = &amp;b; //错误</span></span><br><span class=\"line\">\t*p2 = <span class=\"number\">100</span>; <span class=\"comment\">//正确</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//const既修饰指针又修饰常量</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p3 = &amp;a;</span><br><span class=\"line\">\t<span class=\"comment\">//p3 = &amp;b; //错误</span></span><br><span class=\"line\">\t<span class=\"comment\">//*p3 = 100; //错误</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看 const 右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p>\n<h1 id=\"指针和数组\"><a href=\"#指针和数组\" class=\"headerlink\" title=\"指针和数组\"></a>指针和数组</h1><p>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[] = &#123; <span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> * p = arr;  <span class=\"comment\">//指向数组的指针,arr就是数组的首地址，数组名arr就是一个指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"第一个元素： \"</span> &lt;&lt; arr[<span class=\"number\">0</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"指针访问第一个元素： \"</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//利用指针遍历数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\tp++;<span class=\"comment\">//往后偏移4个字节</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当数组名传入到函数作为参数时，被退化为指向首元素的指针</p>\n<p>指针和函数<br>作用：利用指针作函数参数，可以修改实参的值</p>\n<p>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//值传递</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap1</span><span class=\"params\">(<span class=\"keyword\">int</span> a ,<span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//地址传递</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap2</span><span class=\"params\">(<span class=\"keyword\">int</span> * p1, <span class=\"keyword\">int</span> *p2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp = *p1;</span><br><span class=\"line\">\t*p1 = *p2;</span><br><span class=\"line\">\t*p2 = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\">\tswap1(a, b); <span class=\"comment\">// 值传递不会改变实参</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tswap2(&amp;a, &amp;b); <span class=\"comment\">//地址传递会改变实参</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"b = \"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>\n<h1 id=\"内存模型\"><a href=\"#内存模型\" class=\"headerlink\" title=\"内存模型\"></a>内存模型</h1><p>C++程序在执行时，将内存大方向划分为 4 个区域</p>\n<p>代码区：存放函数体的二进制代码，由操作系统进行管理的</p>\n<p>全局区：存放全局变量和静态变量以及常量</p>\n<p>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</p>\n<p>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</p>\n<h1 id=\"程序运行前\"><a href=\"#程序运行前\" class=\"headerlink\" title=\"程序运行前\"></a>程序运行前</h1><p>在程序编译后，生成了 exe 可执行程序，未执行该程序前分为两个区域</p>\n<p>代码区：</p>\n<p>存放 CPU 执行的机器指令</p>\n<p>代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>\n<p>代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令</p>\n<p>全局区：</p>\n<p>全局变量和静态变量存放在此.</p>\n<p>全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>\n<p>==该区域的数据在程序结束后由操作系统释放==.</p>\n<p>总结：</p>\n<p>C++中在程序运行前分为全局区和代码区<br>代码区特点是共享和只读<br>全局区中存放全局变量、静态变量、常量<br>常量区中存放 const 修饰的全局常量 和 字符串常量<br>const 修饰的局部常量在栈中</p>\n<h1 id=\"程序运行后\"><a href=\"#程序运行后\" class=\"headerlink\" title=\"程序运行后\"></a>程序运行后</h1><p>栈区：</p>\n<p>由编译器自动分配释放, 存放函数的参数值,局部变量等</p>\n<p>注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>\n<p>堆区：</p>\n<p>由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>\n<p>在 C++中主要利用 new 在堆区开辟内存</p>\n<p>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;<span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">10</span>);  <span class=\"comment\">//指针a指向的是new出来的对象的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;  <span class=\"comment\">//即使函数（在栈中）的空间被回收，依然返回了new出来的对象的地址</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = func();  <span class=\"comment\">//指针p指向new出来的对象的地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：</p>\n<p>堆区数据由程序员管理开辟和释放</p>\n<p>堆区数据利用 new 关键字进行开辟内存</p>\n<h1 id=\"new-操作符\"><a href=\"#new-操作符\" class=\"headerlink\" title=\"new 操作符\"></a>new 操作符</h1><p>C++中利用==new==操作符在堆区开辟数据</p>\n<p>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p>\n<p>语法：new 数据类型</p>\n<p>利用 new 创建的数据，会返回该数据对应的类型的指针</p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><p>基本使用<br>*作用： *给变量起别名</p>\n<p>语法： 数据类型 &amp;别名 = 原名</p>\n<p>注意事项<br>引用必须初始化<br>引用在初始化后，不可以改变<br>本质<br>本质：引用的本质在 c++内部实现是一个指针常量.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">/发现是引用，转换为 <span class=\"keyword\">int</span>* <span class=\"keyword\">const</span> ref = &amp;a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; ref)</span></span>&#123;</span><br><span class=\"line\">ref = <span class=\"number\">100</span>; <span class=\"comment\">// ref 是引用，转换为*ref = 100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>&amp; ref = a;</span><br><span class=\"line\">    ref = <span class=\"number\">20</span>; <span class=\"comment\">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a:\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ref:\"</span> &lt;&lt; ref &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    func(a);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>\n<h1 id=\"常量引用\"><a href=\"#常量引用\" class=\"headerlink\" title=\"常量引用\"></a>常量引用</h1><p>作用：常量引用主要用来修饰形参，防止误操作</p>\n<p>在函数形参列表中，可以加==const 修饰形参==，防止形参改变实参</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引用使用的场景，通常用来修饰形参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showValue</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; v)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//v += 10;</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; v &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class=\"line\">    <span class=\"comment\">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; ref = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ref &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//函数中利用常量引用防止误操作修改实参</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    showValue(a);</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"函数提高\"><a href=\"#函数提高\" class=\"headerlink\" title=\"函数提高\"></a>函数提高</h1><p>函数默认参数<br>在 C++中，函数的形参列表中的形参是可以有默认值的。</p>\n<p>语法：返回值类型 函数名 （参数= 默认值）{}</p>\n<p>注意事项:</p>\n<p>如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</p>\n<p>如果函数声明有默认值，函数实现的时候就不能有默认参数</p>\n<p>区分函数声明，函数实现，函数调用</p>\n<p>函数占位参数<br>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>\n<p>语法： 返回值类型 函数名 (数据类型){}</p>\n<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span>)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"this is func\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h1><p>作用：函数名可以相同，提高复用性</p>\n<p>函数重载满足条件：</p>\n<p>同一个作用域下<br>函数名称相同<br>函数参数类型不同 或者 个数不同 或者 顺序不同</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数重载注意事项</span></span><br><span class=\"line\"><span class=\"comment\">//1、引用作为重载条件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"func (int &amp;a) 调用 \"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"func (const int &amp;a) 调用 \"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2、函数重载碰到函数默认参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b = <span class=\"number\">10</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"func2(int a, int b = 10) 调用\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"func2(int a) 调用\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">func(a); <span class=\"comment\">//调用无 const</span></span><br><span class=\"line\">func(<span class=\"number\">10</span>);<span class=\"comment\">//调用有 const</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a>类和对象</h1><p>封装<br>struct 和 class 区别<br>在 C++中 struct 和 class 唯一的区别就在于 默认的访问权限不同</p>\n<p>区别：</p>\n<p>struct 默认权限为公共<br>class 默认权限为私有<br>对象的初始化和清理<br>构造函数和析构函数<br>构造函数语法：类名(){}</p>\n<p>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</p>\n<p>析构函数语法： ~类名(){}</p>\n<p>构造函数调用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、构造函数分类</span></span><br><span class=\"line\"><span class=\"comment\">// 按照参数分类分为 有参和无参构造 无参又称为默认构造函数</span></span><br><span class=\"line\"><span class=\"comment\">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"comment\">//无参（默认）构造函数</span></span><br><span class=\"line\">Person() &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"无参构造函数!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">Person(<span class=\"keyword\">int</span> a) &#123;</span><br><span class=\"line\">age = a;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"有参构造函数!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">Person(<span class=\"keyword\">const</span> Person&amp; p) &#123;</span><br><span class=\"line\">age = p.age;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"拷贝构造函数!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//析构函数</span></span><br><span class=\"line\">~Person() &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"析构函数!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2、构造函数的调用</span></span><br><span class=\"line\"><span class=\"comment\">//调用无参构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">Person p; <span class=\"comment\">//调用无参构造函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用有参的构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2.1  括号法，常用</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class=\"line\">    <span class=\"comment\">//Person p2();</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2.2 显式法</span></span><br><span class=\"line\">    Person p2 = Person(<span class=\"number\">10</span>);</span><br><span class=\"line\">    Person p3 = Person(p2);</span><br><span class=\"line\">    <span class=\"comment\">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2.3 隐式转换法</span></span><br><span class=\"line\">    Person p4 = <span class=\"number\">10</span>; <span class=\"comment\">// Person p4 = Person(10);</span></span><br><span class=\"line\">    Person p5 = p4; <span class=\"comment\">// Person p5 = Person(p4);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class=\"line\">    <span class=\"comment\">//Person p5(p4);</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    test01();</span><br><span class=\"line\">    <span class=\"comment\">//test02();</span></span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"拷贝构造函数调用时机\"><a href=\"#拷贝构造函数调用时机\" class=\"headerlink\" title=\"拷贝构造函数调用时机\"></a>拷贝构造函数调用时机</h1><p>C++中拷贝构造函数调用时机通常有三种情况</p>\n<p>使用一个已经创建完毕的对象来初始化一个新对象<br>值传递的方式给函数参数传值(作为函数参数)<br>以值方式返回局部对象(作为函数返回值)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">Person() &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"无参构造函数!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">mAge = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person(<span class=\"keyword\">int</span> age) &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"有参构造函数!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">mAge = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person(<span class=\"keyword\">const</span> Person&amp; p) &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"拷贝构造函数!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">mAge = p.mAge;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//析构函数在释放内存之前调用</span></span><br><span class=\"line\">~Person() &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"析构函数!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"keyword\">int</span> mAge;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">man</span><span class=\"params\">(<span class=\"number\">100</span>)</span></span>; <span class=\"comment\">//p对象已经创建完毕</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">newman</span><span class=\"params\">(man)</span></span>; <span class=\"comment\">//调用拷贝构造函数</span></span><br><span class=\"line\">    Person newman2 = man; <span class=\"comment\">//拷贝构造</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Person newman3;</span></span><br><span class=\"line\">    <span class=\"comment\">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2. 值传递的方式给函数参数传值</span></span><br><span class=\"line\"><span class=\"comment\">//相当于 Person p1 = p;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doWork</span><span class=\"params\">(Person p1)</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">Person p; <span class=\"comment\">//无参构造函数</span></span><br><span class=\"line\">doWork(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3. 以值方式返回局部对象</span></span><br><span class=\"line\"><span class=\"function\">Person <span class=\"title\">doWork2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">Person p1;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; (<span class=\"keyword\">int</span> \\*)&amp;p1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> p1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test03</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">Person p = doWork2();</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; (<span class=\"keyword\">int</span> \\*)&amp;p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//test01();</span></span><br><span class=\"line\">    <span class=\"comment\">//test02();</span></span><br><span class=\"line\">    test03();</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>构造函数调用规则<br>默认情况下，c++编译器至少给一个类添加 3 个函数</p>\n<p>1．默认构造函数(无参，函数体为空)</p>\n<p>2．默认析构函数(无参，函数体为空)</p>\n<p>3．默认拷贝构造函数，对属性进行值拷贝</p>\n<p>构造函数调用规则如下：</p>\n<p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造<br>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p>\n<h1 id=\"深拷贝与浅拷贝\"><a href=\"#深拷贝与浅拷贝\" class=\"headerlink\" title=\"深拷贝与浅拷贝\"></a>深拷贝与浅拷贝</h1><p>浅拷贝：简单的赋值拷贝操作</p>\n<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>\n<p>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"comment\">//无参（默认）构造函数</span></span><br><span class=\"line\">Person() &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"无参构造函数!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">Person(<span class=\"keyword\">int</span> age ,<span class=\"keyword\">int</span> <span class=\"built_in\">height</span>) &#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"有参构造函数!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    \tm_age = age;</span><br><span class=\"line\">    \tm_height = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"built_in\">height</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">    Person(<span class=\"keyword\">const</span> Person&amp; p) &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"拷贝构造函数!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    \t<span class=\"comment\">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class=\"line\">    \tm_age = p.m_age;</span><br><span class=\"line\">    \tm_height = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(*p.m_height);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"析构函数!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (m_height != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">delete</span> m_height;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"keyword\">int</span> m_age;</span><br><span class=\"line\"><span class=\"keyword\">int</span>\\* m_height;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">18</span>, <span class=\"number\">180</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(p1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"p1的年龄： \"</span> &lt;&lt; p1.m_age &lt;&lt; <span class=\"string\">\" 身高： \"</span> &lt;&lt; *p1.m_height &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"p2的年龄： \"</span> &lt;&lt; p2.m_age &lt;&lt; <span class=\"string\">\" 身高： \"</span> &lt;&lt; *p2.m_height &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    test01();</span><br><span class=\"line\"></span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"初始化列表\"><a href=\"#初始化列表\" class=\"headerlink\" title=\"初始化列表\"></a>初始化列表</h1><p>作用：用来初始化属性</p>\n<p>语法：构造函数()：属性 1(值 1),属性 2（值 2）… {}</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c) :m_A(a), m_B(b), m_C(c) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"类对象作为类成员\"><a href=\"#类对象作为类成员\" class=\"headerlink\" title=\"类对象作为类成员\"></a>类对象作为类成员</h1><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span>&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">A a；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当类中成员是其他类对象时，我们称该成员为 对象成员<br>构造的顺序是 ：先调用对象成员的构造，再调用本类构造；析构顺序与构造相反</p>\n<p>静态成员<br>静态成员就是在成员变量和成员函数前加上关键字 static</p>\n<p>静态成员分为：</p>\n<p>静态成员变量<br>所有对象共享同一份数据<br>在编译阶段分配内存<br>类内声明，类外初始化<br>静态成员函数<br>所有对象共享同一个函数<br>静态成员函数只能访问静态成员变量<br>两种访问方式：<br>1、通过对象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">p1.func();</span><br></pre></td></tr></table></figure>\n\n<p>2、通过类名</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person::func();</span><br></pre></td></tr></table></figure>\n\n<p>C++对象模型和 this 指针<br>成员变量和成员函数分开存储<br>在 C++中，类内的成员变量和成员函数分开存储</p>\n<p>只有非静态成员变量才属于类的对象上</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">Person() &#123;</span><br><span class=\"line\">mA = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//非静态成员变量占对象空间</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> mA;</span><br><span class=\"line\"><span class=\"comment\">//静态成员变量不占对象空间</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> mB;</span><br><span class=\"line\"><span class=\"comment\">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"mA:\"</span> &lt;&lt; <span class=\"keyword\">this</span>-&gt;mA &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//静态成员函数也不占对象空间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sfunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"this-指针\"><a href=\"#this-指针\" class=\"headerlink\" title=\"this 指针\"></a>this 指针</h1><p>我们知道在 C++中成员变量和成员函数是分开存储的</p>\n<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>\n<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>\n<p>c++通过提供特殊的对象指针，this 指针，解决上述问题。this 指针指向被调用的成员函数所属的对象</p>\n<p>this 指针是隐含每一个非静态成员函数内的一种指针</p>\n<p>this 指针不需要定义，直接使用即可</p>\n<p>this 指针的用途：</p>\n<p>当形参和成员变量同名时，可用 this 指针来区分<br>在类的非静态成员函数中返回对象本身，可使用 return <em>this，这里 this 是指向本对象的指针，</em>是取值运算符，*this 是本对象本身<br>空指针访问成员函数<br>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针</p>\n<p>如果用到 this 指针，需要加以判断保证代码的健壮性</p>\n<p>const 修饰成员函数<br>常函数：</p>\n<p>成员函数后加 const 后我们称为这个函数为常函数<br>常函数内不可以修改成员属性<br>成员属性声明时加关键字 mutable 后，在常函数中依然可以修改<br>常对象：</p>\n<p>声明对象前加 const 称该对象为常对象<br>常对象只能调用常函数<br>​ this 指针的本质是一个指针常量，指针的指向不可修改，编译器中相当于</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person \\* <span class=\"keyword\">const</span> <span class=\"keyword\">this</span>;</span><br></pre></td></tr></table></figure>\n\n<p>​ 如果想让指针指向的值也不可以修改，需要声明常函数，编译器中相当于</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Person \\* <span class=\"keyword\">const</span> <span class=\"keyword\">this</span>;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"友元\"><a href=\"#友元\" class=\"headerlink\" title=\"友元\"></a>友元</h1><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>\n<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>\n<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>\n<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>\n<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>\n<p>友元的关键字为 ==friend==</p>\n<p>友元的三种实现</p>\n<p>全局函数做友元（让这个全局函数可以访问另一个类中私有成员）<br>C++<br>//告诉编译器 goodGay 全局函数 是 Building 类的好朋友，可以访问类中的私有内容，class 中<br>friend void goodGay(Building * building);<br>类做友元（让这个类可以访问另一个类中私有成员）<br>C++<br>//告诉编译器 goodGay 类是 Building 类的好朋友，可以访问到 Building 类中私有内容，class 中<br>friend class goodGay;<br>成员函数做友元（让这个成员函数可以访问另一个类中私有成员）</p>\n<h1 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h1><p>模板就是建立通用的模具，大大提高复用性</p>\n<p>函数模板<br>C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板<br>C++提供两种模板机制:函数模板和类模板<br>函数模板语法<br>函数模板作用：</p>\n<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。</p>\n<p>语法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">函数声明或定义</span><br><span class=\"line\">解释：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> — 声明创建模板</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typename</span> — 表面其后面的符号是一种数据类型，可以用 <span class=\"class\"><span class=\"keyword\">class</span> 代替</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">T</span> — 通用的数据类型，名称可以替换，通常为大写字母</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">C</span>++</span></span><br><span class=\"line\"><span class=\"class\">//利用模板提供通用的交换函数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">template</span>&lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">mySwap</span>(<span class=\"title\">T</span>&amp; <span class=\"title\">a</span>, <span class=\"title\">T</span>&amp; <span class=\"title\">b</span>)</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">T temp = a;</span><br><span class=\"line\">a = b;</span><br><span class=\"line\">b = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">C++</span><br><span class=\"line\"><span class=\"comment\">//利用模板实现交换</span></span><br><span class=\"line\"><span class=\"comment\">//1、自动类型推导</span></span><br><span class=\"line\">mySwap(a, b);</span><br><span class=\"line\"><span class=\"comment\">//2、显示指定类型</span></span><br><span class=\"line\">mySwap&lt;<span class=\"keyword\">int</span>&gt;(a, b);</span><br></pre></td></tr></table></figure>\n"},{"title":"Quick Sort Questions","url":"/2023/01/18/Quick%20Sort%20Questions/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><ol start=\"912\">\n<li>快速排序<br>虽然大家都能默写出快速排序, 但是这几个问题是我在今天一个等于符号错误的时候引申出来的, 记录一下, 本文现讲正确性, 再谈优化</li>\n</ol>\n<p>为什么一定要先从右边开始?? 能不能先从左边开始?<br>其实不一定要先从右边开始, 当你要升序排序的时候, 从右边开始, 反之亦然</p>\n<p>从右边开始是因为要保证 left 指向的值在退出循环时永远小于等于 pivot, 保证随后的中枢值归位 swap(nums, pivot_index, left);的正确性.</p>\n<p>正确性<br>partition 判断时的等号,什么时候取,为什么?<br>先别往下看, 可以试着猜想下</p>\n<p>image.png<br>image.png</p>\n<p>image.png<br>image.png</p>\n<p>image.png<br>image.png</p>\n<p>image.png<br>image.png</p>\n<p>这个问题我在没有 debug 之前想了很久, 后来发现, 其实简单地在 nums[low] 和 pivot 作判断的那一行打上断点, 就能轻松解决.</p>\n<p>错误的:<br>image.png<br>image.png</p>\n<p>我们发现, 如果判断条件是 nums[low] &lt; pivot 的话, 这个条件其实永远不会满足, 因为 low 初始时指向的是 pivot, 也就是 nums[low] = pivot 成立, 自己和自己比较, 自己当然不会比自己小, 所以 nums[low] &lt; pivot 的写法是错误的!!!</p>\n<p>有的同学可能会说, 如果是因为自身和自身比较的话, 那我先把 left++是不是就是可以了呢? 其实这样更是大错特错, 因为把 partition 的区间无缘由地缩小了 1, 抛弃了最左边的元素.</p>\n<p>设想这样的情形, 原数组是有序的, 即选取了最小的数作为 pivot, 如果 left++后, 退出循环时 left 为最小的数右边, 最后还要进行交换 swap(nums, pivot_index, left);, 直接把最小的数换到第二位去了, 更是不可取.</p>\n<p>关于 nums[high] 和 pivot 作比较的情况, leetcode 提交验证显示都能通过, 我们可以这样想, 如果 nums[high] 和 pivot 作比较时加了=号, 即 while (left &lt; right &amp;&amp; nums[right] &gt; pivot), 那么等于 pivot 的元素分布于 partition 操作的两端, 否则只会出现在左半部分.</p>\n<p>按照语义来讲, 应该采用的是:</p>\n<p>Java<br>public int partition(int[] nums, int left, int right) {<br>int pivot_index = left;<br>int pivot = nums[pivot_index];<br>while (left &lt; right) {<br>while (left &lt; right &amp;&amp; nums[right] &gt; pivot)<br>right–;<br>while (left &lt; right &amp;&amp; nums[left] &lt;= pivot)<br>left++;<br>if (left &lt; right)<br>swap(nums, left, right);<br>}<br>swap(nums, pivot_index, left);<br>return left;<br>}<br>partition 策略? 快慢指针, 左右指针?<br>左右指针就是上面那四个图的做法, 其实还有一种做法, 是快慢指针, 如下</p>\n<p>Java<br>public int partition(int[] nums, int left, int right) {<br>int pivot = nums[left];<br>int smaller_tail_index = left;<br>for (int i = left + 1; i &lt;= right; i++) {<br>if (nums[i] &lt; pivot) {<br>smaller_tail_index++;<br>swap(nums, smaller_tail_index, i);<br>}<br>}<br>swap(nums, smaller_tail_index, left);<br>return smaller_tail_index;<br>}<br>Time / Spcace Complexity<br>复杂度分析：</p>\n<p>时间复杂度：O(NlogN)，这里 N 是数组的长度, 最坏情况下为 O(N^2)<br>空间复杂度：O(logN)，这里占用的空间来自递归函数的栈空间<br>什么时候最坏?</p>\n<p>每次 partition 操作都导致左右分割极不均衡, 递归树的深度由 O(logN)变为链表的 O(N)</p>\n<p>之后优化也就是在递归树上做文章</p>\n<p>优化<br>partition_random 的优化? random 函数?<br>使用 random()函数来进行优化非常简单, 只需要随机选一个数, 和最左边的元素交换位置即可, 之后进入正常的 partition 操作</p>\n<p>Java<br>public int partition_random(int[] nums, int left, int right) {<br>int random_index = new Random().nextInt(right - left + 1) + left;<br>swap(nums, random_index, left);<br>return partition(nums, left, right);<br>}<br>partition_random? 三数取和?<br>有了随机选取, 为什么还要 三数取和?</p>\n<p>虽然随机选取枢轴时，减少出现不好分割的几率，但是还是最坏情况下还是 O(n^2），要缓解这种情况，就引入了三数取中选取枢轴, 它每次选取的一定不会是最坏的情况, 反而每次都是最好的情况</p>\n<p>可以这么理解, 三个数, 排序</p>\n<p>首先排序最右边两个数, middle 和 right, 选出大的, 放到最右边<br>然后, 我们排序一个数 left 和右边两个数, 因为右边两个数中较大者已经在末尾了, 所以我们比较 left 和 right 即可<br>最后, 我们把三个数中中间的那个数放到最开头 left 的位置. 因为此时三个数中最大的数已经放到 right 位置上了, left 和 middle 中较大的数既是三个数中中间大的数, 我们比较 left 和 middle 即可<br>Java<br>public int partition_random(int[] nums, int left, int right) {<br>int middle = left + (right - left) &gt;&gt; 1;<br>if (nums[middle] &gt; nums[right]) swap(nums, middle, right);<br>if (nums[left] &gt; nums[right]) swap(nums, left, right);<br>if (nums[middle] &gt; nums[left]) swap(nums, left, middle);<br>return partition(nums, left, right);<br>}<br>使用三数取中选择枢轴优势还是很明显的，但是还是处理不了重复数组</p>\n<p>优化相同的数, 放到数组的中间, 之后递归时直接不需要再次参与递归<br>此代码纯原创, 跑过了 leetcode, 还是很开心的呀 hhh!</p>\n<p>思路如下:</p>\n<p>使用 same_as_pivot_num 记录和 pivot 相同的数的个数, 并把相同的数都放到数组左边</p>\n<p>把和 pivot 相同的数(位于数组的左边)交换到和 pivot 相邻的左边</p>\n<p>然后使用数组, 把和 pivot 相同的数的个数 same_as_pivot_num 和 pivot 都传参传递出去</p>\n<p>向左边递归时即可跳过相同的元素!!!</p>\n<p>有注释, 基于之前的代码结构改变, 看懂前面的看这个小 case</p>\n<p>Java<br>public void quickSort(int[] nums, int start, int end) {<br>if (end &lt;= start) {<br>return;<br>}<br>int partition[] = partition(nums, start, end);<br>int partition_index = partition[0];<br>int same_as_pivot_num = partition[1];<br>quickSort(nums, start, partition_index - same_as_pivot_num - 1);<br>quickSort(nums, partition_index + 1, end);<br>}</p>\n<pre><code>public int[] partition(int[] nums, int left, int right) {\n    int pivot_index = left;\n    int pivot = nums[pivot_index];\n    int same_as_pivot_num = 0;\n    while (left &lt; right) {\n        while (left &lt; right &amp;&amp; nums[right] &gt; pivot)\n            right--;\n        while (left &lt; right &amp;&amp; nums[left] &lt;= pivot)\n            left++;\n        if (left &lt; right) {\n            swap(nums, left, right);\n            // 注意这里left和right已经交换了, 且交换前只有left有可能==pivot, 所以现在只需要判断right就行, 并把他们放到数组刚开始的位置\n            if (nums[right] == pivot)\n                swap(nums, left + 1 + same_as_pivot_num++, left);\n        }\n    }\n    swap(nums, pivot_index, left);\n    for (int i = 0; i &lt; same_as_pivot_num; i++) {\n        swap(nums, left + i, pivot_index - 1 - i);\n    }\n    return new int[]{left, same_as_pivot_num};\n}</code></pre><p>更多优化措施<br>设置阈值, 结合插入排序<br>疑似尾递归优化???查了资料, 发现并不是严格的尾递归优化策略, 这点存疑, 请大佬解答</p>\n"},{"title":"Python爬虫实战（二）教务处首页","url":"/2020/08/15/Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%99%E5%8A%A1%E5%A4%84%E9%A6%96%E9%A1%B5/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h1><p>爬取四川大学教务处首页的通知，并邮件推送</p>\n<p>github链接：<a href=\"https://github.com/ZhengLin-Li/leaning-spider-scu-jwc\" target=\"_blank\" rel=\"noopener\">https://github.com/ZhengLin-Li/leaning-spider-scu-jwc</a></p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><h2 id=\"一、crawl-py\"><a href=\"#一、crawl-py\" class=\"headerlink\" title=\"一、crawl.py\"></a>一、crawl.py</h2><ol>\n<li>利用<code>requests</code>库,拿到页面的response对象</li>\n<li>利用<code>BeautifulSoup</code>库解析拿到的文档树</li>\n<li>把数据文件保存进<code>data.txt</code>文件中</li>\n</ol>\n<h2 id=\"二、send-email-py\"><a href=\"#二、send-email-py\" class=\"headerlink\" title=\"二、send_email.py\"></a>二、send_email.py</h2><ol>\n<li>引入<code>SMTP</code>,<code>Header</code>,<code>MIMEText</code>库</li>\n<li>利用固定格式发送电子邮件</li>\n</ol>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import requests</span><br><span class=\"line\">from bs4 import BeautifulSoup</span><br><span class=\"line\"></span><br><span class=\"line\">response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;jwc.scu.edu.cn&#x2F;&#39;)</span><br><span class=\"line\">page &#x3D; response.content.decode()</span><br><span class=\"line\"># print(page)</span><br><span class=\"line\"></span><br><span class=\"line\">soup &#x3D; BeautifulSoup(page, &#39;lxml&#39;)</span><br><span class=\"line\">tag &#x3D; soup.find_all(class_&#x3D;&#39;list-llb-list&#39;)</span><br><span class=\"line\"># print(tag)</span><br><span class=\"line\"></span><br><span class=\"line\">result &#x3D; &#39;&#39;</span><br><span class=\"line\">for each in tag:</span><br><span class=\"line\">    result +&#x3D; each.text</span><br><span class=\"line\"># print(result)</span><br><span class=\"line\"></span><br><span class=\"line\">with open(&#39;data.txt&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf8&#39;) as fp:</span><br><span class=\"line\">    for each in tag:</span><br><span class=\"line\">        text &#x3D; each.text</span><br><span class=\"line\">        fp.write(text)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">from smtplib import SMTP</span><br><span class=\"line\">from email.header import Header</span><br><span class=\"line\">from email.mime.text import MIMEText</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def main():</span><br><span class=\"line\">    # 请自行修改下面的邮件发送者和接收者</span><br><span class=\"line\">    sender &#x3D; &#39;xxxxxxxxx@qq.com&#39;  # 发送者的邮箱地址</span><br><span class=\"line\">    receivers &#x3D; [&#39;xxxxxxxxxx@qq.com&#39;]  # 接收者的邮箱地址</span><br><span class=\"line\">    message &#x3D; MIMEText(open(&#39;data.txt&#39;).read(), _subtype&#x3D;&#39;plain&#39;, _charset&#x3D;&#39;utf-8&#39;)</span><br><span class=\"line\">    message[&#39;From&#39;] &#x3D; Header(&#39;Your Old Friend&#39;, &#39;utf-8&#39;)  # 邮件的发送者</span><br><span class=\"line\">    message[&#39;To&#39;] &#x3D; Header(&#39;Darling Jay&#39;, &#39;utf-8&#39;)   # 邮件的接收者</span><br><span class=\"line\">    message[&#39;Subject&#39;] &#x3D; Header(&#39;To darling Jay&#39;, &#39;utf-8&#39;) # 邮件的标题</span><br><span class=\"line\">    smtper &#x3D; SMTP(&#39;smtp.qq.com&#39;)</span><br><span class=\"line\">    # 请自行修改下面的登录口令</span><br><span class=\"line\"></span><br><span class=\"line\">    smtper.login(sender, &#39;xxxxxxxxxxxxxxxx&#39;)  # QQ邮箱smtp的授权码</span><br><span class=\"line\">    smtper.sendmail(sender, receivers, message.as_string())</span><br><span class=\"line\">    print(&#39;邮件发送完成!&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n","categories":["Python爬虫"],"tags":["Python","爬虫","实战"]},{"title":"TIME_WAIT optimization","url":"/2023/01/18/TIME_WAIT%20optimization/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>TIME_WAIT<br>我们知道，tcp 在关闭连接的时候主动关闭方在最后一个 ack 报文之后还需要等 2MSL 才能关闭连接。</p>\n<p>原因：</p>\n<p>确保被动关闭方的正常关闭。在没有 TIME_WAIT 或者 TIME_WAIT 过短的情况下，如果最后一个 ack 报文在网络中丢失，被动关闭方可能永远也关闭不了这个 tcp 连接，但是有了 TIME_WAIT 状态之后，如果被动关闭方发送 fin 报文的 timeout 之后仍然没有收到 ack，就会重传 fin 报文，此时主动关闭方因为还处于 TIME_WAIT 状态，还没有关闭连接，所以可以回应 ack 报文。<br>确保本次连接的所有网络包都消失在网络中，防止对之后的有着相同四元组的连接造成干扰。如果本次连接关闭后，又有新建立的具有相同四元组的 tcp 连接，tcp/ip 协议栈是区分不了哪一个报文属于老连接哪一个报文属于新连接的，2MSL 足以保证网络中的所有老报文自然在网络中消失。<br>MSL<br>MSL, max segment lifetime, 最大报文生存时间</p>\n<p>TTL，time to live，记录着该本文还能经过多少跳的路由，每经过一条路由，TTL 就会减一，如果为 0，则被抛弃</p>\n<p>为什么 TIME_WAIT 是 2MSL？<br>这其实是一个经验之谈，也有不是 2MSL 的实现，例如 RFC 规定的 MSL 是 2mins，但是 linux 实现是 30seconds</p>\n<p>也就是说，linux 的 TIME_WAIT 默认是 1min</p>\n<p>TIME_WAIT 过长的问题<br>维持这一个连接占用端口<br>维持这一个连接占用资源<br>跳过 TIME_WAIT<br>linux 下有两种方式跳过 TIME_WAIT</p>\n<p>net.ipv4.tcp_tw_reuse（连接发起方在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用）<br>net.ipv4.tcp_tw_recycle（允许处于 TIME_WAIT 状态的连接被快速回收）<br>这两个参数默认都是关闭的，启动这两个参数需要先启用 net.ipv4.tcp_timestamps</p>\n<p>net.ipv4.tcp_timestamps 和 PAWS 机制<br>tcp_timestamps 选项开启之后， PAWS 机制会自动开启，</p>\n<p>目的：防止 TCP 包中的序列号发生绕回</p>\n<p>方法：开启 tcp 报文首部的时间戳选项，有 2 个用处：</p>\n<p>精确计算 RTT<br>防止序列号回绕（PAWS）（序列号，32bits，如果到达 4G 是就会从 0 开始，有点循环队列的感觉）<br>net.ipv4.tcp_tw_reuse 的问题<br>被动关闭方在最后一个 ack 丢失的情况下不能正确关闭<br>PAWS 不会阻止过期的 RST 报文，也就是说新的连接可能被老连接的延迟的 RST 报文干扰（历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃）<br>只适用于连接发起方， 连接发起方在调用 connect() 函数时，内核会随机找一个 TIME_WAIT 状态超过 1 秒的连接给新的连接复用<br>net.ipv4.tcp_tw_recycle 的问题<br>被动关闭方在最后一个 ack 丢失的情况下不能正确关闭<br>如果同时开启了 recycle 和 timestamps 选项，则会开启一种称之为「 per-host 的 PAWS 机制」，客户端在 NAT 的情况下，SYN 包可能被丢弃（因为多个客户端在 NAT 下发送的 tcp 包具有相同的 ip 地址，但是 tcp_timestamps 却不是递增的，因为他们来自不同的客户端，服务端会丢弃不是递增的 tcp 包）<br>在 Linux 4.12 版本后，直接取消了 tcp_tw_recycle 这一参数。</p>\n"},{"title":"Sorting Algorithm","url":"/2023/01/18/Sorting%20Algorithm/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>昨天 mock interview 被问到了排序，说一种最熟悉的排序算法，说了快排，感觉答的不好，今天来复盘一下。</p>\n<p>点击我的 leetcode 主页跳转：<a href=\"https://leetcode-cn.com/u/zhenglin_li/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/u/zhenglin_li/</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20eae80fc8ad46ff9d36cb5cce706cec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGFuZGEzMjU=,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/ce3e7c3dfb1d4e0f90e90e66081eb3a5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGFuZGEzMjU=,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/2bcc24bdee0c4e938984626a3d47ad90.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGFuZGEzMjU=,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"\"></p>\n<p>问：排序算法分哪几种？<br>答：外排序和内排序<br>复盘：感觉他想问的是分为</p>\n<p>1、基于插入的排序 ：直接插入排序 、希尔排序</p>\n<p>2、基于交换到排序 ：冒泡排序 、快速排序</p>\n<p>3、基于选择的排序 ：简单选择排序、堆排序</p>\n<p>问：知道哪几种？<br>在这里插入图片描述<br>在这里插入图片描述</p>\n<p>冒泡排序<br>一句话总结：每次比较相邻的两个元素，逆序则交换，每一轮结束后最大的元素就会被换到结尾</p>\n<p>优化 1，除了第一轮之后的每一轮的比较不用到尾，且每轮比较的次数越来越少</p>\n<p>优化 2，记录每一趟是否交换过，如没有交换过，说明已经有序，提前返回</p>\n<p>复杂度：最好 O（n），如果有序，没有交换过，一趟遍历即返回，平均 O（n^2）</p>\n<p>Java<br>for (int i = 1; i &lt; arr.length; i++) {<br> // 设定一个标记，若为 true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。<br> boolean flag = true;  </p>\n<p>for (int j = 0; j &lt; arr.length - i; j++) {<br> if (arr[j] &gt; arr[j + 1]) {<br> int tmp = arr[j];<br> arr[j] = arr[j + 1];<br> arr[j + 1] = tmp;  </p>\n<p>flag = false;<br> }<br> }  </p>\n<p>if (flag) {<br> break;<br> }<br>}<br>选择排序<br>一句话总结：每一轮是选择剩下的最小的，与第一个交换就行<br>复杂度最好最坏都是 O（n^2），无论如何每一轮都要遍历来选择剩下的最小的</p>\n<p>算法思想 1：贪心算法：每一次决策只看当前，当前最优，则全局最优。注意：这种思想不是任何时候都适用。</p>\n<p>算法思想 2：减治思想：外层循环每一次都能排定一个元素，问题的规模逐渐减少，直到全部解决，即「大而化小，小而化了」。运用「减治思想」很典型的算法就是大名鼎鼎的「二分查找」。</p>\n<p>优点：交换次数最少。如果在交换成本较高的排序任务中，就可以使用「选择排序」（《算法 4》相关章节课后练习题）</p>\n<p>Java<br>// 总共要经过 N-1 轮比较<br>for (int i = 0; i &lt; arr.length - 1; i++) {<br> int min = i;</p>\n<p>// 每轮需要比较的次数 N-i<br> for (int j = i + 1; j &lt; arr.length; j++) {<br> if (arr[j] &lt; arr[min]) {<br> // 记录目前能找到的最小值元素的下标<br> min = j;<br> }<br> }</p>\n<pre><code>// 将找到的最小值和i位置所在的值进行交换</code></pre><p>if (i != min) {<br> int tmp = arr[i];<br> arr[i] = arr[min];<br> arr[min] = tmp;<br> }<br>插入排序<br>一句话总结：对于每一个元素 a，他之前的元素依次后移一位，直到 a 在合适的位置上</p>\n<p>特点：「插入排序」在「几乎有序」的数组上表现良好。在数组「几乎有序」的前提下，「插入排序」可以提前终止内层循环；「短数组」的特点是：每个元素离它最终排定的位置都不会太远</p>\n<p>最好复杂度：O（n），如果有序，每一个元素只需要和前一位元素比较</p>\n<p>Java<br>for (int i = 1; i &lt; arr.length; i++) {</p>\n<p>// 记录要插入的数据 a<br>int tmp = arr[i];</p>\n<p>// 从已经排序的序列最右边的开始比较，找到比其小的数<br> int j = i;<br> while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) {<br> arr[j] = arr[j - 1];<br> j–;<br> }</p>\n<p>// 存在比其小的数，插入<br> if (j != i) {<br> arr[j] = tmp;<br> }<br> }<br>希尔排序<br>一句话总结：分治思想在简单插入排序上的应用，原序列分组为很多子序列，不断减少步长，直到为 1</p>\n<p>Java<br>int length = arr.length;<br>int temp;<br>// 步长为 step，结束标志为 step==1，每次缩短为原来的一半<br>for (int step = length / 2; step &gt;= 1; step /= 2) {<br> for (int i = step; i &lt; length; i++) {<br> temp = arr[i];<br> int j = i - step;<br> while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) {<br> arr[j + step] = arr[j];<br> j -= step;<br> }<br> arr[j + step] = temp;<br> }<br>}<br>归并排序<br>「归并排序」有「原地 + 迭代」和「借助额外空间 + 递归」，也即「自底向上」和「自顶向下」</p>\n<p>自底向上「借助额外空间 + 递归」</p>\n<p>自顶向下的归并排序进行的操作主要就是对数组的拆分与合并。通过层层拆分得到单元素数组，天生有序，然后归并两个单元素数组得到一个较大的有序数组，接着再归并两个较大数组得到更大的一个有序数组，重复这个过程，最终归并便得到了一个排好序的数组。</p>\n<p>Java<br>public int[] sortArray(int[] nums) {<br>return mergeSort(nums, 0, nums.length - 1);<br>}</p>\n<p>public int[] mergeSort(int[] nums, int left, int right) {<br>if (left &gt;= right)<br>return new int[]{nums[left]};<br>int middle = (left + right) &gt;&gt;&gt; 1;<br>int[] leftPart = mergeSort(nums, left, middle);<br>int[] rightPart = mergeSort(nums, middle + 1, right);<br>return merge(leftPart, rightPart);<br>}</p>\n<p>public int[] merge(int[] left, int[] right) {<br>int[] res = new int[left.length + right.length];<br>int i = 0, j = 0, index = 0;<br>while (i &lt; left.length &amp;&amp; j &lt; right.length)<br>res[index++] = left[i] &lt; right[j] ? left[i++] : right[j++];<br>while (i &lt; left.length)<br>res[index++] = left[i++];<br>while (j &lt; right.length)<br>res[index++] = right[j++];<br>return res;<br>}<br>时间复杂度分析：为什么为 O（nlogn），且这个时间复杂度是稳定的，不随需要排序的序列不同而产生波动？<br>我们知道，归并排序的过程中，需要对当前区间进行对半划分，直到区间的长度为 1。也就是说，每一层的子区间，长度都是上一层的 1/2。这也就意味着，当划分到第 logn 层的时候，子区间的长度就是 1 了。而归并排序的 merge 操作，则是从最底层开始（子区间为 1 的层），对相邻的两个子区间进行合并，对于每一层来说，在合并所有子区间的过程中，n 个元素都会被操作一次，所以每一层的时间复杂度都是 O（n）。</p>\n<p>每一层的时间复杂度为 O（n），共有 logn 层，所以归并排序的时间复杂度就是 O（nlogn）。</p>\n<p>自顶向下「原地 + 迭代」<br>在这里插入图片描述<br>在这里插入图片描述</p>\n<p>归并两个单元素数组得到一个较大的有序数组，接着再归并两个较大数组得到更大的一个有序数组，重复这个过程，最终归并便得到了一个排好序的数组。</p>\n<p>快速排序<br>一句话总结：快速排序每一次都排定一个元素（这个元素呆在了它最终应该呆的位置），然后递归地去排它左边的部分和右边的部分，依次进行下去，直到数组有序<br>算法思想：分而治之（分治思想），与「归并排序」不同，「快速排序」在「分」这件事情上不想「归并排序」无脑地一分为二，而是采用了 partition 的方法（每次 partition 后这个元素呆在了它最终应该呆的位置），因此就没有「合」的过程。</p>\n<p>Java<br>class Solution {<br>public int[] sortArray(int[] nums) {<br>quickSort(nums, 0, nums.length - 1);<br>return nums;<br>}</p>\n<pre><code>public void quickSort(int[] nums, int start, int end) {\n    if (start &gt;= end)\n        return;\n    int partitionIndex = partition(nums, start, end);\n    // 注意要-1\n    quickSort(nums, start, partitionIndex - 1);\n    quickSort(nums, partitionIndex + 1, end);\n}\n\npublic int partition(int[] nums, int left, int right) {\n    int pivot = left;\n    while (left &lt; right) {\n        // 注意先right--再left++\n        while (left &lt; right &amp;&amp; nums[right] &gt; nums[pivot])\n            right--;\n        // 注意要有等号，二选一\n        while (left &lt; right &amp;&amp; nums[left] &lt;= nums[pivot])\n            left++;\n        if (left &lt; right)\n            swap(nums, left, right);\n    }\n    // now left == right is true\n    swap(nums, pivot, left);\n    return left;\n}\n\npublic void swap(int[] nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}</code></pre><p>}<br>时间复杂度分析：</p>\n<p>最差情况：选取的轴刚好就是这个区间的最大值或者最小值。需要处理 n 轮，每轮复杂度为 O(n)。</p>\n<p>最好情况，我们选取的轴刚好就是这个区间的中位数。<br>也就是说，在操作之后，正好将区间分成了数字个数相等的左右两个子区间。此时就和归并排序基本一致了。</p>\n<p>堆排序<br>一句话总结：先建堆，再从后往前对每一个元素 交换和归位</p>\n<p>堆：完全二叉树 + parent &gt; children</p>\n<p>注意在堆排序中，建堆堆复杂度为 O(n)，前提是在堆排序中，否则更普适的情况是 O(nlogn)</p>\n<p>Java<br>class Solution {<br>public int[] sortArray(int[] nums) {<br>heapSort(nums);<br>return nums;<br>}</p>\n<pre><code>// 堆排序，先建堆，在进行交换和归位\npublic void heapSort(int[] nums) {\n    buildHeap(nums);\n    for (int i = nums.length - 1; i &gt;= 1; i--) {\n        swap(nums, 0, i);\n        siftDown(nums, 0, i - 1);\n    }\n}\n\n// 归位函数，用于递归地把某个节点放到该放的位置\npublic void siftDown(int[] nums, int root_index, int end) {\n    int max_index = root_index;\n    int left_index = root_index * 2 + 1;\n    int right_index = root_index * 2 + 2;\n    if (left_index &lt;= end &amp;&amp; nums[left_index] &gt; nums[max_index])\n        max_index = left_index;\n    if (right_index &lt;= end &amp;&amp; nums[right_index] &gt; nums[max_index])\n        max_index = right_index;\n    if (max_index != root_index) {\n        swap(nums, max_index, root_index);\n        siftDown(nums, max_index, end);\n    }\n}\n\n// 建堆，O(n)，从倒数第二层有叶子节点的那个节点开始，依次递减\npublic void buildHeap(int[] nums) {\n    int index_tail = nums.length - 1;\n    int index_parent = (index_tail - 1) / 2;\n    for (int i = index_parent; i &gt;= 0; i--)\n        siftDown(nums, i, index_tail);\n}\n\npublic static void swap(int[] nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}</code></pre><p>}</p>\n"},{"title":"Traversal of a binary tree","url":"/2023/01/18/Traversal%20of%20a%20binary%20tree/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>The previous article (binary tree, preorder traversal, middle-order traversal, post-order traversal) only described the traversal of binary tree in general, this article focuses on the analysis of the traversal order of pre, middle and post-order</p>\n<p>Binary tree traversal<br>The depth-first traversal of a binary tree can be subdivided into preorder traversal, middle-order traversal, and postorder traversal, which can be implemented recursively (this essay focuses on recursive implementation) or non-recursively</p>\n<p>Pre-order traversal: root-&gt;left subtree -&gt; right subtree (root-&gt;left-&gt;right)</p>\n<p>Middle-order traversal: left subtree -&gt; root node -&gt; right subtree (left -&gt; root -&gt; right)</p>\n<p>Post-order traversal: left subtree -&gt; right subtree -&gt; root (left-&gt;right-&gt;root)</p>\n<p>Before proceeding to find another traversal order for two known traversal orders, let’s look at the code corresponding to different traversal orders</p>\n<p>Pre-order traversal</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">/_ traverse a binary tree _/ in a recursive manner, in preorder</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PreOrderTraverse</span><span class=\"params\">(BiTree t, <span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (t == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"data = %c level = %d\\n \"</span>, t-&gt;data, level);</span><br><span class=\"line\">  PreOrderTraverse(t-&gt;lchild, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">  PreOrderTraverse(t-&gt;rchild, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Middle-order traversal</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">/_ traverse a binary tree _/ in a recursive manner in middle order</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PreOrderTraverse</span><span class=\"params\">(BiTree t, <span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (t == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  PreOrderTraverse(t-&gt;lchild, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"data = %c level = %d\\n \"</span>, t-&gt;data, level);</span><br><span class=\"line\">  PreOrderTraverse(t-&gt;rchild, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">/_ Traverse a binary tree _/ in a recursive, post-order manner</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PreOrderTraverse</span><span class=\"params\">(BiTree t, <span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (t == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  PreOrderTraverse(t-&gt;lchild, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">  PreOrderTraverse(t-&gt;rchild, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"data = %c level = %d\\n \"</span>, t-&gt;data, level);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The code corresponding to the three traversal methods is almost identical, except that the position of one statement has changed</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"data = %c level = %d\\n \"</span>, t-&gt;data, level);</span><br></pre></td></tr></table></figure>\n\n<p>It is difficult to understand the process of traversal by just reading the text and code, so we suggest the reader to traverse the process himself.</p>\n<p>(Image source: <a href=\"https://www.cnblogs.com/xinchrome/p/4905608.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xinchrome/p/4905608.html</a>)</p>\n<p>Pre-order traversal<br>The characteristics of the traversal of the preorder, the root node -&gt; left subtree -&gt; right subtree, note that the code printf statement is placed before the two recursive statements, so first visit the root node G, print G, and then visit the left subtree D, at this time, the left subtree D as the root node, print D, and then visit the left subtree of D A</p>\n<p>A again as the root node, print A, A no left subtree or right subtree, the end of the function call returns to the D node (at this time has been printed out: GDA) D node of the left subtree has been recursively completed, now recursively visit the right subtree F, F as the root node, print F, F has left subtree visit the left subtree E, E as the</p>\n<p>root node, print E, (at this time has been printed out: GDAFE), E no left and right subtree, the function recursion ends to return to F node, the left subtree of F has recursion completed, but no right subtree, so the function recursion ends to return to D node, D node of the left subtree and right subtree recursion all complete.</p>\n<p>The function recursion ends and returns to the G node, visits the right subtree M of the G node, M as the root node, prints M, visits the left subtree H of M, H as the root node, prints H, (at this time has been printed out: GDAFEMH) H no left and right subtree, the function recursion ends and returns to the M node, the left subtree of the M node has</p>\n<p>recursion is complete, access the right subtree Z, Z as the root node, print Z, Z no left and right subtree, the function recursion is complete, return to the M node, M node of the left subtree right subtree recursion is complete, the function recursion is complete, return to the G node, G node of the left and right subtree recursion is complete, the entire binary tree traversal is complete</p>\n<p>(MGJ, finally finished -)</p>\n<p>Pre-order traversal result: GDAFEMHZ</p>\n<p>Summarize the steps of the preorder traversal</p>\n<p>Step 1: Print the node (on second thought, I removed the phrase “visit the root node”)</p>\n<p>Step 2: visit the left subtree and return to the first step (note: returning to the first step means that the left subtree of the root node is the new root node, as if D is the left subtree of G but D is also the root of A and F nodes)</p>\n<p>Step 3: Visit the right subtree and return to the first step</p>\n<p>Step 4: End the recursion and return to the previous node</p>\n<p>An alternative representation of preorder traversal.</p>\n<p>(1) Visit the root node</p>\n<p>(2) traversing the left subtree in the forward order</p>\n<p>(3) traversing the right subtree in the forward order</p>\n<p>(When completing steps 2 and 3, we also follow the rules for traversing a binary tree in the forward order)</p>\n<p>Pre-order traversal result: GDAFEMHZ</p>\n<p>Middle-order traversal (the detailed traversal process will not be repeated, (┬á┬á┬á))<br>Middle-order traversal steps<br>Step 1: Visit the left subtree of the node</p>\n<p>Step 2: If the node has a left subtree, then return to the first step, otherwise print the node</p>\n<p>Step 3: If the node has a right subtree, return to the first step, otherwise end the recursion and return to the previous node</p>\n<p>(according to my own understanding of the middle order is: first left to the end, left to the left can not be left to stop and print the node, and then return to the node’s previous node, and print the node, and then visit the node’s right subtree, and then left to the left can not be left to stop)</p>\n<p>Another representation of the mid-order traversal.</p>\n<p>(1) traversing the left subtree in the middle order</p>\n<p>(2) visit the root node</p>\n<p>(3) traversing the right subtree in middle order</p>\n<p>(When completing steps 1 and 3, follow the rules of mid-order traversal)</p>\n<p>So the middle-order traversal of the graph is: ADEFGHMZ</p>\n<p>Post-order traversal steps<br>Step 1: Visit the left subtree</p>\n<p>Step 2: If the node has a left subtree, return to the first step</p>\n<p>Step 3: If the node has a right subtree, return to the first step, otherwise print the node and return to the previous node</p>\n<p>Another representation of post-order traversal.</p>\n<p>(1) Post-order traversal of the left subtree</p>\n<p>(2) Post-order traversal of the right subtree</p>\n<p>(3) Accessing the root node</p>\n<p>(When completing steps 1 and 2, the rules for backward traversal are still followed)</p>\n<p>The post-order traversal of the graph is: AEFDHZMG</p>\n<p>(Readers who traverse the binary tree on paper, it is still easy to get the order wrong suggest to go back and look at the code corresponding to the three different traversals)</p>\n<p>Reconstruct the binary tree<br>The first: the known preorder traversal, middle-order traversal for the post-order traversal<br>Pre-order traversal: ABCDEF</p>\n<p>Middle-order traversal: CBDAEF</p>\n<p>Before the analysis, the reader needs to know the characteristics of different traversal results</p>\n<p>1, the first element of the preorder traversal is the root node of the entire binary tree</p>\n<p>2, the element to the left of the root node in the middle-order traversal is the left subtree, and the element to the right of the root node is the right subtree</p>\n<p>3, the last element of the post-order traversal is the root of the entire binary tree</p>\n<p>(If the reader does not understand the above three characteristics, it is recommended to go back and look at the code corresponding to the three different traversals and write a simple binary tree on paper with three different traversal results to deepen the understanding of the three different traversals)</p>\n<p>Using these features above to analyze the traversal results, the</p>\n<p>Step 1: First look at the preorder traversal A is definitely the root node</p>\n<p>The second step: to confirm the root node, and then look at the middle-order traversal, the root node A in the middle-order traversal of the left is CBD, the right is EF, all can determine the binary tree has both left and right subtree</p>\n<p>Step 3: First to analyze the left subtree CBD, then CBD who to do the left subtree of A? At this point, we cannot directly use the characteristics of the middle-order traversal (left-&gt;root-&gt;right) to derive the left subtree should look like this</p>\n<p>Because there are two cases that satisfy the middle-order traversal as CBD, we cannot directly derive the structure of the left subtree from the middle-order traversal, so we have to go back to the preorder traversal</p>\n<p>Observe the preorder traversal ABCDEF, the order of the left subtree CBD in the preorder traversal is BCD, which means that B is the root of the left subtree (this may not be well understood, another way to say it is that B is the left subtree of A), and this result is because if the root of a binary tree has a left subtree, then</p>\n<p>This result is because if the root of a binary tree has a left subtree, then this left subtree must follow the root in the preorder traversal (this is obtained by using the characteristics of preorder traversal (root-&gt;left-&gt;right)), and here we can confirm that B is the root of the left subtree.</p>\n<p>Step 4: then observe the middle-order traversal CBDAEF, B element left is C right is D, that B node has both left and right subtree, left and right subtree only one element can be directly determined, do not need to return to observe the pre-order traversal</p>\n<p>Step 5: Here the reconstruction of the left subtree has been completed, now rebuild the right subtree, because the process of reconstructing the right subtree and the process of the left subtree is exactly the same, the steps are not as detailed as the above ((┬á┬á┬á)), observe the middle-order traversal of the right subtree as EF, and then observe the pre-order traversal ABCDEF in the right subtree</p>\n<p>Observe that the right subtree of ABCDEF is EF, so E is the right subtree of A, and then observe that E has only F on the right side of the middle-order convenience, and all F is the right subtree of E. The final binary tree obtained is like this</p>\n<p>The resulting post-order traversal is: CDBFEA</p>\n<p>To summarize the above steps: first observe the preorder traversal to find the root node -&gt; observe the middle order traversal to classify the left side of the root node as the left subtree element and the right side as the right subtree element (there may be only left or right subtree) -&gt; observe the order of the left and right subtree elements in the preorder traversal, and the most forward is the root node of the left and right subtrees -&gt; repeat the previous steps</p>\n<p>The second: the known middle-order traversal, back-order traversal to find the front-order traversal (the question or the above)<br>Middle-order traversal: CBDAEF</p>\n<p>Post-order traversal is: CDBFEA</p>\n<p>still according to the characteristics of the results of different traversal to reconstruct the binary tree, the process is very similar here will not be detailed, the last element of the post-order traversal A is the root node, in the middle-order traversal to the root node A as a division of the elements into the left subtree (CBD) and the right subtree (EF), and then observe the order of the left subtree in the post-order traversal is CDB</p>\n<p>Then observe the middle order traversal, the left side of the B element is C and the right side is D. This means that the B node has both left and right subtrees, and only one element of the left and right subtrees can be determined directly without going back to observe the back order traversal, and the left subtree reconstruction is completed.</p>\n<p>Now look at the right subtree, the right subtree has two elements EF, observe the post-order traversal E in the back of F, so E is the root of the right subtree, and then look at the middle-order traversal E only right an F element, that is, F is the right subtree of E, at this time the entire binary tree reconstruction is complete</p>\n<p>To summarize the above steps: first observe the post-order traversal to find the root node -&gt; observe the middle-order traversal to classify the left side of the root node as the left subtree element and the right side as the right subtree element (there may be only left or right subtree) -&gt; observe the order of the left and right subtree elements in the post-order traversal, and the most backward one is the root of the left and right subtree -&gt; repeat the previous steps</p>\n<p>Note<br>Known that the preorder traversal, post-order traversal can not be derived from the middle-order traversal (because there is more than one kind of binary tree reconstructed from the preorder and post-order)</p>\n<p>For example, the two binary trees on the left have the same preorder (BEFA) and postorder (AFEB), but the corresponding middle-order traversal results are different (the left one is AFEB, the right one is BEFA), so it is impossible to reconstruct a unique binary tree by preorder and postorder alone</p>\n<p>Translated with <a href=\"http://www.DeepL.com/Translator\" target=\"_blank\" rel=\"noopener\">www.DeepL.com/Translator</a> (free version)</p>\n<p>之前的一篇随笔（二叉树、前序遍历、中序遍历、后序遍历）只对二叉树的遍历进行了笼统的描述，这篇随笔重点对前、中、后序的遍历顺序进行分析</p>\n<p>二叉树的遍历<br>二叉树的深度优先遍历可细分为前序遍历、中序遍历、后序遍历，这三种遍历可以用递归实现（本篇随笔主要分析递归实现），也可使用非递归实现的</p>\n<p>前序遍历：根节点-&gt;左子树-&gt;右子树（根-&gt;左-&gt;右）</p>\n<p>中序遍历：左子树-&gt;根节点-&gt;右子树（左-&gt;根-&gt;右）</p>\n<p>后序遍历：左子树-&gt;右子树-&gt;根节点（左-&gt;右-&gt;根）</p>\n<p>在进行已知两种遍历顺序求另一种遍历顺序前，先看一下不同遍历顺序对应的代码</p>\n<p>前序遍历</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">/_ 以递归方式 前序遍历二叉树 _/</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PreOrderTraverse</span><span class=\"params\">(BiTree t, <span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (t == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"data = %c level = %d\\n \"</span>, t-&gt;data, level);</span><br><span class=\"line\">  PreOrderTraverse(t-&gt;lchild, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">  PreOrderTraverse(t-&gt;rchild, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>中序遍历</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">/_ 以递归方式 中序遍历二叉树 _/</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PreOrderTraverse</span><span class=\"params\">(BiTree t, <span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (t == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  PreOrderTraverse(t-&gt;lchild, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"data = %c level = %d\\n \"</span>, t-&gt;data, level);</span><br><span class=\"line\">  PreOrderTraverse(t-&gt;rchild, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">/_ 以递归方式 后序遍历二叉树 _/</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PreOrderTraverse</span><span class=\"params\">(BiTree t, <span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (t == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  PreOrderTraverse(t-&gt;lchild, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">  PreOrderTraverse(t-&gt;rchild, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"data = %c level = %d\\n \"</span>, t-&gt;data, level);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>三种遍历方式对应的代码几乎相同，只是一条语句的位置发生了变化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"data = %c level = %d\\n \"</span>, t-&gt;data, level);</span><br></pre></td></tr></table></figure>\n\n<p>只看文字和代码来理解遍历的过程是比较困难的，建议读者亲自去遍历，为了理清遍历的过程下面上题</p>\n<p>（图片来源：<a href=\"https://www.cnblogs.com/xinchrome/p/4905608.html）\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xinchrome/p/4905608.html）</a></p>\n<p>前序遍历<br>前序的遍历的特点，根节点-&gt;左子树-&gt;右子树，注意看前序的遍历的代码 printf 语句是放在两条递归语句之前的，所以先访问根节点 G，打印 G，然后访问左子树 D，此时左子树 D 又作为根节点，打印 D，再访问 D 的左子树 A</p>\n<p>A 又作为根节点，打印 A，A 没有左子树或者右子树，函数调用结束返回到 D 节点（此时已经打印出来的有：GDA）D 节点的左子树已经递归完成，现在递归访问右子树 F，F 作为根节点，打印 F，F 有左子树访问左子树 E，E 作为</p>\n<p>根节点，打印 E，（此时已经打印出来的有：GDAFE），E 没有左子树和右子树，函数递归结束返回 F 节点，F 的左子树已经递归完成了，但没有右子树，所以函数递归结束，返回 D 节点，D 节点的左子树和右子树递归全部完成，</p>\n<p>函数递归结束返回 G 节点，访问 G 节点的右子树 M，M 作为根节点，打印 M，访问 M 的左子树 H，H 作为根节点，打印 H，（此时已经打印出来的有：GDAFEMH）H 没有左子树和右子树，函数递归结束，返回 M 节点，M 节点的左子树已经</p>\n<p>递归完成，访问右子树 Z，Z 作为根节点，打印 Z，Z 没有左子树和右子树，函数递归结束，返回 M 节点，M 节点的左子树右子树递归全部完成，函数递归结束，返回 G 节点，G 节点的左右子树递归全部完成，整个二叉树的遍历就结束了</p>\n<p>（MGJ，终于打完了··）</p>\n<p>前序遍历结果：GDAFEMHZ</p>\n<p>总结一下前序遍历步骤</p>\n<p>第一步：打印该节点（再三考虑还是把访问根节点这句话去掉了）</p>\n<p>第二步：访问左子树，返回到第一步（注意：返回到第一步的意思是将根节点的左子树作为新的根节点，就好比图中 D 是 G 的左子树但是 D 也是 A 节点和 F 节点的根节点）</p>\n<p>第三步：访问右子树，返回到第一步</p>\n<p>第四步：结束递归，返回到上一个节点</p>\n<p>前序遍历的另一种表述：</p>\n<p>（1）访问根节点</p>\n<p>（2）前序遍历左子树</p>\n<p>（3）前序遍历右子树</p>\n<p>（在完成第 2,3 步的时候，也是要按照前序遍历二叉树的规则完成）</p>\n<p>前序遍历结果：GDAFEMHZ</p>\n<p>中序遍历（详细遍历过程就不再赘述了，(┬＿┬)）<br>中序遍历步骤<br>第一步：访问该节点左子树</p>\n<p>第二步：若该节点有左子树，则返回第一步，否则打印该节点</p>\n<p>第三步：若该节点有右子树，则返回第一步，否则结束递归并返回上一节点</p>\n<p>（按我自己理解的中序就是：先左到底，左到不能在左了就停下来并打印该节点，然后返回到该节点的上一节点，并打印该节点，然后再访问该节点的右子树，再左到不能再左了就停下来）</p>\n<p>中序遍历的另一种表述：</p>\n<p>（1）中序遍历左子树</p>\n<p>（2）访问根节点</p>\n<p>（3）中序遍历右子树</p>\n<p>（在完成第 1，3 步的时候，要按照中序遍历的规则来完成）</p>\n<p>所以该图的中序遍历为：ADEFGHMZ</p>\n<p>后序遍历步骤<br>第一步：访问左子树</p>\n<p>第二步：若该节点有左子树，返回第一步</p>\n<p>第三步：若该节点有右子树，返回第一步，否则打印该节点并返回上一节点</p>\n<p>后序遍历的另一种表述：</p>\n<p>（1）后序遍历左子树</p>\n<p>（2）后序遍历右子树</p>\n<p>（3）访问根节点</p>\n<p>（在完成 1,2 步的时候，依然要按照后序遍历的规则来完成）</p>\n<p>该图的后序遍历为：AEFDHZMG</p>\n<p>（读者如果在纸上遍历二叉树的时候，仍然容易将顺序搞错建议再回去看一下三种不同遍历对应的代码）</p>\n<p>重构二叉树<br>第一种：已知前序遍历、中序遍历求后序遍历<br>前序遍历：ABCDEF</p>\n<p>中序遍历：CBDAEF</p>\n<p>在进行分析前读者需要知道不同遍历结果的特点</p>\n<p>1、前序遍历的第一元素是整个二叉树的根节点</p>\n<p>2、中序遍历中根节点的左边的元素是左子树，根节点右边的元素是右子树</p>\n<p>3、后序遍历的最后一个元素是整个二叉树的根节点</p>\n<p>（如果读者不明白上述三个特点，建议再回去看一下三种不同遍历对应的代码，并在纸上写出一个简单的二叉树的三种不同的遍历结果，以加深对三种不同遍历的理解）</p>\n<p>用上面这些特点来分析遍历结果，</p>\n<p>第一步：先看前序遍历 A 肯定是根节点</p>\n<p>第二步：确认了根节点，再来看中序遍历，中序遍历中根节点 A 的左边是 CBD，右边是 EF，所有可以确定二叉树既有左子树又有右子树</p>\n<p>第三步：先来分析左子树 CBD，那么 CBD 谁来做 A 的左子树呢？这个时候不能直接用中序遍历的特点（左-&gt;根-&gt;右）得出左子树应该是这个样子</p>\n<p>因为有两种情况都满足中序遍历为 CBD 无法直接根据中序遍历来直接得出左子树的结构，这个时候就要返回到前序遍历中去</p>\n<p>观察前序遍历 ABCDEF，左子树 CBD 在前序遍历中的顺序是 BCD，意味着 B 是左子树的根节点（这么说可能不太好理解，换个说法就是 B 是 A 的左子树）,得出这个结果是因为如果一个二叉树的根节点有左子树，那么</p>\n<p>这个左子树一定在前序遍历中一定紧跟着根节点（这个是用前序遍历的特点（根-&gt;左-&gt;右）得出的）,到这里就可以确认 B 是左子树的根节点</p>\n<p>第四步：再观察中序遍历 CBDAEF，B 元素左边是 C 右边是 D，说明 B 节点既有左子树又有右子树，左右子树只有一个元素就可以直接确定了，不用再返回去观察前序遍历</p>\n<p>第五步：到这里左子树的重建就已经完成了，现在重建右子树，因为重建右子树的过程和左子树的过程一模一样，步骤就不像上面写这么细了（(┬＿┬)），观察中序遍历右子树为 EF，再观察前序遍历 ABCDEF 中右子树</p>\n<p>的顺序为 EF，所以 E 为 A 的右子树，再观察中序便利中 E 只有右边有 F，所有 F 为 E 的右子树，最后得到的二叉树是这个样子的</p>\n<p>所有求得的后序遍历为：CDBFEA</p>\n<p>总结一下上述步骤： 先观察前序遍历找到根节点-&gt;观察中序遍历将根节点左边归为左子树元素，右边归为右子树元素（可能会出现只有左子树或者右子树的情况）-&gt;观察前序遍历中左\\右子树几个元素的顺序，最靠前的为左\\右子树的根节点-&gt;重复前面的步骤</p>\n<p>第二种：已知中序遍历、后序遍历求前序遍历（题还是上面这道）<br>中序遍历：CBDAEF</p>\n<p>后序遍历为：CDBFEA</p>\n<p>仍然是根据不同遍历方式结果的特点来重构二叉树，过程很相似这里就不详细说了，后序遍历的最后一个元素 A 是根节点，在中序遍历中以根节点 A 作为分界将元素分为左子树（CBD）和右子树（EF），再观察后序遍历中左子树的顺序是 CDB</p>\n<p>，可以判断出 B 是左子树的根节点（因为后序遍历是：左-&gt;右-&gt;根），再观察中序遍历，B 元素左边是 C 右边是 D，说明 B 节点既有左子树又有右子树，左右子树只有一个元素就可以直接确定了，不用再返回去观察后序遍历，左子树重建完成，</p>\n<p>现在来看右子树，右子树有两个元素 EF，观察后序遍历 E 在 F 的后面，所以 E 是右子树的根节点，然后看中序遍历中 E 只有右边一个 F 元素了，即 F 是 E 的右子树，此时整个二叉树重构完成</p>\n<p>总结一下上述步骤：先观察后序遍历找到根节点-&gt;观察中序遍历将根节点左边归为左子树元素，右边归为右子树元素（可能会出现只有左子树或者右子树的情况）-&gt;观察后序遍历中左\\右子树几个元素的顺序，最靠后的为左\\右子树的根节点-&gt;重复前面的步骤</p>\n<p>注意<br>已知前序遍历、后序遍历无法求出中序遍历（因为由前序后序重构出来的二叉树不止一种）</p>\n<p>举个栗子左图这两种二叉树前序（BEFA）和后序（AFEB）一样，但对应的中序遍历结果不一样（左边的是 AFEB 右边的是 BEFA），所以仅靠前序后序是无法重构出唯一的二叉树</p>\n"},{"title":"hexo butterfly折腾心得","url":"/2020/08/11/hexo%20butterfly%E6%8A%98%E8%85%BE%E5%BF%83%E5%BE%97/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>魔改了两天的butterfly主题，说下心得吧</p>\n<h1 id=\"我的博客\"><a href=\"#我的博客\" class=\"headerlink\" title=\"我的博客\"></a>我的博客</h1><p>首先给各位观众老爷们看下效果<br><a href=\"https://zhenglin-li.github.io/\" target=\"_blank\" rel=\"noopener\">https://zhenglin-li.github.io/</a><br><a href=\"http://9pshr3.coding-pages.com/\">http://9pshr3.coding-pages.com/</a><br>这两个一样的，第二个速度快</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><ol>\n<li><p>butterfly主题官方的参考文档：<a href=\"https://demo.jerryc.me/\" target=\"_blank\" rel=\"noopener\">https://demo.jerryc.me/</a></p>\n</li>\n<li><p>0基础从hexo开始的参考文档：<a href=\"https://www.jianshu.com/p/a1a4ebf0e5fc\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/a1a4ebf0e5fc</a></p>\n</li>\n<li><p>0基础从hexo开始的参考文档：<a href=\"https://blog.csdn.net/weixin_42429718/article/details/105723193\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_42429718/article/details/105723193</a></p>\n</li>\n<li><p>音乐页面的参考文档：<a href=\"https://blog.csdn.net/qq_46435629/article/details/106295515\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_46435629/article/details/106295515</a></p>\n</li>\n<li><p>hexo douban的使用参考文档：<a href=\"https://github.com/mythsman/hexo-douban\" target=\"_blank\" rel=\"noopener\">https://github.com/mythsman/hexo-douban</a></p>\n</li>\n<li><p>在butterfy中使用iconfont图标：<a href=\"https://blog.csdn.net/u012208219/article/details/106883012/\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u012208219/article/details/106883012/</a></p>\n</li>\n</ol>\n<h1 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h1><ol>\n<li><p>刚开始改主题配置文件的时候，一定要记得修改的是<code>blog根目录/source/_data</code>下的<code>butterfly.yml</code>，没有你就创建一个，然后把本来的配置文件里的代码复制过去再进行修改</p>\n</li>\n<li><p>参考文档里面对增加音乐界面的描述不是很清楚，可以参考<a href=\"https://blog.csdn.net/qq_46435629/article/details/106295515\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_46435629/article/details/106295515</a></p>\n</li>\n<li><p>在hexo douban的使用中</p>\n<ol>\n<li><p>书籍电影游戏页面分别对应books、movies、games</p>\n</li>\n<li><p>注意这里不用hexo new page books，hexo douban会自动生成的</p>\n</li>\n<li><p>hexo douban是利用爬虫来实现的，每日在终端（powershell或git bash）输入<code>hexo douban -bgm</code>多次会触发豆瓣的反爬虫机制，导致获取不到数据的情况，等过一天就好了<br>附报错提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">   INFO  0 books have been loaded in 1336 ms, because you are offline \t\tor your network is bad</span><br><span class=\"line\">INFO  0 movies have been loaded in 1409 ms, because you are offline \tor your network is bad</span><br><span class=\"line\">INFO  0 games have been loaded in 1360 ms, because you are offline \t\tor your network is bad</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>在butterfy中使用iconfont图标：<a href=\"https://blog.csdn.net/u012208219/article/details/106883012/\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u012208219/article/details/106883012/</a></p>\n</li>\n</ol>\n","categories":["个人博客"]},{"title":"my-first-blog","url":"/2020/06/16/my-first-blog/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"my-first-Blog\"><a href=\"#my-first-Blog\" class=\"headerlink\" title=\"my first Blog\"></a>my first Blog</h1><p>各位好，欢迎来到我的Blog。</p>\n<p>本博客采用hexo框架，GitHub、gitee、coding托管，现为butterfly主题。</p>\n<p>这是我的第一篇博客。</p>\n","categories":["个人博客"]},{"title":"reset.css","url":"/2020/08/04/reset-css/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>css的重置样式表分享：reset.css</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">html5doctor.com Reset Stylesheet</span></span><br><span class=\"line\"><span class=\"comment\">Time:2020.8.4</span></span><br><span class=\"line\"><span class=\"comment\">Author: Zhenglin Li</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span>, <span class=\"selector-tag\">div</span>, <span class=\"selector-tag\">span</span>, <span class=\"selector-tag\">object</span>, <span class=\"selector-tag\">iframe</span>,</span><br><span class=\"line\"><span class=\"selector-tag\">h1</span>, <span class=\"selector-tag\">h2</span>, <span class=\"selector-tag\">h3</span>, <span class=\"selector-tag\">h4</span>, <span class=\"selector-tag\">h5</span>, <span class=\"selector-tag\">h6</span>, <span class=\"selector-tag\">p</span>, <span class=\"selector-tag\">blockquote</span>, <span class=\"selector-tag\">pre</span>,</span><br><span class=\"line\"><span class=\"selector-tag\">abbr</span>, <span class=\"selector-tag\">address</span>, <span class=\"selector-tag\">cite</span>, <span class=\"selector-tag\">code</span>,</span><br><span class=\"line\"><span class=\"selector-tag\">del</span>, <span class=\"selector-tag\">dfn</span>, <span class=\"selector-tag\">em</span>, <span class=\"selector-tag\">img</span>, <span class=\"selector-tag\">ins</span>, <span class=\"selector-tag\">kbd</span>, <span class=\"selector-tag\">q</span>, <span class=\"selector-tag\">samp</span>,</span><br><span class=\"line\"><span class=\"selector-tag\">small</span>, <span class=\"selector-tag\">strong</span>, <span class=\"selector-tag\">sub</span>, <span class=\"selector-tag\">sup</span>, <span class=\"selector-tag\">var</span>,</span><br><span class=\"line\"><span class=\"selector-tag\">b</span>, <span class=\"selector-tag\">i</span>,</span><br><span class=\"line\"><span class=\"selector-tag\">dl</span>, <span class=\"selector-tag\">dt</span>, <span class=\"selector-tag\">dd</span>, <span class=\"selector-tag\">ol</span>, <span class=\"selector-tag\">ul</span>, <span class=\"selector-tag\">li</span>,</span><br><span class=\"line\"><span class=\"selector-tag\">fieldset</span>, <span class=\"selector-tag\">form</span>, <span class=\"selector-tag\">label</span>, <span class=\"selector-tag\">legend</span>,</span><br><span class=\"line\"><span class=\"selector-tag\">table</span>, <span class=\"selector-tag\">caption</span>, <span class=\"selector-tag\">tbody</span>, <span class=\"selector-tag\">tfoot</span>, <span class=\"selector-tag\">thead</span>, <span class=\"selector-tag\">tr</span>, <span class=\"selector-tag\">th</span>, <span class=\"selector-tag\">td</span>,</span><br><span class=\"line\"><span class=\"selector-tag\">article</span>, <span class=\"selector-tag\">aside</span>, <span class=\"selector-tag\">canvas</span>, <span class=\"selector-tag\">details</span>, <span class=\"selector-tag\">figcaption</span>, <span class=\"selector-tag\">figure</span>, </span><br><span class=\"line\"><span class=\"selector-tag\">footer</span>, <span class=\"selector-tag\">header</span>, <span class=\"selector-tag\">hgroup</span>, <span class=\"selector-tag\">menu</span>, <span class=\"selector-tag\">nav</span>, <span class=\"selector-tag\">section</span>, <span class=\"selector-tag\">summary</span>,</span><br><span class=\"line\"><span class=\"selector-tag\">time</span>, <span class=\"selector-tag\">mark</span>, <span class=\"selector-tag\">audio</span>, <span class=\"selector-tag\">video</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">outline</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>:baseline;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:transparent;</span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>:border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-pseudo\">:focus</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">outline</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">article</span>,<span class=\"selector-tag\">aside</span>,<span class=\"selector-tag\">canvas</span>,<span class=\"selector-tag\">details</span>,<span class=\"selector-tag\">figcaption</span>,<span class=\"selector-tag\">figure</span>,</span><br><span class=\"line\"><span class=\"selector-tag\">footer</span>,<span class=\"selector-tag\">header</span>,<span class=\"selector-tag\">hgroup</span>,<span class=\"selector-tag\">menu</span>,<span class=\"selector-tag\">nav</span>,<span class=\"selector-tag\">section</span>,<span class=\"selector-tag\">summary</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">display</span>:block;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">list-style</span>:none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">blockquote</span>, <span class=\"selector-tag\">q</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">quotes</span>:none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">blockquote</span><span class=\"selector-pseudo\">:before</span>, <span class=\"selector-tag\">blockquote</span><span class=\"selector-pseudo\">:after</span>,</span><br><span class=\"line\"><span class=\"selector-tag\">q</span><span class=\"selector-pseudo\">:before</span>, <span class=\"selector-tag\">q</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>:<span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>:none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>:baseline;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:transparent;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">ins</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>:<span class=\"number\">#ff9</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#000</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-decoration</span>:none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">mark</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>:<span class=\"number\">#ff9</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#000</span>; </span><br><span class=\"line\">    <span class=\"attribute\">font-style</span>:italic;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>:bold;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">del</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">text-decoration</span>: line-through;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">abbr</span><span class=\"selector-attr\">[title]</span>, <span class=\"selector-tag\">dfn</span><span class=\"selector-attr\">[title]</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>:<span class=\"number\">1px</span> dotted <span class=\"number\">#000</span>;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>:help;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">table</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-collapse</span>:collapse;</span><br><span class=\"line\">    <span class=\"attribute\">border-spacing</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">hr</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:block;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">1px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>:<span class=\"number\">0</span>;   </span><br><span class=\"line\">    <span class=\"attribute\">border-top</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#cccccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">1em</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">input</span>, <span class=\"selector-tag\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>:middle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["前端"],"tags":["资源分享"]},{"title":"todo","url":"/2023/01/18/todo/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>整理 C++<br>翻译英文<br>juejin</p>\n"},{"title":"mysql 安装教程和注意事项","url":"/2020/07/19/mysql%E5%AE%89%E8%A3%85/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"mysql-安装教程和注意事项\"><a href=\"#mysql-安装教程和注意事项\" class=\"headerlink\" title=\"mysql 安装教程和注意事项\"></a>mysql 安装教程和注意事项</h1><h2 id=\"下载MySql\"><a href=\"#下载MySql\" class=\"headerlink\" title=\"下载MySql\"></a>下载MySql</h2><p>官网下载地址：<a href=\"https://dev.mysql.com/downloads/mysql/，\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/mysql/，</a> 我选的第一个版本。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/07/19/yiSjxTZ1ncPz3AH.png\" alt=\"image-20200719173654976\"></p>\n<h2 id=\"解压和配置\"><a href=\"#解压和配置\" class=\"headerlink\" title=\"解压和配置\"></a>解压和配置</h2><p>我是直接解压到D盘，总之路径不能有中文，解压到指定文件目录。</p>\n<ol>\n<li><p>打开解压后的MySql文件在根目录下创建my.ini (mysql配置文件)。</p>\n</li>\n<li><p>新建文本文件输入以下内容,并修改文件名为my.ini</p>\n</li>\n<li><p>注意里面的basedir和datadir字段要视安装位置而定</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[mysql]</span><br><span class=\"line\"> </span><br><span class=\"line\"># 设置mysql客户端默认字符集</span><br><span class=\"line\"> </span><br><span class=\"line\">default-character-set&#x3D;utf8</span><br><span class=\"line\"> </span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\"> </span><br><span class=\"line\">#设置3306端口</span><br><span class=\"line\"> </span><br><span class=\"line\">port &#x3D; 3306</span><br><span class=\"line\"> </span><br><span class=\"line\"># 设置mysql的安装目录</span><br><span class=\"line\"> </span><br><span class=\"line\">basedir&#x3D;D:\\mysql-8.0.21-winx64</span><br><span class=\"line\"> </span><br><span class=\"line\"># 设置mysql数据库的数据的存放目录</span><br><span class=\"line\"> </span><br><span class=\"line\">datadir&#x3D;D:\\mysql-8.0.21-winx64\\data</span><br><span class=\"line\"> </span><br><span class=\"line\"># 允许最大连接数</span><br><span class=\"line\"> </span><br><span class=\"line\">max_connections&#x3D;200</span><br><span class=\"line\"> </span><br><span class=\"line\"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class=\"line\"> </span><br><span class=\"line\">character-set-server&#x3D;utf8</span><br><span class=\"line\"> </span><br><span class=\"line\"># 创建新表时将使用的默认存储引擎</span><br><span class=\"line\"> </span><br><span class=\"line\">default-storage-engine&#x3D;INNODB</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><p>找到CMD命令提示符，右键以管理员身份运行</p>\n<p>如下图</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/07/19/beTQEgw1HdWI2GA.png\" alt=\"\"></p>\n</li>\n</ol>\n<p>​             进入mysql子目录bin，如D: 进入D盘，cd 文件夹名 打开文件夹等操作不再赘述。</p>\n<p>​             在bin下依次输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysqld --install</span><br></pre></td></tr></table></figure>\n\n<pre><code>(安装) </code></pre><p>​             </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysqld --initialize</span><br></pre></td></tr></table></figure>\n\n<pre><code>（初始化）</code></pre><p>​        </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">net start mysql</span><br></pre></td></tr></table></figure>\n\n<p>​              （运行）</p>\n<p>如果出现“发生系统错误2”的提示，我的解决方法是：</p>\n<p>在<strong>管理员命令行窗口</strong>下，进入<strong>安装的mysql的bin</strong>目录下：</p>\n<p><strong>1.  mysql -remove</strong></p>\n<p><strong>2.  mysql -install</strong></p>\n<p><strong>3.  net start mysql</strong></p>\n<p><strong>(4. net stop mysql (关闭mysql))</strong></p>\n<h2 id=\"配置环境变量\"><a href=\"#配置环境变量\" class=\"headerlink\" title=\"配置环境变量\"></a>配置环境变量</h2><ol>\n<li>直接搜索环境变量进入到页面</li>\n<li>点击系统变量的Path，编辑Path。</li>\n<li>点击新建，把bin目录加入其中。</li>\n</ol>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/07/20/eORgKXBpbGaZ5YV.png\" alt=\"\"></p>\n<h2 id=\"重设密码\"><a href=\"#重设密码\" class=\"headerlink\" title=\"重设密码\"></a>重设密码</h2><p>这一步花了我很长时间，是因为在my.ini文件中加入mysqld –skip-grant-tables跳过密码验证的方法在mysql8.0中已失效，使用使用以下步骤重设密码</p>\n<ol>\n<li>打开命令窗口cmd，输入命令：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">net stop mysql</span><br></pre></td></tr></table></figure>\n\n<p>停止MySQL服务，</p>\n<ol start=\"2\">\n<li>开启跳过密码验证登录的MySQL服务</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysqld --console --skip-grant-tables --shared-memory</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>再打开一个新的cmd，无密码登录MySQL，输入登录命令：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>密码置为空，命令如下：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">use mysql</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">update user set authentication_string&#x3D;&#39;&#39; where user&#x3D;&#39;root&#39;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>退出mysql，执行命令：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">quit</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"6\">\n<li><p>关闭以-console –skip-grant-tables –shared-memory 启动的MySQL服务，</p>\n</li>\n<li><p>打开命令框，输入：net start mysql 启动MySQL服务，一管理员的身份运行cmd。</p>\n</li>\n<li><p>步骤4密码已经置空，所以无密码状态登录MySQL，输入登录命令：mysql -u root -p</p>\n</li>\n<li><p>修改密码，如下图：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;新密码&#39;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"10\">\n<li>验证更改后密码正确登录</li>\n</ol>\n<p>输入quit，退出当前登录，输入登录命令：mysql -u root -p</p>\n<p>输入密码，成功登录，到此，重置密码结束。</p>\n","categories":["数据库"],"tags":["mysql","数据库"]},{"title":"删除github上仓库里的文件","url":"/2020/08/18/%E5%88%A0%E9%99%A4github%E4%B8%8A%E4%BB%93%E5%BA%93%E9%87%8C%E7%9A%84%E6%96%87%E4%BB%B6/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"一-删除已有仓库\"><a href=\"#一-删除已有仓库\" class=\"headerlink\" title=\"一.删除已有仓库\"></a>一.删除已有仓库</h1><p>如果我们想要删除Github中没有用的仓库，应该如何去做呢？</p>\n<p>进入到我们需要删除的仓库里面，找到“settings”即仓库设置,<br>然后，在仓库设置里拉到最底部，找到“Danger Zone”即危险区域,<br>点击“Delete this repository”这样就可以删除该仓库了。</p>\n<h1 id=\"二-删除Github中的某个文件或文件夹\"><a href=\"#二-删除Github中的某个文件或文件夹\" class=\"headerlink\" title=\"二.删除Github中的某个文件或文件夹\"></a>二.删除Github中的某个文件或文件夹</h1><p>我们知道，在Github上我们只能删除仓库，并不能删除文件或者文件夹，所以只能用命令来解决。</p>\n<h2 id=\"1-新建文件夹\"><a href=\"#1-新建文件夹\" class=\"headerlink\" title=\"1. 新建文件夹\"></a>1. 新建文件夹</h2><p>在桌面上新建一个文件夹<code>delete</code>，其实在哪里建叫什么名都可以</p>\n<h2 id=\"2-git-bash-here\"><a href=\"#2-git-bash-here\" class=\"headerlink\" title=\"2. git bash here\"></a>2. <code>git bash here</code></h2><p>在新建的文件夹里右键<code>git bash here</code>打开终端，并执行<code>git init</code>初始化仓库</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/08/18/6qcP7g1FWEJZnvY.png\" alt=\"\"></p>\n<h2 id=\"3-git-clone-lt-你的地址-gt\"><a href=\"#3-git-clone-lt-你的地址-gt\" class=\"headerlink\" title=\"3. git clone &lt;你的地址&gt;\"></a>3. <code>git clone &lt;你的地址&gt;</code></h2><p>找到github上要删除的仓库地址，并复制，在终端里输入<code>git clone &lt;你的地址&gt;</code><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/08/18/PKmY8O756IDc4sr.png\" alt=\"\"></p>\n<h2 id=\"4-git-bash-here\"><a href=\"#4-git-bash-here\" class=\"headerlink\" title=\"4. git bash here\"></a>4. <code>git bash here</code></h2><p>然后你会发现多了一个文件夹，打开之，并在该文件夹下右键<code>git bash here</code>打开终端，注意这里是一个新的终端了<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/08/18/PKmY8O756IDc4sr.png\" alt=\"\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/08/18/PKmY8O756IDc4sr.png\" alt=\"\"></p>\n<h2 id=\"5-dir\"><a href=\"#5-dir\" class=\"headerlink\" title=\"5. dir\"></a>5. <code>dir</code></h2><p>在终端里输入<code>dir</code>查看此文件夹下的文件和目录（文件夹）</p>\n<h2 id=\"6-git-rm-lt-filename-gt\"><a href=\"#6-git-rm-lt-filename-gt\" class=\"headerlink\" title=\"6.git rm &lt;filename&gt;\"></a>6.<code>git rm &lt;filename&gt;</code></h2><p>删除本地仓库文件 <code>git rm &lt;filename&gt;</code>，<code>&lt;filename&gt;</code>是你要删除的文件名字</p>\n<h2 id=\"7-git-rm-r-lt-filename-gt-，-lt-filename-gt\"><a href=\"#7-git-rm-r-lt-filename-gt-，-lt-filename-gt\" class=\"headerlink\" title=\"7. git rm -r &lt;filename&gt;，&lt;filename&gt;\"></a>7. <code>git rm -r &lt;filename&gt;</code>，<code>&lt;filename&gt;</code></h2><p>文件夹的删除和文件不一样，需要多一个参数，如下<br>删除本地仓库文件夹 <code>git rm -r &lt;filename&gt;</code>，<code>&lt;filename&gt;</code>是你要删除的文件夹名字<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/08/18/f45za73j8PFqGZm.png\" alt=\"\"></p>\n<h2 id=\"8-git-commit-m-quot-备注-quot\"><a href=\"#8-git-commit-m-quot-备注-quot\" class=\"headerlink\" title=\"8. git commit -m &quot;备注&quot;\"></a>8. <code>git commit -m &quot;备注&quot;</code></h2><p>删除完你需要删除的文件和文件夹以后，在终端里提交本次修改<code>git commit -m &quot;备注&quot;</code><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/08/18/hmP58SUoFCuvzqw.png\" alt=\"\"></p>\n<h2 id=\"9-git-checkout\"><a href=\"#9-git-checkout\" class=\"headerlink\" title=\"9. git checkout\"></a>9. <code>git checkout</code></h2><p>把删除的文件恢复到最新版本 <code>git checkout</code></p>\n<h2 id=\"10-git-push\"><a href=\"#10-git-push\" class=\"headerlink\" title=\"10. git push\"></a>10. <code>git push</code></h2><p>将本地内容推送到远程仓库 <code>git push</code></p>\n<h2 id=\"11-大功告成！\"><a href=\"#11-大功告成！\" class=\"headerlink\" title=\"11. 大功告成！\"></a>11. 大功告成！</h2><p>刷新github仓库 看到选定删除的文件没有了。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/08/18/uXqeW94l7HsZUNb.png\" alt=\"\"></p>\n","categories":["git"],"tags":["git","github"]},{"title":"大一实训","url":"/2020/07/14/%E5%A4%A7%E4%B8%80%E5%AE%9E%E8%AE%AD/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>好了，又到了全校放假而计软网实训的时候了，我选的是超市信息管理系统。</p>\n<p>链接如下：</p>\n<p><a href=\"https://github.com/ZhengLin-Li/Practical-training-in-2020\" target=\"_blank\" rel=\"noopener\">https://github.com/ZhengLin-Li/Practical-training-in-2020</a></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/07/23/HYDmIMiQ2szgEc3.png\" alt=\"image-20200723142936009\"></p>\n<p>实习总结：</p>\n<p>对于软件工程专业来说，实习的重要性不言而喻。虽然大一暑假的这次实训也算不上实习，但我还是获益良多，下面我来做个简短的总结。</p>\n<p>本次实训工作的具体内容有和小组成员们讨论并完善完善需求规约以及填写项目设计报告，并在此基础上进行代码的编写。</p>\n<p>自项目开始之初，我就热情饱满，以认真负责的态度努力完成自己负责的各项任务。我能严格要求自己，主动完成组长交给我的各项任务。众所周知，一个软件的完成需要团队默契的配合，我自己出现的失误可能会使整个团队进度受到影响。因此在实训的这段时间里，我与小组内其他成员积极沟通，互相协助解决问题。从而在项目基本完成的情况下又进行了多方面的改善，达到了预定的目标。</p>\n<p>通过这次实训，我了解到了明确需求的重要性，良好团队沟通和代码规范的必要性，以及体会到了软件行业确实需要不断的学习才能跟上时代的步伐。在本次实训开始前，我就初略的看完了链表，本想着水到渠成，结果纸上得来终觉浅，实操起来接问题百出，于是我明白了编程要勤于实践。这次实训我另外一个收获就是了解了在企业中是如何通过团队合作的方式来协力完成某个项目的开发。培养了我的软件开发思维，让我在编写代码和完善文档时更具有条理。</p>\n<p>这次实训也暴露出我自身的一些问题：c语言基础不够扎实，撰写文档的经验不足，团队交流有些生疏等等。我在这次实训中着重关注了这些问题并加以改进，已有明显进步。也很感谢实训老师这十天的辛苦付出与耐心讲解，为我的代码提出了很多实用的意见，也指出了我不足，使我能够找准方向提升自己。</p>\n<p>日期：2020.7.22</p>\n","categories":["实训"],"tags":["实训","C语言"]},{"title":"发文Demo","url":"/2020/08/11/%E5%8F%91%E6%96%87Demo/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"链接合集\"><a href=\"#链接合集\" class=\"headerlink\" title=\"链接合集\"></a>链接合集</h1><p>github：<br>我的邮箱：<a href=\"mailto:1125806272@qq.com\">1125806272@qq.com</a><br>我的博客：<a href=\"http://9pshr3.coding-pages.com/\">http://9pshr3.coding-pages.com/</a><br>或<a href=\"https://zhenglin-li.github.io/\" target=\"_blank\" rel=\"noopener\">https://zhenglin-li.github.io/</a><br>我的csdn：<a href=\"https://me.csdn.net/Panda325\" target=\"_blank\" rel=\"noopener\">https://me.csdn.net/Panda325</a><br>我的简书：<a href=\"https://www.jianshu.com/u/e2d945027d3f\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/u/e2d945027d3f</a><br>我的今日头条：<a href=\"https://www.toutiao.com/c/user/4004188138/#mid=1592553312231438\" target=\"_blank\" rel=\"noopener\">https://www.toutiao.com/c/user/4004188138/#mid=1592553312231438</a><br>我的博客园：<a href=\"https://www.cnblogs.com/zhenglin-li/\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhenglin-li/</a></p>\n<h1 id=\"git-bash一条龙\"><a href=\"#git-bash一条龙\" class=\"headerlink\" title=\"git bash一条龙\"></a>git bash一条龙</h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean &amp;&amp; hexo douban -bgm &amp;&amp; hexo g &amp;&amp; hexo deploy &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"Front-matter\"><a href=\"#Front-matter\" class=\"headerlink\" title=\"Front-matter\"></a>Front-matter</h1><p>Front-matter 是档案最上方以 — 分隔的区域，用于指定个别档案的变数。</p>\n<p>如果标注可选的参数，可根据自己需要添加，不用全部都写在 markdown 里</p>\n<h2 id=\"Page-Front-matter\"><a href=\"#Page-Front-matter\" class=\"headerlink\" title=\"Page Front-matter\"></a>Page Front-matter</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title:</span><br><span class=\"line\">date:</span><br><span class=\"line\">updated:</span><br><span class=\"line\">type:</span><br><span class=\"line\">comments:</span><br><span class=\"line\">description:</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">top_img:</span><br><span class=\"line\">mathjax:</span><br><span class=\"line\">katex:</span><br><span class=\"line\">aside:</span><br><span class=\"line\">aplayer：</span><br><span class=\"line\">highlight_shrink：</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<hr>\n<table>\n<thead>\n<tr>\n<th>写法</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td>【必需】页面标题</td>\n</tr>\n<tr>\n<td>date</td>\n<td>【必需】页面创建日期</td>\n</tr>\n<tr>\n<td>type</td>\n<td>【必需】标籤、分类和友情链接三个页面需要配置</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>【可选】页面更新日期</td>\n</tr>\n<tr>\n<td>description</td>\n<td>【可选】页面描述</td>\n</tr>\n<tr>\n<td>keywords</td>\n<td>【可选】页面关键字</td>\n</tr>\n<tr>\n<td>comments</td>\n<td>【可选】显示页面评论模块 (默认 true)</td>\n</tr>\n<tr>\n<td>top_img</td>\n<td>【可选】页面顶部图片</td>\n</tr>\n<tr>\n<td>mathjax</td>\n<td>【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td>\n</tr>\n<tr>\n<td>katex</td>\n<td>【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td>\n</tr>\n<tr>\n<td>aside</td>\n<td>【可选】显示侧边栏 (默认 true)</td>\n</tr>\n<tr>\n<td>aplayer</td>\n<td>【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td>\n</tr>\n<tr>\n<td>highlight_shrink</td>\n<td>【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配</td>\n</tr>\n</tbody></table>\n<h2 id=\"Post-Front-matter\"><a href=\"#Post-Front-matter\" class=\"headerlink\" title=\"Post Front-matter\"></a>Post Front-matter</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title:</span><br><span class=\"line\">date:</span><br><span class=\"line\">updated:</span><br><span class=\"line\">tags:</span><br><span class=\"line\">categories:</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">description:</span><br><span class=\"line\">top_img:</span><br><span class=\"line\">comments：</span><br><span class=\"line\">cover:  </span><br><span class=\"line\">toc:  </span><br><span class=\"line\">toc_number:</span><br><span class=\"line\">auto_open:</span><br><span class=\"line\">copyright:</span><br><span class=\"line\">copyright_author:</span><br><span class=\"line\">copyright_author_href:</span><br><span class=\"line\">copyright_url:</span><br><span class=\"line\">copyright_info:</span><br><span class=\"line\">mathjax:</span><br><span class=\"line\">katex:</span><br><span class=\"line\">aplayer：</span><br><span class=\"line\">highlight_shrink：</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>写法</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td>【必需】文章标题</td>\n</tr>\n<tr>\n<td>date</td>\n<td>【必需】文章创建日期</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>【可选】文章更新日期</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>【可选】文章标籤</td>\n</tr>\n<tr>\n<td>categories</td>\n<td>【可选】文章分类</td>\n</tr>\n<tr>\n<td>keywords</td>\n<td>【可选】文章关键字</td>\n</tr>\n<tr>\n<td>description</td>\n<td>【可选】文章描述</td>\n</tr>\n<tr>\n<td>top_img</td>\n<td>【可选】文章顶部图片</td>\n</tr>\n<tr>\n<td>cover</td>\n<td>【可选】文章缩略图 (如果没有设置 top_img, 文章页顶部将显示缩略图，可设为 false / 图</td>\n</tr>\n<tr>\n<td>comments</td>\n<td>【可选】显示文章评论模块 (默认 true)</td>\n</tr>\n<tr>\n<td>toc</td>\n<td>【可选】显示文章 TOC (默认为设置中 toc 的 enable 配置)</td>\n</tr>\n<tr>\n<td>toc_number</td>\n<td>【可选】显示 toc_number (默认为设置中 toc 的 number 配置)</td>\n</tr>\n<tr>\n<td>auto_open</td>\n<td>【可选】是否自动打开 TOC (默认为设置中 toc 的 auto_open 配置)</td>\n</tr>\n<tr>\n<td>copyright</td>\n<td>【可选】显示文章版权模块 (默认为设置中 post_copyright 的 enable 配置)</td>\n</tr>\n<tr>\n<td>copyright_author</td>\n<td>【可选】文章版权模块的文章作者</td>\n</tr>\n<tr>\n<td>copyright_author_href</td>\n<td>【可选】文章版权模块的文章作者链接</td>\n</tr>\n<tr>\n<td>copyright_url</td>\n<td>【可选】文章版权模块的文章连结链接</td>\n</tr>\n<tr>\n<td>copyright_info</td>\n<td>【可选】文章版权模块的版权声明文字</td>\n</tr>\n<tr>\n<td>mathjax</td>\n<td>【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td>\n</tr>\n<tr>\n<td>katex</td>\n<td>【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td>\n</tr>\n<tr>\n<td>aplayer</td>\n<td>【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td>\n</tr>\n<tr>\n<td>highlight_shrink</td>\n<td>【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</td>\n</tr>\n</tbody></table>\n<h1 id=\"插入视频\"><a href=\"#插入视频\" class=\"headerlink\" title=\"插入视频\"></a>插入视频</h1><div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n    <iframe src=\"//player.bilibili.com/player.html?aid=77217003&bvid=BV1XJ411X7Ud&cid=132187550&page=101\"  scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"></iframe>\n</div>\n\n\n","categories":["个人博客"]},{"title":"地平线：零之曙光","url":"/2020/08/15/%E5%9C%B0%E5%B9%B3%E7%BA%BF%EF%BC%9A%E9%9B%B6%E4%B9%8B%E6%9B%99%E5%85%89/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"图集\"><a href=\"#图集\" class=\"headerlink\" title=\"图集\"></a>图集</h1><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/170222/316-1F222162218.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/170222/316-1F222162217.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/170222/316-1F222162216-50.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/170222/316-1F222162215.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/170222/316-1F222162214-50.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/170222/316-1F222162214.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/170222/316-1F222162216.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/160621/317-160621135640.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/160621/317-160621135641-50.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/160621/317-160621135642.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/160621/317-160621135643.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/160621/317-160621135643-50.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/160621/317-160621135644.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/160621/317-160621135405.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/160621/317-160621135407.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/160621/317-160621135407-50.jpg\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img.3dmgame.com/uploads/allimg/160621/317-160621135408.jpg\" alt=\"\"></p>\n<h1 id=\"原声带\"><a href=\"#原声带\" class=\"headerlink\" title=\"原声带\"></a>原声带</h1><p><a href=\"http://pan.baidu.com/s/1eS9T9HC\" target=\"_blank\" rel=\"noopener\">http://pan.baidu.com/s/1eS9T9HC</a></p>\n<p>或</p>\n<p><a href=\"https://dl2.wdk6534.com/Laosiji/3DMGAME-Horizon_Zero_Dawn_(Original_Soundtrack)-WEB-2017[320Kbps].rar\" target=\"_blank\" rel=\"noopener\">https://dl2.wdk6534.com/Laosiji/3DMGAME-Horizon_Zero_Dawn_(Original_Soundtrack)-WEB-2017[320Kbps].rar</a></p>\n","categories":["游戏"],"tags":["游戏"]},{"title":"小镇做题家没错，错的是世界","url":"/2020/07/29/%E5%B0%8F%E9%95%87%E5%81%9A%E9%A2%98%E5%AE%B6/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a><strong>1</strong></h1><p>最近小镇做题家这个词冒了出来，作为后浪的反面。</p>\n<p>小镇做题家代表了那些出身贫苦，读书努力，依靠高考进入了一所比较好的大学，有一个相对不错的学历，但面对社会依然单薄无力拘谨的形象。</p>\n<p>我回想自己的生活中，似乎是遇到过这些朋友的。</p>\n<p>读中学时有一个同学，努力上进，埋头苦读，在我们翘课打球的时候，他在做题，在我们网吧CS五黑的时候，他在做题，在我们唱K宵夜吹牛皮的时候，他还在写题，他是那种典型的别人家的孩子，老师的最爱，校长的希望。</p>\n<p>有一说一，我是校长我也喜欢人家，毕竟这是行走的KPI。</p>\n<p>人人都爱KPI。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://p3-tt.byteimg.com/large/pgc-image/3d8ffe037c294ecb97e94a5a972f2616?from=pc\" alt=\"小镇做题家没错，错的是世界\"></p>\n<p>工作之后，我遇到过这么一个实习生，说是实习生，但是看起来似乎比我还要大，半路从生物转行计算机，某985毕业，浑身上下带着一股“老实人”的气息，正儿八经的老实人。</p>\n<p>我说的不是牛顿老师。</p>\n<p>只是这人虽然老实，但老实的并不可爱，也不好用。</p>\n<p>脑回路异乎寻常的直，跟他沟通存在一定门槛，对于工作难以变通，同时也不知道到处去问，我不认为这是他的错误，毕竟谁也不敢说刚上班就有经验，但确实也不喜欢和他合作，因为会给我自己增加非常多的工作量。</p>\n<p>他的野心很明显，想在大城市待下来，但接人待物确实存在问题，喜欢抱怨，并且逢人就强调自己一定要留下来，所以最后尽管我给他写了转正推荐，但拒绝他来我的组，他去了别的更缺人的组，后来我离职，就断了联系。</p>\n<p>人不是坏人，也没什么坏心思，很努力，很肯付出，但有时候就是战战兢兢，不得其法。</p>\n<p>一提起小镇做题家，我第一时间就想到了他们。</p>\n<h1 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a><strong>2</strong></h1><p>小镇做题家是指那些村镇出生，学习优秀但因缺乏视野和资源导致生活不如意的青年，本质上是一种自嘲的称谓。</p>\n<p>但要区分清楚，不是所有小镇出身大城市工作的年轻人都叫小镇做题家。</p>\n<p>你小镇出身，大城市流水线拼手机，送外卖，剪头发，这叫入城务工青年。</p>\n<p>你小镇出身，娶/嫁了个富二代，从此衣食无忧，这叫人生赢家。</p>\n<p>你小镇出生，清北毕业，先上班后创业，门店开遍全国，纳斯达克上市，问鼎福布斯，这叫莫欺少年穷。</p>\n<p>你小镇出身，学校还行，工作正常，稳扎稳打，赚了点小钱，这叫芸芸众生。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://p6-tt.byteimg.com/large/pgc-image/3d20be349fdd4d298db432ed9901827d?from=pc\" alt=\"小镇做题家没错，错的是世界\"></p>\n<p>如果你仔细观察，你可以发现，小镇做题家基本包含了所有与奋斗相关的美德。</p>\n<p>尽管经济条件一般，原生家庭物质生活匮乏导致童年见识缺失，在成长路上家庭也无法提供额外的资源和助力，在初高中时依附于“题海战术”、取得优异成绩，从而脱离农村、小镇考入一流名校进入大城市。</p>\n<p>辛苦三年早起晚睡千辛万苦从小镇刷题考上大学后，才发现来自城市的同学因为丰富的教学资源，高中悠闲度过。</p>\n<p>当他们早早的觉醒危机意识，在大学里开始制定学籍计划，希望复刻自己在高中时的成功时，但发现自己思维、眼界、见识都远弱于他人。</p>\n<p>而因为教育资源的落后，以及家庭资源的局限，自己既没有同学那样悠闲的生活，除了纸面上的学习成绩之外，音乐、才艺、运动甚至连人际交往等各类技能都是欠缺的。</p>\n<p>别人的四年叫青春，他们的四年叫大学。</p>\n<p>这其实并不好笑。</p>\n<h1 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a><strong>3</strong></h1><p>小镇做题家往往入学即巅峰，然后就是被各种暴打，尤其是在面对就业时，会发现自己前四年积累的那些证书，那些学分对面试、工作没有想象中的给力。</p>\n<p>最后企业选了你那个大二就在家人帮助开始实习，做出过好几个实操项目的同学。</p>\n<p>或者更直接一些有资源的。</p>\n<p>这不能怪企业现实，毕竟公司是要赚钱的，这年头大家都不容易，很多老板其实甚至可以说是在给员工打工。</p>\n<p>不是所有人都能骗到投资人接盘的。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://p6-tt.byteimg.com/large/pgc-image/8251aec8f0384b4f801d109dc57cc514?from=pc\" alt=\"小镇做题家没错，错的是世界\"></p>\n<p>工作之后，好不容易留在了大城市，一线行业。</p>\n<p>但工作不上不下，既比不过那些资源型同学，也比不过本地城市中产。</p>\n<p>既没有六个钱包给他助力，也没有开公司的父母等着他回家继承家产。</p>\n<p>做题家们逐渐开始发现自己面临的尴尬，有的过了很久才发现自己选错了行业，浪费数年时间；</p>\n<p>有的因为谨小慎微，做事犹犹豫豫，不够机灵常常错失良机；</p>\n<p>有的做着一份没有未来的工作，因为害怕转行的风险，日渐绝望。</p>\n<p>简单的来说，在以成绩作为唯一标准的高考前阶段，他们用成绩吊打了一众同学，当高考结束开始拼实操能力的时候，他们却开始反向被世界吊打。</p>\n<p>某种程度上，这证明了地球是圆的。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://p6-tt.byteimg.com/large/pgc-image/d65766abdb7543b8960b5db1d2d186de?from=pc\" alt=\"小镇做题家没错，错的是世界\"></p>\n<h1 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4\"></a><strong>4</strong></h1><p><strong>小镇做题家真的是失败者吗？</strong></p>\n<p>很明显不是。</p>\n<p>刷题也是有门槛的，就像我，想刷题都刷不来，我当年不知道多羡慕他们。</p>\n<p>那小镇做题家是目光短浅吗？</p>\n<p>很明显也不是。</p>\n<p>小镇做题家其实早早认识到了人生的残酷和自身没有资源可以依靠这个事实，选择了“刷题”这样一条艰辛但高效的道路，并几年如一日的坚持下来，达成了目标。</p>\n<p>自制力强大，执行力爆表。</p>\n<p>刷题这件事情，可真不是谁都能搞定的。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://p6-tt.byteimg.com/large/pgc-image/85bccde2e0f9436b90c0c48da3378757?from=pc\" alt=\"小镇做题家没错，错的是世界\"></p>\n<p>能吃苦，能认识到现实，看起来是很好，但这里面会有一个负面循环。</p>\n<p>物质的匮乏，导致他们没有条件去增长见识，大量的时间在刷题上，和刷题占用了他们太多的时间资源，导致他们没有时间自行发展其他软性技能。</p>\n<p>实现人生成功→要有好学历→没钱没资源→只能刷题→刷题导致思维僵化→成为做题家→做题家难以成功。</p>\n<p>形成了一个逻辑上的死循环。</p>\n<p>出生于农村城镇，因为原生家庭物质生活匮乏，无法给做题家们带来助力。</p>\n<p>小镇做题家的名头就是这样来的。</p>\n<p>现实只能让他们刷题，不刷题没有出路，但这个社会没有给你继续刷题的机会。</p>\n<p>所以我从来不会看不起小镇做题家，因为错的不是他们，真的是这个世界。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://p6-tt.byteimg.com/large/pgc-image/277a022a7876484cae83538b37fa0140?from=pc\" alt=\"小镇做题家没错，错的是世界\"></p>\n<h1 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5\"></a><strong>5</strong></h1><p>另外，讲道理，刷题家们的失败，是相对于城市中产而言的，相对于老家的务工青年，他们的生活条件和上升通道是要强得多。</p>\n<p>导致做题家失败的原因是资源的不足+社会化程度低，可以说是非战之罪。</p>\n<p>这种资源不光是指金钱，也指人脉、信息。</p>\n<p>比如中产家庭的父母，可以在子女报考专业的时候给一些指导意见，可以给子女介绍实习，可以帮助子女内推工作。</p>\n<p>而做题家们的父母要不就是农民，要不就是小城市打工仔，别说什么给资源，别在你报专业的时候跟你憋出一句21世纪是生物的世纪就算帮忙了。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://p6-tt.byteimg.com/large/pgc-image/8cbf6f5f6de642e186e41e52a02a7dfa?from=pc\" alt=\"小镇做题家没错，错的是世界\"></p>\n<p>这是直接原因，那么根本原因是什么呢？</p>\n<p>是“信息差”。</p>\n<p>做题家们对抗人生的策略是用时间换空间。</p>\n<p>这个策略是没问题的，但问题在于，社会性的“成功”是多因素导致的，但做题家们能做的事情却是单一的。</p>\n<p>高考前成功的唯一考量因素是“成绩”，</p>\n<p>高考后最大的考量因素是“经济”，是“资源”。</p>\n<p>成绩的成功是单一的，时间只需要花在六个科目上，“经济”的成功是多因素的，你要把时间花在性价比最高的因素上。</p>\n<p>后者比前者的门槛，高了太多。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://p6-tt.byteimg.com/large/pgc-image/b05239685f94453c8ed12df16e931571?from=pc\" alt=\"小镇做题家没错，错的是世界\"></p>\n<p>打个比方，企业挑选员工的条件，是找合适的人，有过相关行业实习经验，容易沟通，实操能力强；</p>\n<p>企业晋升员工的条件是有管理能力，做出过成绩，能服众。</p>\n<p>而做题家能提供的只有，学习成绩好，善于应试。</p>\n<p>企业不需要应试能力，社会也不需要应试能力，因为这些换不来金钱。</p>\n<p>而这种信息差导致的认知的偏差，就会最终导致“努力错了方向”。</p>\n<p>产生这种“我明明已经很努力了，为什么还是这么失败”的结局。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://p1-tt.byteimg.com/large/pgc-image/f1399dbd1fad4683a6e8435987b548e9?from=pc\" alt=\"小镇做题家没错，错的是世界\"></p>\n<h1 id=\"6\"><a href=\"#6\" class=\"headerlink\" title=\"6\"></a><strong>6</strong></h1><p>做题家们痛苦的根源是跳出了自己的圈层，看到了更大的世界，而手头上的资源和以往的成功经验却难以支撑他们在正确的路上更进一步。</p>\n<p>俗话说，不努力还好，一努力才发现自己是个废物，这才是最痛苦的。</p>\n<p>但，小镇做题家是废物吗？</p>\n<p>当然不是。</p>\n<p>看一下小镇做题家的开局难度就知道。</p>\n<p>物资的匮乏，教育资源跟不上，必须靠堆时间刷题找补。</p>\n<p>出身地与外界接触少，很多人大学毕业后才第一次离开自己家的小镇眼界窄。</p>\n<p>面临学业、就业等人生重大抉择没人能够提供建议，帮自己避雷，容易进坑。</p>\n<p>没有家庭资源兜底，没有退路，容错极低，面临选择只能选择短期保底，致使长期失利。</p>\n<p>这四点加在一起堪称深渊开局，甚至如果婴儿有意识有的选，面对这种投胎都恨不得当场去世。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://p1-tt.byteimg.com/large/pgc-image/144977d0af524f9fa649dd165d27572a?from=pc\" alt=\"小镇做题家没错，错的是世界\"></p>\n<p>但人家是怎么做的？</p>\n<p>认识到了开局难度，知道自己所处的劣势，于是早早的认准了“刷题”这样一条单调高效且成功率最高的路，忍受着孤独和无奈一路杀了上去，最后顶着一身白装跟那些满身时装的rmb玩家同台竞技。</p>\n<p>在开局两只手的情况下，靠刷题刷成了社会中上水平收入，你们别笑，按绝对比例来说大部分白领学历，收入都是社会中上水平，哪怕仅在城市中，也不拖后腿。</p>\n<p>尽管做题家们经常自嘲自己被家境、社会环境、生存压力压垮，努力半生无所作为。</p>\n<p>但从绝对比例来说，小镇做题家依然是人生中的强者。</p>\n<p>强者是什么？</p>\n<p>从绝对意义来说，是强于大多数人，从相对意义来说，是强于昨天的自己。</p>\n<p>无论是哪一点，他们都做到了。</p>\n<p>尤其是考虑到他们的起点，更是值得尊敬。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://p6-tt.byteimg.com/large/pgc-image/773332dc12fd47bb9f2909980bc6a159?from=pc\" alt=\"小镇做题家没错，错的是世界\"></p>\n<h1 id=\"7\"><a href=\"#7\" class=\"headerlink\" title=\"7\"></a><strong>7</strong></h1><p>在小镇做题家这个话题底下，我看到一句话是我很讨厌的。</p>\n<p>“同样出身小镇，有的人依然对知识抱有无功利的兴趣，有的人则完全只把读书当成敲门砖。”</p>\n<p>对小镇做题家极尽鄙夷。</p>\n<p>这是一句完全正确的废话，是“何不食肉糜”的现代版本。</p>\n<p>读书如果不是作为敲门砖，那么世界上99%的人不会去读书。</p>\n<p>读书就是不如王者荣耀有趣，这很正常。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"http://p1-tt.byteimg.com/large/pgc-image/49083ade1e074fe29ce633ceb17ff9f7?from=pc\" alt=\"小镇做题家没错，错的是世界\"></p>\n<p>确实承认，书籍文化有文化传承、探索知识的作用，但在社层面上的意义在于给社会输出一批具有良好学历水平和工作能力的专向人才。</p>\n<p>对个人的意义在于让自己拥有获得工作，获得更好生活的能力。</p>\n<p>对知识抱有兴趣的完全可以自己自学，或者向着专业领域冲就行了，完全不冲突。</p>\n<p>更何况，面对一个缺乏资源独自战斗，只是为了获得跟后浪们同台竞技的年轻人，你好意思跟他说，你不要那么功利？</p>\n<p>功利有错吗？功利没错，功利是他们获得更好生活的唯一方式，功利是他们对抗这个世界的唯一方式。</p>\n<p>在你们指责别人功利前，请别忘了有许多人光是活着就已经拼尽了全力。</p>\n<p>有人耗费整个青春，只是为了证明他不比你差。</p>\n<p>谁喜欢功利的世界呢，但很多时候他们没的选。</p>\n<p>其实，我们也没得选。</p>\n","categories":["读书"]},{"title":"微信小程序云开发学习笔记（一）云数据库","url":"/2020/08/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>微信小程序和后台交互扫盲：<a href=\"https://www.bilibili.com/video/BV1jt411E7au\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1jt411E7au</a></p>\n<p>云开发：<a href=\"https://www.bilibili.com/video/BV1pE411C7Ca?from=search&amp;seid=14303234966957086491\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1pE411C7Ca?from=search&amp;seid=14303234966957086491</a></p>\n<p>云开发学习代码： D:\\code is here\\微信小程序云开发学习</p>\n<p><a href=\"https://github.com/ZhengLin-Li/learning-miniapp-coulddevelopment\" target=\"_blank\" rel=\"noopener\">https://github.com/ZhengLin-Li/learning-miniapp-coulddevelopment</a></p>\n<p>云开发配置的环境：cloud-learning</p>\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n    <iframe src=\"//player.bilibili.com/player.html?aid=71382448&bvid=BV1pE411C7Ca&cid=123683867&page=16\"  scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"></iframe>\n</div>\n\n\n<h1 id=\"云开发环境初始化准备\"><a href=\"#云开发环境初始化准备\" class=\"headerlink\" title=\"云开发环境初始化准备\"></a>云开发环境初始化准备</h1><h2 id=\"需要：\"><a href=\"#需要：\" class=\"headerlink\" title=\"需要：\"></a>需要：</h2><p>APPID</p>\n<h2 id=\"操作：\"><a href=\"#操作：\" class=\"headerlink\" title=\"操作：\"></a>操作：</h2><ol>\n<li><p>在创建项目时，填入APPID并选择不使用云函数</p>\n</li>\n<li><p>进入到开发者页面，点击左上角的云开发并选择开通</p>\n</li>\n<li><p>设置云开发环境名称，可以任意填写</p>\n</li>\n<li><p>在<code>project.config.json</code>中加入字段<code>&quot;cloudfunctionRoot&quot;:&quot;cloud&quot;</code></p>\n</li>\n<li><p>在打开的云开发控制台中点击设置，新建一个环境ID</p>\n</li>\n<li><p><code>app.js</code>中删除所有代码，只保留<code>env</code>即环境ID</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">App(&#123;</span><br><span class=\"line\">  onLaunch: function () &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;云开发环境初始化</span><br><span class=\"line\">    wx.cloud.init(&#123;</span><br><span class=\"line\">      env:&quot;cloud-learning-i44qm&quot;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200817153256182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在project.config.json中加入字段&quot;cloudfunctionRoot&quot;:&quot;cloud&quot;\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200817153332529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"app.js中删除所有代码，只保留\"></p>\n</li>\n<li><p>在根目录下创建文件夹（目录）<code>cloud</code></p>\n</li>\n</ol>\n<h1 id=\"云数据库\"><a href=\"#云数据库\" class=\"headerlink\" title=\"云数据库\"></a>云数据库</h1><h2 id=\"新增固定的数据\"><a href=\"#新增固定的数据\" class=\"headerlink\" title=\"新增固定的数据\"></a>新增固定的数据</h2><p>效果：通过点击一个按键可以向云数据库中新增固定字段的内容</p>\n<p>实现：</p>\n<ol>\n<li>在<code>index.wxml</code>中，加入如下代码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button bindtap&#x3D;&quot;addData&quot;&gt;新增数据&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>点击云开发–&gt;数据库–&gt;创建集合<code>testlist</code></li>\n<li>在<code>index.js</code>中加入如下代码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const DB &#x3D; wx.cloud.database().collection(&quot;testlist&quot;)</span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  addData()&#123;</span><br><span class=\"line\">    console.log(&#39;调用添加数据的方法&#39;)</span><br><span class=\"line\">    DB.add(&#123;</span><br><span class=\"line\">      data:&#123;</span><br><span class=\"line\">        name:&#39;panda bear&#39;,</span><br><span class=\"line\">        price:9999</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      success(res) &#123;</span><br><span class=\"line\">        console.log(&quot;成功&quot;, res)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail(res) &#123;</span><br><span class=\"line\">        console.log(&quot;失败&quot;, res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>测试：点击新增数据按钮，发现控制台上有相应输出，再进入到云开发的数据库页面，发现上述字段已新增</p>\n<h2 id=\"新增用户输入的不确定数据\"><a href=\"#新增用户输入的不确定数据\" class=\"headerlink\" title=\"新增用户输入的不确定数据\"></a>新增用户输入的不确定数据</h2><p>效果：用户通过输入想新增的数据并点击确定新增按键，即可向云数据库中新增用户想新增的数据</p>\n<p>实现：</p>\n<ol>\n<li>在<code>index.wxml</code>中加入如下代码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input placeholder&#x3D;&quot;输入名字&quot; bindinput&#x3D;&quot;addName&quot;&gt;&lt;&#x2F;input&gt;</span><br><span class=\"line\">&lt;text&gt;\\n&lt;&#x2F;text&gt;</span><br><span class=\"line\">&lt;input placeholder&#x3D;&quot;输入年龄&quot; bindinput&#x3D;&quot;addAge&quot;&gt;&lt;&#x2F;input&gt;</span><br><span class=\"line\">&lt;text&gt;\\n&lt;&#x2F;text&gt;</span><br><span class=\"line\">&lt;button bindtap&#x3D;&quot;addData&quot; type&#x3D;&quot;primary&quot;&gt;新增数据&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在<code>index.js</code>中加入如下代码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const DB &#x3D; wx.cloud.database().collection(&quot;list&quot;)</span><br><span class=\"line\">let name &#x3D; &#39;&#39;</span><br><span class=\"line\">let age &#x3D; &#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  addName(event)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;console.log(event.detail.value)</span><br><span class=\"line\">    name &#x3D; event.detail.value</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  addAge(event)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;console.log(event.detail.value)</span><br><span class=\"line\">    age &#x3D; event.detail.value</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  addData() &#123;</span><br><span class=\"line\">    console.log(&#39;调用添加数据的方法&#39;)</span><br><span class=\"line\">    DB.add(&#123;</span><br><span class=\"line\">      data: &#123;</span><br><span class=\"line\">        name: name,</span><br><span class=\"line\">        age: age</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      success(res) &#123;</span><br><span class=\"line\">        console.log(&quot;添加数据成功&quot;, res)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail(res) &#123;</span><br><span class=\"line\">        console.log(&quot;添加数据失败&quot;, res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>测试：输入数据后，点击新增数据按钮，发现控制台上有相应输出，再进入到云开发的数据库页面，发现输入的字段已新增</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200817153642239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"输入数据后，点击新增数据按钮\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/2020081715371567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"控制台上有相应输出\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200817153801918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"再进入到云开发的数据库页面，发现输入的字段已新增\"></p>\n<h2 id=\"查找已有的数据\"><a href=\"#查找已有的数据\" class=\"headerlink\" title=\"查找已有的数据\"></a>查找已有的数据</h2><p>效果：通过点击一个按键可以查询云数据库中的内容</p>\n<p>实现：</p>\n<ol>\n<li>在<code>index.wxml</code>中，加入如下代码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button bindtap&#x3D;&quot;getData&quot;&gt;查询数据&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>在<code>index.js</code>中加入如下代码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const DB &#x3D; wx.cloud.database().collection(&quot;testlist&quot;)</span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  getData() &#123;</span><br><span class=\"line\">    console.log(&#39;调用查询数据的方法&#39;)</span><br><span class=\"line\">    DB.get(&#123;</span><br><span class=\"line\">      success(res)&#123;</span><br><span class=\"line\">        console.log(&#39;查询数据成功&#39;,res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>测试：点击查询数据按钮，发现控制台上有相应输出</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDgvMTcvTkdIVHpBcVhjeXcyTXJuLnBuZw?x-oss-process=image/format,png\" alt=\"\"></p>\n<h2 id=\"通过ID删除数据\"><a href=\"#通过ID删除数据\" class=\"headerlink\" title=\"通过ID删除数据\"></a>通过ID删除数据</h2><p>效果：用户通过输入想删除数据的ID并点击确定删除按键，即可删除云数据库中用户想删除的数据</p>\n<p>实现：</p>\n<ol>\n<li>在<code>index.wxml</code>中加入如下代码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input placeholder&#x3D;&quot;要删除数据的ID&quot; bindinput&#x3D;&quot;delDataInput&quot;&gt;&lt;&#x2F;input&gt;</span><br><span class=\"line\">&lt;text&gt;\\n&lt;&#x2F;text&gt;</span><br><span class=\"line\">&lt;button bindtap&#x3D;&quot;delData&quot; type&#x3D;&quot;primary&quot;&gt;删除数据&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在<code>index.js</code>中加入如下代码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const DB &#x3D; wx.cloud.database().collection(&quot;list&quot;)</span><br><span class=\"line\">let id &#x3D; &#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  delDataInput(event)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;console.log(event.detail.value)</span><br><span class=\"line\">    id &#x3D; event.detail.value</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  delData() &#123;</span><br><span class=\"line\">    console.log(&#39;调用删除数据的方法&#39;)</span><br><span class=\"line\">    DB.doc(id).remove(&#123;</span><br><span class=\"line\">      success(res) &#123;</span><br><span class=\"line\">        console.log(&#39;删除数据成功&#39;, res.data)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>测试：输入想删除数据的ID后（注意不要带有引号””），点击确定删除按键，发现控制台上有相应输出，再进入到云开发的数据库页面，发现输入id对应的该条数据已删除<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200817154308889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"删除前\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200817154330814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"删除后\"></p>\n<h2 id=\"通过属性删除数据\"><a href=\"#通过属性删除数据\" class=\"headerlink\" title=\"通过属性删除数据\"></a>通过属性删除数据</h2><p>效果：用户通过输入想删除数据的name的值并点击确定删除按键，即可删除云数据库中用户想删除的数据</p>\n<p>实现：</p>\n<ol>\n<li>在<code>index.wxml</code>中加入如下代码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input placeholder&#x3D;&quot;输入要删除数据的name&quot; bindinput&#x3D;&quot;delDataInputName&quot;&gt;&lt;&#x2F;input&gt;</span><br><span class=\"line\">&lt;text&gt;\\n&lt;&#x2F;text&gt;</span><br><span class=\"line\">&lt;button bindtap&#x3D;&quot;delDataByProperty&quot; type&#x3D;&quot;primary&quot;&gt;通过属性删除&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在<code>index.js</code>中加入如下代码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const DB &#x3D; wx.cloud.database().collection(&quot;list&quot;)</span><br><span class=\"line\">let nameDelete &#x3D; &#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  delDataInputName(event)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;console.log(event.detail.value)</span><br><span class=\"line\">    nameDelete &#x3D; event.detail.value</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  delDataByProperty() &#123;</span><br><span class=\"line\">    console.log(&#39;调用属性删除数据的方法&#39;)</span><br><span class=\"line\">    DB.where(&#123;</span><br><span class=\"line\">      name: nameDelete</span><br><span class=\"line\">    &#125;).remove(&#123;</span><br><span class=\"line\">      success(res) &#123;</span><br><span class=\"line\">        console.log(&#39;删除数据成功&#39;, res.data)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail(res) &#123;</span><br><span class=\"line\">        console.log(&quot;删除数据失败&quot;, res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>测试：输入想删除数据的name的值后（注意不要带有引号””），点击确定删除按键，发现控制台上有相应输出，再进入到云开发的数据库页面，发现输入的想删除数据的name的值对应的该条数据已删除<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200817154708242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"删除前\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200817154729966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"删除后\"><br>另：<br>如果<code>name</code>为<code>abcd</code>的有多个数据，则全部name为abcd的数据都会被删除，如下图：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200817155152692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"全部name为abcd的数据都会被删除\"></p>\n<h2 id=\"修改更新数据\"><a href=\"#修改更新数据\" class=\"headerlink\" title=\"修改更新数据\"></a>修改更新数据</h2><p>更新有两个，updata和set，分别为：<br>update：局部更新一个或多个记录<br>set：替换更新一个记录<br>此处演示update</p>\n<p>效果：用户通过输入数据ID以及修改后的name的值并点击修改更新数据按键，即可修改更新数据云数据库中用户想修改更新数据的数据</p>\n<p>实现：</p>\n<ol>\n<li>在<code>index.wxml</code>中加入如下代码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input placeholder&#x3D;&quot;输入要更新的数据的ID&quot; bindinput&#x3D;&quot;updateID&quot;&gt;&lt;&#x2F;input&gt;</span><br><span class=\"line\">&lt;input placeholder&#x3D;&quot;输入更新后的name的值&quot; bindinput&#x3D;&quot;updateValue&quot;&gt;&lt;&#x2F;input&gt;</span><br><span class=\"line\">&lt;button bindtap&#x3D;&quot;updateData&quot; type&#x3D;&quot;primary&quot;&gt;修改更新数据&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在<code>index.js</code>中加入如下代码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const DB &#x3D; wx.cloud.database().collection(&quot;list&quot;)</span><br><span class=\"line\">let updateID &#x3D; &#39;&#39;</span><br><span class=\"line\">let updateValue &#x3D; &#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  updateID(event) &#123;</span><br><span class=\"line\">    console.log(event.detail.value)</span><br><span class=\"line\">    updateID &#x3D; event.detail.value</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  updateValue(event) &#123;</span><br><span class=\"line\">    console.log(event.detail.value)</span><br><span class=\"line\">    updateValue &#x3D; event.detail.value</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  updateData() &#123;</span><br><span class=\"line\">    console.log(&#39;调用修改更新数据的方法&#39;)</span><br><span class=\"line\">    DB.doc(updateID).update(&#123;</span><br><span class=\"line\">      data: &#123;</span><br><span class=\"line\">        name: updateValue</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      success(res) &#123;</span><br><span class=\"line\">        console.log(&#39;修改更新数据成功&#39;, res.data)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail(res) &#123;</span><br><span class=\"line\">        console.log(&quot;修改更新数据失败&quot;, res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>测试：输入数据ID以及修改后的name的值并点击修改更新数据按键，发现控制台上有相应输出，再进入到云开发的数据库页面，数据已修改更新<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200817164257555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"修改更新数据前\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200817164315864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"修改更新数据后\"></p>\n<h1 id=\"小程序云开发数据库的增删改查已经全部完成！\"><a href=\"#小程序云开发数据库的增删改查已经全部完成！\" class=\"headerlink\" title=\"小程序云开发数据库的增删改查已经全部完成！\"></a>小程序云开发数据库的增删改查已经全部完成！</h1>","categories":["微信小程序"],"tags":["入门","微信小程序云开发"]},{"title":"微信小程序云开发学习笔记（三）云存储","url":"/2020/08/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E4%BA%91%E5%AD%98%E5%82%A8/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"一、小程序云存储简介\"><a href=\"#一、小程序云存储简介\" class=\"headerlink\" title=\"一、小程序云存储简介\"></a>一、小程序云存储简介</h1><p>云开发提供了一块存储空间，提供了上传文件到云端、带权限管理的云端下载能力，开发者可以在小程序端和云函数端通过 API 使用云存储功能。</p>\n<p>在小程序端可以分别调用 <code>wx.cloud.uploadFile</code> 和 <code>wx.cloud.downloadFile</code> 完成上传和下载云文件操作</p>\n<h1 id=\"二、选择并上传图片\"><a href=\"#二、选择并上传图片\" class=\"headerlink\" title=\"二、选择并上传图片\"></a>二、选择并上传图片</h1><h2 id=\"使用的API：\"><a href=\"#使用的API：\" class=\"headerlink\" title=\"使用的API：\"></a>使用的API：</h2><ol>\n<li><p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.chooseImage.html\" target=\"_blank\" rel=\"noopener\">wx.chooseImage</a></p>\n</li>\n<li><p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/storage/uploadFile/client.uploadFile.html\" target=\"_blank\" rel=\"noopener\">wx.cloud.uploadFile</a></p>\n</li>\n</ol>\n<h2 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><h3 id=\"1-初始化云环境\"><a href=\"#1-初始化云环境\" class=\"headerlink\" title=\"1. 初始化云环境\"></a>1. 初始化云环境</h3><p>在app.js中指定云开发环境，其中<code>env</code>是你自己指定的环境ID</p>\n<p><code>app.js</code>中的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">App(&#123;</span><br><span class=\"line\">  onLaunch: function () &#123;</span><br><span class=\"line\">    wx.cloud.init(&#123;</span><br><span class=\"line\">      env: &quot;cloud-learning-i44qm&quot;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-新建一个pageuploadImg用于测试\"><a href=\"#2-新建一个pageuploadImg用于测试\" class=\"headerlink\" title=\"2. 新建一个pageuploadImg用于测试\"></a>2. 新建一个page<code>uploadImg</code>用于测试</h3><h3 id=\"3-uploadImg-wxml中，\"><a href=\"#3-uploadImg-wxml中，\" class=\"headerlink\" title=\"3. uploadImg.wxml中，\"></a>3. <code>uploadImg.wxml</code>中，</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button bindtap&#x3D;&quot;handleTap&quot;&gt;上传&lt;&#x2F;button&gt;</span><br><span class=\"line\">&lt;image src&#x3D;&quot;&#123;&#123;URL&#125;&#125;&quot;&gt;&lt;&#x2F;image&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-uploadImg-js中（版本一）\"><a href=\"#4-uploadImg-js中（版本一）\" class=\"headerlink\" title=\"4. uploadImg.js中（版本一）\"></a>4. <code>uploadImg.js</code>中（版本一）</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data:&#123;</span><br><span class=\"line\">    URL:&#39;&#39;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  handleTap() &#123;</span><br><span class=\"line\">    let that &#x3D; this</span><br><span class=\"line\">    console.log(&quot;点击了上传按钮&quot;)</span><br><span class=\"line\">    wx.chooseImage(&#123;</span><br><span class=\"line\">      count: 1,</span><br><span class=\"line\">      sizeType: [&#39;original&#39;, &#39;compressed&#39;],</span><br><span class=\"line\">      sourceType: [&#39;album&#39;, &#39;camera&#39;],</span><br><span class=\"line\">      success(res) &#123;</span><br><span class=\"line\">        console.log(&quot;选择成功&quot;, res)</span><br><span class=\"line\">        that.upload(res.tempFilePaths[0])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  upload(imgUrl) &#123;</span><br><span class=\"line\">    wx.cloud.uploadFile(&#123;</span><br><span class=\"line\">      cloudPath: new Date().getTime() +&#39;.png&#39;,    &#x2F;&#x2F;防止文件名重复，使用时间戳</span><br><span class=\"line\">      filePath: imgUrl, &#x2F;&#x2F; 文件路径</span><br><span class=\"line\">      success: res &#x3D;&gt; &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; get resource ID</span><br><span class=\"line\">        console.log(&quot;上传成功&quot;,res)</span><br><span class=\"line\">        this.setData(&#123;</span><br><span class=\"line\">          URL: res.fileID</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail: err &#x3D;&gt; &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; handle error</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-uploadImg-js中（版本二）\"><a href=\"#5-uploadImg-js中（版本二）\" class=\"headerlink\" title=\"5. uploadImg.js中（版本二）\"></a>5. <code>uploadImg.js</code>中（版本二）</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    imgURL:&#39;&#39;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  selectAndUpload() &#123;</span><br><span class=\"line\">    let that &#x3D; this</span><br><span class=\"line\">    wx.chooseImage(&#123;</span><br><span class=\"line\">      count: 1,</span><br><span class=\"line\">      sizeType: [&#39;original&#39;, &#39;compressed&#39;],</span><br><span class=\"line\">      sourceType: [&#39;album&#39;, &#39;camera&#39;],</span><br><span class=\"line\">      success: res &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(&#39;choose successfully&#39;,res)</span><br><span class=\"line\">        wx.cloud.uploadFile(&#123;</span><br><span class=\"line\">          cloudPath: new Date().getTime() + &#39;.png&#39;,</span><br><span class=\"line\">          filePath: res.tempFilePaths[0], &#x2F;&#x2F; 文件路径</span><br><span class=\"line\">          success: function (res) &#123;</span><br><span class=\"line\">            console.log(&#39;upload successfully&#39;, res)</span><br><span class=\"line\">            that.setData(&#123;</span><br><span class=\"line\">              imgURL: res.fileID</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          fail(res) &#123;</span><br><span class=\"line\">            console.log(&#39;upload failed&#39;, res)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail(res) &#123;</span><br><span class=\"line\">        console.log(&#39;choose failed&#39;, res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"6-查看控制台和模拟器，我们发现如下输出：\"><a href=\"#6-查看控制台和模拟器，我们发现如下输出：\" class=\"headerlink\" title=\"6. 查看控制台和模拟器，我们发现如下输出：\"></a>6. 查看控制台和模拟器，我们发现如下输出：</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200819222757284.png#pic_center\" alt=\"在这里插入图片描述\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/2020081923020121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"三、选择并上传视频\"><a href=\"#三、选择并上传视频\" class=\"headerlink\" title=\"三、选择并上传视频\"></a>三、选择并上传视频</h1><h2 id=\"使用的API：-1\"><a href=\"#使用的API：-1\" class=\"headerlink\" title=\"使用的API：\"></a>使用的API：</h2><ol>\n<li><p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/media/video/wx.chooseVideo.html\" target=\"_blank\" rel=\"noopener\">wx.chooseVideo</a></p>\n</li>\n<li><p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/storage/uploadFile/client.uploadFile.html\" target=\"_blank\" rel=\"noopener\">wx.cloud.uploadFile</a></p>\n</li>\n</ol>\n<h2 id=\"实现步骤-1\"><a href=\"#实现步骤-1\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><p>同上，把图片API相关代码换为如下即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">wx.chooseVideo(&#123;</span><br><span class=\"line\">  sourceType: [&#39;album&#39;,&#39;camera&#39;],</span><br><span class=\"line\">  maxDuration: 600,</span><br><span class=\"line\">  camera: &#39;back&#39;,</span><br><span class=\"line\">  success(res) &#123;</span><br><span class=\"line\">    console.log(res.tempFilePath)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"四、选择并上传多媒体文件（图片-视频）\"><a href=\"#四、选择并上传多媒体文件（图片-视频）\" class=\"headerlink\" title=\"四、选择并上传多媒体文件（图片+视频）\"></a>四、选择并上传多媒体文件（图片+视频）</h1><h2 id=\"使用的API：-2\"><a href=\"#使用的API：-2\" class=\"headerlink\" title=\"使用的API：\"></a>使用的API：</h2><ol>\n<li><p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/media/video/wx.chooseMedia.html\" target=\"_blank\" rel=\"noopener\">wx.chooseMedia</a></p>\n</li>\n<li><p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/storage/uploadFile/client.uploadFile.html\" target=\"_blank\" rel=\"noopener\">wx.cloud.uploadFile</a></p>\n</li>\n</ol>\n<h2 id=\"实现步骤-2\"><a href=\"#实现步骤-2\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><p>同上，把图片API相关代码换为如下即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">wx.chooseMedia(&#123;</span><br><span class=\"line\">  count: 9,</span><br><span class=\"line\">  mediaType: [&#39;image&#39;,&#39;video&#39;],</span><br><span class=\"line\">  sourceType: [&#39;album&#39;, &#39;camera&#39;],</span><br><span class=\"line\">  maxDuration: 300,</span><br><span class=\"line\">  camera: &#39;back&#39;,</span><br><span class=\"line\">  success(res) &#123;</span><br><span class=\"line\">    console.log(res.tempFiles.tempFilePath)</span><br><span class=\"line\">    console.log(res.tempFiles.size)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"五、实现类似朋友圈效果\"><a href=\"#五、实现类似朋友圈效果\" class=\"headerlink\" title=\"五、实现类似朋友圈效果\"></a>五、实现类似朋友圈效果</h1><h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p>编辑并share页面如下：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200820100623691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>点击分享以后，跳转到以前share过的朋友圈页面，点击左上角可以返回，如下：<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200820101912679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>本demo会用到微信小程序的云开发功能，包括云数据库，云存储</p>\n<h2 id=\"实现步骤-3\"><a href=\"#实现步骤-3\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><h3 id=\"1-云开发环境的初始化\"><a href=\"#1-云开发环境的初始化\" class=\"headerlink\" title=\"1. 云开发环境的初始化\"></a>1. 云开发环境的初始化</h3><p>详见：<a href=\"https://blog.csdn.net/Panda325/article/details/108117775\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/Panda325/article/details/108117775</a></p>\n<h3 id=\"2-新建page\"><a href=\"#2-新建page\" class=\"headerlink\" title=\"2. 新建page\"></a>2. 新建page</h3><p>新建两个page<code>share</code>和<code>pyq</code>，<code>share</code>用于编辑文案并选择配图，<code>pyq</code>用于查看以前发过的朋友圈<br><code>app.json</code>的<code>pages</code>字段如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;pages&quot;: [</span><br><span class=\"line\">    &quot;pages&#x2F;share&#x2F;share&quot;,</span><br><span class=\"line\">    &quot;pages&#x2F;pyq&#x2F;pyq&quot;</span><br><span class=\"line\">  ],</span><br></pre></td></tr></table></figure>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200820102112926.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-share页面\"><a href=\"#3-share页面\" class=\"headerlink\" title=\"3. share页面\"></a>3. <code>share</code>页面</h3><p> <code>share</code>页面从上到下依次是：多行输入框 <code>textarea</code>，选择图片的按钮 <code>button</code>，分享按钮 <code>button</code><br> <code>share.wxml</code>如下：<br> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"> &lt;textarea placeholder&#x3D;&quot;输入您的文案&quot; bindblur&#x3D;&quot;bindTextAreaBlur&quot;</span><br><span class=\"line\">    value&#x3D;&quot;&#123;&#123;details&#125;&#125;&quot; class&#x3D;&#39;text&#39;&gt; &lt;&#x2F;textarea&gt;</span><br><span class=\"line\">&lt;input&gt;\\n\\n&lt;&#x2F;input&gt;</span><br><span class=\"line\">&lt;button bindtap&#x3D;&quot;seleteAndUploadPicture&quot;&gt;</span><br><span class=\"line\">&lt;image src&#x3D;&#39;https:&#x2F;&#x2F;ss0.bdstatic.com&#x2F;70cFvHSh_Q1YnxGkpoWK1HF6hhy&#x2F;it&#x2F;u&#x3D;2444066247,3899866315&amp;fm&#x3D;26&amp;gp&#x3D;0.jpg&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class=\"line\">&lt;&#x2F;button&gt;</span><br><span class=\"line\">&lt;input&gt;\\n\\n&lt;&#x2F;input&gt;</span><br><span class=\"line\">&lt;button bindtap&#x3D;&quot;share&quot;&gt;分享&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><br>  <code>share.js</code>如下：<br> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const DB &#x3D; wx.cloud.database().collection(&quot;pyq&quot;)</span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    details: &#39;&#39;,</span><br><span class=\"line\">    imgURL: &#39;&#39;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  bindTextAreaBlur: function (e) &#123;</span><br><span class=\"line\">    console.log(e.detail.value);</span><br><span class=\"line\">    var that &#x3D; this;</span><br><span class=\"line\">    that.setData(&#123;</span><br><span class=\"line\">      details: e.detail.value</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  seleteAndUploadPicture() &#123;</span><br><span class=\"line\">    let that &#x3D; this</span><br><span class=\"line\">    wx.chooseImage(&#123;</span><br><span class=\"line\">      count: 1,</span><br><span class=\"line\">      sizeType: [&#39;original&#39;, &#39;compressed&#39;],</span><br><span class=\"line\">      sourceType: [&#39;album&#39;, &#39;camera&#39;],</span><br><span class=\"line\">      success: res &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(&#39;choose successfully&#39;, res)</span><br><span class=\"line\">        that.setData(&#123;</span><br><span class=\"line\">          imgURL: res.tempFilePaths[0]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail(res) &#123;</span><br><span class=\"line\">        console.log(&#39;choose failed&#39;, res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  share() &#123;</span><br><span class=\"line\">    console.log(&#39;调用share的方法&#39;)</span><br><span class=\"line\">    let that &#x3D; this</span><br><span class=\"line\">    wx.cloud.uploadFile(&#123;</span><br><span class=\"line\">      cloudPath: new Date().getTime() + &#39;.png&#39;,</span><br><span class=\"line\">      filePath: this.data.imgURL, &#x2F;&#x2F; 文件路径</span><br><span class=\"line\">      success: function (res) &#123;</span><br><span class=\"line\">        console.log(&#39;upload successfully&#39;, res)</span><br><span class=\"line\">        that.setData(&#123;</span><br><span class=\"line\">          imgURL: res.fileID</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail(res) &#123;</span><br><span class=\"line\">        console.log(&#39;upload failed&#39;, res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    DB.add(&#123;</span><br><span class=\"line\">      data: &#123;</span><br><span class=\"line\">        descption: this.data.details,</span><br><span class=\"line\">        imgURL: this.data.imgURL</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      success(res) &#123;</span><br><span class=\"line\">        console.log(&quot;share成功&quot;, res)</span><br><span class=\"line\">        wx.navigateTo(&#123;</span><br><span class=\"line\">          url: &quot;..&#x2F;..&#x2F;pages&#x2F;pyq&#x2F;pyq&quot;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        wx.showToast(&#123;</span><br><span class=\"line\">          title: &#39;成功&#39;,</span><br><span class=\"line\">          icon: &#39;success&#39;,</span><br><span class=\"line\">          duration: 2000</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail(res) &#123;</span><br><span class=\"line\">        console.log(&quot;share失败&quot;, res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br>  <code>share.wxss</code>如下：<br> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text&#123;</span><br><span class=\"line\">  &#x2F;* height: 100rpx;</span><br><span class=\"line\">  line-height: 100rpx; *&#x2F;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  font-size: 60rpx;</span><br><span class=\"line\">  background-color: #bfa;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-pyq页面\"><a href=\"#4-pyq页面\" class=\"headerlink\" title=\"4. pyq页面\"></a>4. <code>pyq</code>页面</h3><p> <code>pyq.wxml</code>如下：<br> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;view wx:for&#x3D;&quot;&#123;&#123;array&#125;&#125;&quot;&gt;</span><br><span class=\"line\">&lt;view&gt;&#123;&#123;index&#125;&#125; : &#123;&#123;item.descption&#125;&#125;&lt;&#x2F;view&gt;</span><br><span class=\"line\">&lt;image src&#x3D;&quot;&#123;&#123;item.imgURL&#125;&#125;&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class=\"line\">&lt;view&gt;\\n&lt;&#x2F;view&gt;</span><br><span class=\"line\">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><br>  <code>pyq.js</code>如下：<br> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const DB &#x3D; wx.cloud.database().collection(&quot;pyq&quot;)</span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    array: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onLoad() &#123;</span><br><span class=\"line\">    let that &#x3D; this</span><br><span class=\"line\">    DB.get(&#123;</span><br><span class=\"line\">      success(res) &#123;</span><br><span class=\"line\">        that.setData(&#123;</span><br><span class=\"line\">          array: res.data</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        for (let i &#x3D; 0; i &lt; res.data.length; i++) &#123;</span><br><span class=\"line\">          console.log(res.data[i].descption)</span><br><span class=\"line\">          console.log(res.data[i].imgURL)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n","categories":["微信小程序"],"tags":["入门","微信小程序云开发"]},{"title":"微信小程序云开发学习笔记（二）云函数","url":"/2020/08/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BA%91%E5%87%BD%E6%95%B0/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"一、创建一个云开发的小程序\"><a href=\"#一、创建一个云开发的小程序\" class=\"headerlink\" title=\"一、创建一个云开发的小程序\"></a>一、创建一个云开发的小程序</h1><h2 id=\"1-如下图所示创建小程序\"><a href=\"#1-如下图所示创建小程序\" class=\"headerlink\" title=\"1. 如下图所示创建小程序\"></a>1. 如下图所示创建小程序</h2><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818084851626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-删除无关文件\"><a href=\"#2-删除无关文件\" class=\"headerlink\" title=\"2. 删除无关文件\"></a>2. 删除无关文件</h2><p>删除前：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/2020081808502252.png#pic_center\" alt=\"在这里插入图片描述\"><br>删除后：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818085156316.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-删除无关代码\"><a href=\"#3-删除无关代码\" class=\"headerlink\" title=\"3. 删除无关代码\"></a>3. 删除无关代码</h2><p><code>index.wxml</code> <code>index.wxss</code> 内的代码全部清空，<code>index.js</code>保留如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818085442731.png#pic_center\" alt=\"在这里插入图片描述\"><br><code>app.json</code>删除无关代码，如下：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818085748146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"4-配置云函数存储目录\"><a href=\"#4-配置云函数存储目录\" class=\"headerlink\" title=\"4. 配置云函数存储目录\"></a>4. 配置云函数存储目录</h2><p>在<code>project.config.json</code>中新增如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;cloudfunctionRoot&quot;:&quot;cloud&quot;,</span><br></pre></td></tr></table></figure>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818085851769.png#pic_center\" alt=\"在这里插入图片描述\"><br>在根目录下创建同名文件夹，发现其有云朵标识<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818085949202.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"5-云开发环境初始化\"><a href=\"#5-云开发环境初始化\" class=\"headerlink\" title=\"5. 云开发环境初始化\"></a>5. 云开发环境初始化</h2><p>点击云开发—&gt;设置，复制你的环境ID<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818090314311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>在<code>app.js</code>中，删除所有代码，并新增如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">App(&#123;</span><br><span class=\"line\">  onLaunch: function () &#123;</span><br><span class=\"line\">    wx.cloud.init(&#123;</span><br><span class=\"line\">      env:&quot;cloud-learning-i44qm&quot;&#x2F;&#x2F;你的环境ID</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818092006170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"6-创建并上传一个云函数\"><a href=\"#6-创建并上传一个云函数\" class=\"headerlink\" title=\"6. 创建并上传一个云函数\"></a>6. 创建并上传一个云函数</h2><p>我们以最简单的求和函数为例<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818092045766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>输入<code>add</code>并回车<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818092133669.png#pic_center\" alt=\"在这里插入图片描述\"><br>在上图的<code>index.js</code>中改变代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 云函数入口文件</span><br><span class=\"line\">const cloud &#x3D; require(&#39;wx-server-sdk&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">cloud.init()</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 云函数入口函数</span><br><span class=\"line\">exports.main &#x3D; async (event, context) &#x3D;&gt; &#123;</span><br><span class=\"line\">  let a &#x3D; event.a;</span><br><span class=\"line\">  let b &#x3D; event.b;</span><br><span class=\"line\">  return a+b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>写完代码后，记得 Ctrl+s 保存，然后点击如下图所示：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818092500381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>出现下图，则上传成功<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818092523660.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"7-使用云函数\"><a href=\"#7-使用云函数\" class=\"headerlink\" title=\"7. 使用云函数\"></a>7. 使用云函数</h2><p>以下皆在page下的index页面操作<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818093124592.png#pic_center\" alt=\"在这里插入图片描述\"><br><code>index.wxml</code>中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button bindtap&#x3D;&quot;getSum&quot;&gt;云函数的求和运算&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>\n<p><code>index.js</code>中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  getSum() &#123;</span><br><span class=\"line\">    wx.cloud.callFunction(&#123;</span><br><span class=\"line\">      name:&quot;add&quot;,</span><br><span class=\"line\">      data:&#123;</span><br><span class=\"line\">        a:5,</span><br><span class=\"line\">        b:6</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      success(res)&#123;</span><br><span class=\"line\">        console.log(&quot;请求成功！&quot;, res)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail(res)&#123;</span><br><span class=\"line\">        console.log(&quot;请求失败！&quot;,res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>测试云函数调用是否成功<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818093350787.png#pic_center\" alt=\"在这里插入图片描述\"><h2 id=\"8-进阶测试\"><a href=\"#8-进阶测试\" class=\"headerlink\" title=\"8. 进阶测试\"></a>8. 进阶测试</h2><code>index.wxml</code>中<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input bindinput&#x3D;&quot;handleInput1&quot; placeholder&#x3D;&quot;数字1&quot;&gt;&lt;&#x2F;input&gt;</span><br><span class=\"line\">&lt;input bindinput&#x3D;&quot;handleInput2&quot; placeholder&#x3D;&quot;数字2&quot;&gt;&lt;&#x2F;input&gt;</span><br><span class=\"line\">&lt;button bindtap&#x3D;&quot;getSum&quot;&gt;云函数的求和运算&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>\n<code>index.js</code>中<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let a &#x3D; 0</span><br><span class=\"line\">let b &#x3D; 0</span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  handleInput1(event) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;console.log(event.detail.value)</span><br><span class=\"line\">    a &#x3D; event.detail.value</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  handleInput2(event) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;console.log(event.detail.value)</span><br><span class=\"line\">    b &#x3D; event.detail.value</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  getSum() &#123;</span><br><span class=\"line\">    wx.cloud.callFunction(&#123;</span><br><span class=\"line\">      name: &quot;add&quot;,</span><br><span class=\"line\">      data: &#123;</span><br><span class=\"line\">        a: a - &#39;&#39;,</span><br><span class=\"line\">        b: b - &#39;&#39;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      success(res) &#123;</span><br><span class=\"line\">        console.log(&quot;请求成功！&quot;, res)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail(res) &#123;</span><br><span class=\"line\">        console.log(&quot;请求失败！&quot;, res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818094114663.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/2020081809405454.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"二、使用云函数获取用户openid\"><a href=\"#二、使用云函数获取用户openid\" class=\"headerlink\" title=\"二、使用云函数获取用户openid\"></a>二、使用云函数获取用户openid</h1><h2 id=\"1-创建一个新的页面getopenid\"><a href=\"#1-创建一个新的页面getopenid\" class=\"headerlink\" title=\"1. 创建一个新的页面getopenid\"></a>1. 创建一个新的页面<code>getopenid</code></h2><p>如下图：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818095349654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-创建云函数getopenid\"><a href=\"#2-创建云函数getopenid\" class=\"headerlink\" title=\"2. 创建云函数getopenid\"></a>2. 创建云函数<code>getopenid</code></h2><p>里面的代码不用改动，使用默认的就可以<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818095617698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-getopenid-wxml\"><a href=\"#3-getopenid-wxml\" class=\"headerlink\" title=\"3. getopenid.wxml\"></a>3. <code>getopenid.wxml</code></h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button bindtap&#x3D;&quot;getopenid&quot;&gt;getopenid&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-getopenid-js\"><a href=\"#4-getopenid-js\" class=\"headerlink\" title=\"4. getopenid.js\"></a>4. <code>getopenid.js</code></h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  onLoad()&#123;</span><br><span class=\"line\">    wx.cloud.callFunction(&#123;</span><br><span class=\"line\">      name:&quot;getopenid&quot;,</span><br><span class=\"line\">      data:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      success(res) &#123;</span><br><span class=\"line\">        console.log(&quot;获取openid成功！&quot;, res)</span><br><span class=\"line\">        console.log(&quot;openid是：&quot;, res.result.openid)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail(res) &#123;</span><br><span class=\"line\">        console.log(&quot;获取openid失败！&quot;, res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-测试\"><a href=\"#5-测试\" class=\"headerlink\" title=\"5. 测试\"></a>5. 测试</h2><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818095738693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"二、通过云数据库API获取云数据库数据\"><a href=\"#二、通过云数据库API获取云数据库数据\" class=\"headerlink\" title=\"二、通过云数据库API获取云数据库数据\"></a>二、通过云数据库API获取云数据库数据</h1><h2 id=\"1-新建测试数据\"><a href=\"#1-新建测试数据\" class=\"headerlink\" title=\"1. 新建测试数据\"></a>1. 新建测试数据</h2><p>在云数据库中随便新建几条数据<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818101955175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-新建测试页面\"><a href=\"#2-新建测试页面\" class=\"headerlink\" title=\"2. 新建测试页面\"></a>2. 新建测试页面</h2><p>新建页面<code>cloudfunctionVSdatabaseAPI</code><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818101632569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-创建测试按键\"><a href=\"#3-创建测试按键\" class=\"headerlink\" title=\"3. 创建测试按键\"></a>3. 创建测试按键</h2><p><code>cloudfunctionVSdatabaseAPI.wxml</code>中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button bindtap&#x3D;&quot;shujuku&quot;&gt;数据库API获取数据&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>\n<p><code>cloudfunctionVSdatabaseAPI.js</code>中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  shujuku()&#123;</span><br><span class=\"line\">    wx.cloud.database().collection(&quot;pk&quot;).get(&#123;</span><br><span class=\"line\">      success(res) &#123;</span><br><span class=\"line\">        console.log(&quot;数据库API获取数据成功！&quot;, res)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail(res) &#123;</span><br><span class=\"line\">        console.log(&quot;数据库API获取数据失败！&quot;, res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4. 测试\"></a>4. 测试</h2><p>点击按键<code>数据库API获取数据</code>，发现控制台如下输出：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818103343412.png#pic_center\" alt=\"在这里插入图片描述\"><br>此时，我们发现数据库中明明有数据但通过数据库API获取不到，为什么呢？<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818103445206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>原因是权限不够，如果我们更新权限，让所有用户都可以获取，会怎么样呢？<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818103554484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818103609591.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"5-结论\"><a href=\"#5-结论\" class=\"headerlink\" title=\"5. 结论\"></a>5. 结论</h2><p>可以看到，我们现在获取到了想要的数据，我们也发现了通过数据库API获取数据的局限性。</p>\n<h1 id=\"三、通过云函数获取云数据库数据\"><a href=\"#三、通过云函数获取云数据库数据\" class=\"headerlink\" title=\"三、通过云函数获取云数据库数据\"></a>三、通过云函数获取云数据库数据</h1><h2 id=\"1-云数据库就可以直接获取数据库里的数据，为什么这么做？\"><a href=\"#1-云数据库就可以直接获取数据库里的数据，为什么这么做？\" class=\"headerlink\" title=\"1. 云数据库就可以直接获取数据库里的数据，为什么这么做？\"></a>1. 云数据库就可以直接获取数据库里的数据，为什么这么做？</h2><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818100024885.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-说明\"><a href=\"#2-说明\" class=\"headerlink\" title=\"2. 说明\"></a>2. 说明</h2><p>本例延续上例中的<code>cloudfunctionVSdatabaseAPI</code>页面</p>\n<h2 id=\"3-创建云函数\"><a href=\"#3-创建云函数\" class=\"headerlink\" title=\"3. 创建云函数\"></a>3. 创建云函数</h2><p>利用上述方法创建云函数<code>cloudfunctionVSdatabaseAPI</code><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818104300955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>云函数<code>cloudfunctionVSdatabaseAPI.js</code>中的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 云函数入口文件</span><br><span class=\"line\">const cloud &#x3D; require(&#39;wx-server-sdk&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">cloud.init()</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 云函数入口函数</span><br><span class=\"line\">exports.main &#x3D; async (event, context) &#x3D;&gt; &#123;</span><br><span class=\"line\">  return cloud.database().collection(&quot;pk&quot;).get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记得上传并部署，注意这里没有<code>wx.</code><br>云函数调用：<code>cloud.database().collection(&quot;pk&quot;).get();</code><br>本地调用：<code>wx.cloud.database().collection(&quot;pk&quot;).get();</code></p>\n<h2 id=\"4-创建测试按键\"><a href=\"#4-创建测试按键\" class=\"headerlink\" title=\"4. 创建测试按键\"></a>4. 创建测试按键</h2><p><code>cloudfunctionVSdatabaseAPI.wxml</code>中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button bindtap&#x3D;&quot;shujuku&quot;&gt;数据库API获取数据&lt;&#x2F;button&gt;</span><br><span class=\"line\">&lt;button bindtap&#x3D;&quot;yunhanshu&quot;&gt;云函数获取数据&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>\n<p><code>cloudfunctionVSdatabaseAPI.js</code>中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  shujuku()&#123;</span><br><span class=\"line\">    wx.cloud.database().collection(&quot;pk&quot;).get(&#123;</span><br><span class=\"line\">      success(res) &#123;</span><br><span class=\"line\">        console.log(&quot;数据库API获取数据成功！&quot;, res)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail(res) &#123;</span><br><span class=\"line\">        console.log(&quot;数据库API获取数据失败！&quot;, res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  yunhanshu()&#123;</span><br><span class=\"line\">    wx.cloud.callFunction(&#123;</span><br><span class=\"line\">      name:&quot;cloudfunctionVSdatabaseAPI&quot;,</span><br><span class=\"line\">      success(res) &#123;</span><br><span class=\"line\">        console.log(&quot;云函数获取数据成功！&quot;, res)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail(res) &#123;</span><br><span class=\"line\">        console.log(&quot;云函数获取数据失败！&quot;, res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-测试-1\"><a href=\"#5-测试-1\" class=\"headerlink\" title=\"5. 测试\"></a>5. 测试</h2><p>首先更改云数据库的权限为仅创建者可读写<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818105244679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"><br>点击两个按键<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818105303589.png#pic_center\" alt=\"在这里插入图片描述\"><br>控制台输出如下：同样的，数据库API不可以获取到数据，而云函数可以<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818105333789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"6-注意事项\"><a href=\"#6-注意事项\" class=\"headerlink\" title=\"6. 注意事项\"></a>6. 注意事项</h2><p>如果你的云开发有多套环境，在初始化时应指明，如下：<br>在下图文件中<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200818105730727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbmRhMzI1,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 云函数入口文件</span><br><span class=\"line\">const cloud &#x3D; require(&#39;wx-server-sdk&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">cloud.init(&#123;</span><br><span class=\"line\">  env: &quot;cloud-learning-i44qm&quot;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 云函数入口函数</span><br><span class=\"line\">exports.main &#x3D; async (event, context) &#x3D;&gt; &#123;</span><br><span class=\"line\">  return cloud.database().collection(&quot;pk&quot;).get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-云函数调用数据库的应用\"><a href=\"#7-云函数调用数据库的应用\" class=\"headerlink\" title=\"7. 云函数调用数据库的应用\"></a>7. 云函数调用数据库的应用</h2><p>短信发送，邮件发送，复杂数据运算</p>\n<p>我的邮箱：<a href=\"mailto:1125806272@qq.com\">1125806272@qq.com</a><br>我的博客：<a href=\"http://9pshr3.coding-pages.com/\">http://9pshr3.coding-pages.com/</a><br>或<a href=\"https://zhenglin-li.github.io/\" target=\"_blank\" rel=\"noopener\">https://zhenglin-li.github.io/</a><br>我的csdn：<a href=\"https://me.csdn.net/Panda325\" target=\"_blank\" rel=\"noopener\">https://me.csdn.net/Panda325</a><br>我的简书：<a href=\"https://www.jianshu.com/u/e2d945027d3f\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/u/e2d945027d3f</a><br>我的今日头条：<a href=\"https://www.toutiao.com/c/user/4004188138/#mid=1592553312231438\" target=\"_blank\" rel=\"noopener\">https://www.toutiao.com/c/user/4004188138/#mid=1592553312231438</a><br>我的博客园：<a href=\"https://www.cnblogs.com/zhenglin-li/\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhenglin-li/</a></p>\n","categories":["微信小程序"],"tags":["入门","微信小程序云开发"]},{"title":"微信小程序黑马优购（一）","url":"/2020/06/25/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%BB%91%E9%A9%AC%E4%BC%98%E8%B4%AD%EF%BC%88%E4%B8%80%EF%BC%89/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>本篇博客将实时更新我学习使用微信小程序搭建范例黑马优购的过程。</p>\n<p>教程地址：<a href=\"https://www.bilibili.com/video/BV1nE41117BQ?p=47\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1nE41117BQ?p=47</a></p>\n<p>参考文档：<a href=\"https://www.showdoc.cc/128719739414963\" target=\"_blank\" rel=\"noopener\">https://www.showdoc.cc/128719739414963</a></p>\n<h2 id=\"一、-新建小程序项目\"><a href=\"#一、-新建小程序项目\" class=\"headerlink\" title=\"一、 新建小程序项目\"></a>一、 新建小程序项目</h2><p>打开微信开发者工具，新建小程序项目，然后执行如下操作：</p>\n<ol>\n<li><p>app.json中删除”pages/logs/logs”</p>\n</li>\n<li><p>app.json中的window字段改动如下：<code>&quot;navigationBarTitleText&quot;: &quot;黑马优购&quot;</code></p>\n</li>\n<li><p>pages中logs’文件夹删除</p>\n</li>\n<li><p>app.wxss中删除全部内容</p>\n</li>\n<li><p>app.js中删除全部代码，并在vscode中输入wx-app，即可自动补全所需必要代码，再删除globleData</p>\n</li>\n<li><p>pages中index.wxml, index.wxss删除全部语句, index.js中保留必要语句，同上在vscode中输入wx-page</p>\n</li>\n<li><p>pages/index/index.json中，新增如下：<code>&quot;navigationBarTitleText&quot;: &quot;优购首页&quot;</code></p>\n</li>\n<li><p>unils文件夹删除</p>\n<p>至此，目录结构已无冗余，接下来我们新增项目必要的文件夹和文件</p>\n</li>\n</ol>\n<p>##　二、 搭建目录结构</p>\n<p>把目录结构改为如下图所示：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/06/28/49GKD6VP7lmRfEo.png\" alt=\"image-20200625205252095\"></p>\n<p>各个目录的作用如下：</p>\n<ol>\n<li>style： 存放公共样式</li>\n<li>components： 存放组件</li>\n<li>lib： 存放第三方库</li>\n<li>untils： 自己的帮助库</li>\n<li>request： 自己的借口帮助库</li>\n</ol>\n<h2 id=\"三、-搭建项目的页面\"><a href=\"#三、-搭建项目的页面\" class=\"headerlink\" title=\"三、 搭建项目的页面\"></a>三、 搭建项目的页面</h2><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/06/28/SZEYAydNDWfLqnK.png\" alt=\"image-20200625210001721\"></p>\n<p>在app.json中，修改pages字段，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;pages&quot;: [ &quot;pages&#x2F;index&#x2F;index&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;pages&#x2F;category&#x2F;index&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;pages&#x2F;goods_list&#x2F;index &quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;pages&#x2F;goods_detail&#x2F;index &quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;pages&#x2F;cart&#x2F;index&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;pages&#x2F;collect&#x2F;index&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;pages&#x2F;order&#x2F;index&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;pages&#x2F;search&#x2F;index&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;pages&#x2F;user&#x2F;index&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;pages&#x2F;feedback&#x2F;index&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;pages&#x2F;login&#x2F;index&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;pages&#x2F;auth&#x2F;index&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;pages&#x2F;pay&#x2F;index&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"> ],</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、-引入字体图标\"><a href=\"#四、-引入字体图标\" class=\"headerlink\" title=\"四、 引入字体图标\"></a>四、 引入字体图标</h2><ol>\n<li><p>打开阿里巴巴字体图标库，地址<a href=\"https://www.iconfont.cn/，选择图标后加入购物车。![image-20200625212648119](https://i.loli.net/2020/06/28/WEayt6IYfjlrzQD.png)\" target=\"_blank\" rel=\"noopener\">https://www.iconfont.cn/，选择图标后加入购物车。![image-20200625212648119](https://i.loli.net/2020/06/28/WEayt6IYfjlrzQD.png)</a></p>\n</li>\n<li><p>复制下图中链接在浏览器中打开，页面打开后复制页面内所有的内容。</p>\n</li>\n<li><p>在style中新建iconfont.wxss,粘贴刚才复制的全部内容。</p>\n</li>\n<li><p>在app.wxss中导入字体图标，app.wxss加入如下代码<code>@import &quot;./styles/iconfont.wxss&quot;;</code></p>\n</li>\n<li><p>用法测试：在pages/index/index.wxml中输入如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;view&gt;首页\t</span><br><span class=\"line\">\t&lt;text class&#x3D;&quot;iconfont incon-shoucang1&quot;&gt;&lt;&#x2F;text&gt;</span><br><span class=\"line\">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 五、 搭建项目tabber结构</span><br><span class=\"line\"></span><br><span class=\"line\">1. 在app.json的window字段同层级下新增如下代码：</span><br><span class=\"line\"></span><br><span class=\"line\">   &#96;&#96;&#96; </span><br><span class=\"line\">   &quot;tabBar&quot;: &#123;</span><br><span class=\"line\">       &quot;color&quot;: &quot;#999&quot;,</span><br><span class=\"line\">       &quot;selectedColor&quot;: &quot;#ff2d4a&quot;,</span><br><span class=\"line\">       &quot;backgroundColor&quot;: &quot;#fafafa&quot;,</span><br><span class=\"line\">       &quot;position&quot;: &quot;bottom&quot;,</span><br><span class=\"line\">       &quot;borderStyle&quot;: &quot;black&quot;,</span><br><span class=\"line\">       &quot;list&quot;: [</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           &quot;pagePath&quot;: &quot;pages&#x2F;index&#x2F;index&quot;,</span><br><span class=\"line\">           &quot;text&quot;: &quot;首页&quot;,</span><br><span class=\"line\">           &quot;iconPath&quot;: &quot;icons&#x2F;home.png&quot;,</span><br><span class=\"line\">           &quot;selectedIconPath&quot;: &quot;icons&#x2F;home1.png&quot;</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           &quot;pagePath&quot;: &quot;pages&#x2F;category&#x2F;index&quot;,</span><br><span class=\"line\">           &quot;text&quot;: &quot;分类&quot;,</span><br><span class=\"line\">           &quot;iconPath&quot;: &quot;icons&#x2F;cart.png&quot;,</span><br><span class=\"line\">           &quot;selectedIconPath&quot;: &quot;icons&#x2F;cart1.png&quot;</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           &quot;pagePath&quot;: &quot;pages&#x2F;cart&#x2F;index&quot;,</span><br><span class=\"line\">           &quot;text&quot;: &quot;购物车&quot;,</span><br><span class=\"line\">           &quot;iconPath&quot;: &quot;icons&#x2F;category.png&quot;,</span><br><span class=\"line\">           &quot;selectedIconPath&quot;: &quot;icons&#x2F;category1.png&quot;</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           &quot;pagePath&quot;: &quot;pages&#x2F;user&#x2F;index&quot;,</span><br><span class=\"line\">           &quot;text&quot;: &quot;我的&quot;,</span><br><span class=\"line\">           &quot;iconPath&quot;: &quot;icons&#x2F;me.png&quot;,</span><br><span class=\"line\">           &quot;selectedIconPath&quot;: &quot;icons&#x2F;me1.png&quot;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       ]</span><br><span class=\"line\">     &#125;,</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>各字段说明详见开发者文档。</p>\n</li>\n</ol>\n<h2 id=\"六、初始化页面样式\"><a href=\"#六、初始化页面样式\" class=\"headerlink\" title=\"六、初始化页面样式\"></a>六、初始化页面样式</h2><ol>\n<li><p>在app.wxss中加入如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">page,view,text,swiper,swiper-item,image,navigator&#123;</span><br><span class=\"line\">  padding: 0;</span><br><span class=\"line\">  margin: 0;</span><br><span class=\"line\">  box-sizing: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;* </span><br><span class=\"line\">  主题颜色 </span><br><span class=\"line\">  支持变量</span><br><span class=\"line\">*&#x2F;</span><br><span class=\"line\">page&#123;</span><br><span class=\"line\">  --themeColor:#eb4450;</span><br><span class=\"line\">  font-size: 28rpx;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用主题颜色</p>\n<p>在index.wxss中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;* pages&#x2F;index&#x2F;index.wxss *&#x2F;</span><br><span class=\"line\">view&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;* 使用主题颜色 *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">  color:var(--themeColor);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n","categories":["微信小程序"],"tags":["入门","黑马优购"]},{"title":"解决GitHub下载速度慢的方法","url":"/2020/08/18/%E8%A7%A3%E5%86%B3GitHub%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E6%96%B9%E6%B3%95/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h2 id=\"GitHub下载慢的问题\"><a href=\"#GitHub下载慢的问题\" class=\"headerlink\" title=\"GitHub下载慢的问题\"></a>GitHub下载慢的问题</h2><p>很多小伙伴说啊这个GitHub的下载速度很慢，那么本期视屏我给大家准备了几个可以提升速度的方法非常的简单</p>\n<h2 id=\"码云\"><a href=\"#码云\" class=\"headerlink\" title=\"码云\"></a>码云</h2><p>码云作为国内的代码托管厂商，速度是非常快的，我们可以使用码云来作为中转站</p>\n<h2 id=\"使用cnpmjs镜像\"><a href=\"#使用cnpmjs镜像\" class=\"headerlink\" title=\"使用cnpmjs镜像\"></a>使用cnpmjs镜像</h2><p>这个方法更加的简单,只需要修改你的路径<code>github.com</code>为<code>github.com.cnpmjs.org</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 之前</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/ZhengLin-Li/leaning-spider-scu-jwc.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用cnpmjs</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span>  https://github.com.cnpm.org/ZhengLin-Li/leaning-spider-scu-jwc.git</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"使用jsdelivr加速\"><a href=\"#使用jsdelivr加速\" class=\"headerlink\" title=\"使用jsdelivr加速\"></a>使用jsdelivr加速</h2><p>jsdelivr可免费提供CDN加速，我们一般用来给自己的博客加速，或者制作一个免费的图床</p>\n<p>同样的它也可以加速我们的GitHub，当我们要快速获取项目中的某个文件的时候就可以使用这个方式</p>\n<p>它的使用也非常简单，我们将<code>github.com</code>修改为<code>cdn.jsdelivr.net</code>同时将<code>/blob/</code>修改为<code>@</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 之前</span></span><br><span class=\"line\">https://github.com/vuejs/vue/blob/dev/README.md</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用jsdelivr</span></span><br><span class=\"line\">https://cdn.jsdelivr.net/gh/vuejs/vue@dev/README.md</span><br></pre></td></tr></table></figure>\n\n<p>此时速度就非常快了</p>\n","categories":["git"],"tags":["git","github"]},{"title":"浅析动物农场","url":"/2020/06/28/%E6%B5%85%E6%9E%90%E5%8A%A8%E7%89%A9%E5%86%9C%E5%9C%BA/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"书籍资源\"><a href=\"#书籍资源\" class=\"headerlink\" title=\"书籍资源\"></a>书籍资源</h1><p>动物农场（译文经典版）epub格式电子书</p>\n<p>链接：<a href=\"https://pan.baidu.com/s/10fNbTN1_zJokyxZQFQ6eVw\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/10fNbTN1_zJokyxZQFQ6eVw</a><br>提取码：tm3g </p>\n<p>动物农场的后浪问题：<a href=\"https://mp.weixin.qq.com/s?srcid=&amp;scene=22&amp;sharer_sharetime=1588998963415&amp;mid=2247485320&amp;sharer_shareid=ded2fc85fa0f2a75c0e6cd17d67c6c3c&amp;sn=463c7495c61e4dc5c73263aba10fe5e9&amp;idx=1&amp;__biz=MzIxMzc2NjY0NA%3D%3D&amp;chksm=97b09f13a0c71605556b92facfc1ba46e4742b9d8b903071a8df735fe8b004bc0ab4d851e498&amp;mpshare=1#rd\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?srcid=&amp;scene=22&amp;sharer_sharetime=1588998963415&amp;mid=2247485320&amp;sharer_shareid=ded2fc85fa0f2a75c0e6cd17d67c6c3c&amp;sn=463c7495c61e4dc5c73263aba10fe5e9&amp;idx=1&amp;__biz=MzIxMzc2NjY0NA%3D%3D&amp;chksm=97b09f13a0c71605556b92facfc1ba46e4742b9d8b903071a8df735fe8b004bc0ab4d851e498&amp;mpshare=1#rd</a></p>\n<h1 id=\"人物关系\"><a href=\"#人物关系\" class=\"headerlink\" title=\"人物关系\"></a>人物关系</h1><ol>\n<li><p>老少校——也就是那头曾经获奖的公猪，昔年他参展时的报名是维林敦帅哥，在农场里真可谓德高望重，每一只动物都不惜少睡个把小时，十分乐意来听听他要讲些什么。</p>\n</li>\n<li><p>三条狗，分别叫做蓝铃铛、杰茜和钳爪。</p>\n</li>\n<li><p>两匹拉套干重活的马，一匹叫拳击手，一匹叫紫苜蓿，紫苜蓿是一匹母性洋溢的壮实雌马，现在步入其中年期，在生育过四胎之后，她再也没能重塑自己昔日的体态风韵。拳击手则是个庞然大物，几乎有六英尺高，论力气顶得上寻常的马两匹合起来那么大。顺着他鼻梁长就白白的一道毛色，使他的相貌总有那么点儿傻里傻气，而他的智能也确实算不上出类拔萃，不过凭着其坚忍不拔的性格和惊天动地的干劲，他还是到处赢得大家的尊敬。</p>\n</li>\n<li><p>白山羊慕莉尔和驴子本杰明。后者在农场里算得上最资深的动物，脾气也是最坏的。他难得说话，一旦开口通常会发表一些冷嘲热讽的怪论，例如他会说上帝赐给他尾巴以便驱赶苍蝇，然而他宁愿尾巴和苍蝇都不要。在农场的动物中，惟独他从来不笑。倘若被问到这是为什么，他会说他看不出来有什么值得一笑。不过，他对拳击手倒是佩服得五体投地，尽管并不公开承认这一点；他俩每每一块儿到果园后面的一小块牧地去共度星期天，互相紧挨着吃草，可就是从不搭话。</p>\n</li>\n<li><p>失去了母亲的小鸭有气无力地细声叫着鱼贯而入，一边左顾右盼，想找一块他们不至于被踩踏的地方。紫苜蓿用她一条巨大的前腿权当一堵墙，把小鸭子围拢来</p>\n</li>\n<li><p>给琼斯先生拉双轮轻便车的莫丽，那匹长得挺俊、却相当愚蠢的白母马</p>\n</li>\n<li><p>末了一个来到的是一只猫，她照例环视四周，先看看哪儿最暖和，最后生生地从拳击手和紫苜蓿之间挤了进去；少校讲话时她从头至尾一直在那里发出轻微的呜噜声表示心满意足，少校说些什么她连一句也没在听。</p>\n</li>\n<li><p>摩西——那是一只驯化了的乌鸦</p>\n<p>有些动物的名字，在英文里是有含义的。<br>比如克洛弗含义是“苜蓿”，博克塞是“拳击手”,三头猪的名字，分别是斯诺鲍尔、斯奎勒和拿破仑。<br>斯诺鲍尔，Snowball，无论造反夺取政权还是其后捍卫政权，他都身先士卒；他又是七大戒律的起草人和风车工程的设计者，属于动物农场上有理想有干法的最高领导人之一。后来，在与拿破仑单挑的斗争中大败，被拿破仑定性为“卖国贼”（多么熟悉的欲加之罪啊）。在拿破仑成为独裁者后，动物农场的阶级斗争随之开始。只要破坏活动发生了，十之有九会归罪斯诺鲍尔。连老实巴交的奶牛们都会表态说：“斯诺鲍尔悄悄溜进了她们的牛圈，在她们睡觉时把她们的牛奶挤没了。”然而，斯诺鲍尔被驱逐出了农场后，是生是死都早是个问题了。<br>斯奎勒，squealer，英文词根等于汉语的“哇哇叫”“尖声叫”“号叫”等意；加了er，名词化，相当于汉语里的“尖叫的动物”，俚语里有“告密者”的意思。他陪伴在拿破仑左右，上蹿下跳，叽哩哇啦，他的言行是纳粹政权里的戈培尔式的，一个很独特的角色，巧舌如簧、颠倒黑白是他的拿手好戏，他始终如一的基调是：<br>“正是为了你们的利益，我们才喝牛奶，吃那些苹果。你们知道，如果我们猪猡对你们玩忽职守，会发生什么情况吗？琼斯会回来！是的，琼斯会回来！千真万确，同志们。”<br>特供怎么建立的？特权怎么产生的？腐败怎么发生的？这就是理论基础。在极权主义社会里，这样的宣传部长式的角色，在古今中外的历史上确实是史无前例的。审查书籍的刀笔吏有的，审查作品的内务大臣有的，但是企图控制、指挥、统一、支配人的思想的宣传部长，却是二十世纪纳粹政权才发明出来的。名叫宣传部长，实际上是传声筒。什么领袖讲话啦、二百五方针啦、各种指示啦、红头文件啦，五花八门，而中心只有一个：我说好就是好，不好也好；我说坏就是坏，不坏也坏。你们敢不听吗？……剿灭自由思想的方式方法无所不用其极。然而，但凡有一分真诚，是人就相信，思想是控制不了的。控制思想的结果，只能是双重思想泛滥成灾。动物农场这个动物社会，最后一步步走向堕落，宣传部长斯奎勒心知肚明，所以他狐假虎威，后来不得不随时带着两条猛犬出入各种宣传场合。<br>“拿破仑”这个名字，嗨，怎么说呢，不管法国那个小个子皇帝在法国历史上发挥过什么有益的作用，但是在自由知识分子的心目中，他只是一个专制者，一个风光一时的皇帝。奥威尔用这个名字的用意，这点是很清楚的。动物农场上的这个拿破仑，奥威尔描写他的形象，使用的文字与描写劳模博克塞的字数相当，说他“体格硕大，长相狰狞”，“平素不大爱说话，但是以凡事自有主张而出名”。创建动物农场初期，他对斯诺鲍尔的各种计划和各种委员会没有兴趣，只说“教育青少年比给那些成年人干任何事情都重要”。他从娃娃抓起的教育，就是豢养那九条猛犬，为他日后驱逐斯诺鲍尔、独揽大权打下了军队加警察的坚实基础。关于修建风车的投票大会，是拿破仑和斯诺鲍尔你死我活的关键战役，斯诺鲍尔滔滔不绝地讲了大半天修建风车的光明前景，广大动物都被动员起来了，但是拿破仑一句“瞎扯淡”就否定了，随着他“扯尖嗓门儿一声怪叫”，九只猛犬一起扑向斯诺鲍尔，斯诺鲍尔只得落荒而逃，从此在动物农场上消失。拿破仑的专政从此拉开了序幕。斯诺鲍尔被驱逐的第三个星期日，拿破仑出尔反尔，宣布修建风车。要修就要大跃进，加班加点，谁缺席把谁的“食物配额减掉一半”。他的一项新政策是“动物农场要和邻近的农场进行贸易活动”。紧接着他带领猪们住进了琼斯的农场住宅，放风说这是“领袖”的工作需要。住上了人的住宅，就要睡人的床，在人的厨房进食，在人的客厅接待客人。为了显示动物农场的富足，他下令弄虚作假，用沙子装满粮仓。为了和外界进行贸易，他下令把母鸡的蛋统统收缴，连孵小鸡的蛋也不留……群众不服吗？召开群众大会，他带着九条猛犬主持会议，只要他“扯尖嗓子叫了一声”，那些猛犬就向特定目标扑去，拉出来示众，在他们坦白了“罪过”之后，那些猛犬就“立即把他们的喉咙咬断”……四只有独立看法的猪死了，三只试图护蛋闹事的鸡死了，一只隐藏过一穗玉米的鹅死了，一只往水池里尿过尿的羊死了，另两只谋杀了“特别忠于拿破仑的老公羊”的羊也死了……“就这样，坦白和处决的故事整了一起又一起，后来一堆尸体摞在了拿破仑的蹄子旁，空气里充满了血腥味儿。这是自从赶走琼斯后闻所未闻的。”……大清洗之后，拿破仑树立了自己的绝对权威，却也让他感到风声鹤唳，“四只猛犬夜间守卫在他的床边，每个床角一只猛犬，一只名叫品克耶的小猪被委以重任，负责品尝拿破仑吃的所有食物，生怕食物里有毒”……<br>拿破仑这个形象，我没觉得可气可恨，还觉得他直接而专横得可爱。他就是一只大权独揽的伯克郡大公猪，兽性即本性，如同动物世界里的狮子逮住猎物一口咬断喉咙那样痛痛快快，无须人的花花肠子弯弯绕，只要一副造反者大获成功的形象，打下江山就要独享江山，杀害同类就要亲临现场，寡人御榻岂能容他人打瞌睡，我是流氓我怕谁？于是乎，“到了四月份，动物农场宣布成立共和国，这下很有必要选出一位总统。候选人只有一个，拿破仑，因此就一致当选了”。于是乎，“地契虽然在他的名下，但是为猪们所共同享有”。于是乎，“小猪全是黑白花斑，因为拿破仑是农场上唯一的种猪，大家很容易猜出来谁是小猪的父亲”。于是乎，“原来一只猪站在后腿上行走了”……<br>猪乎？人乎？<br>人乎？猪乎？</p>\n</li>\n</ol>\n<h1 id=\"浅析\"><a href=\"#浅析\" class=\"headerlink\" title=\"浅析\"></a>浅析</h1><p>小说里涉及狗、马、山羊、驴子、乌鸦和猪，这些动物有名有姓，算角色；绵羊、奶牛、猫、鸽子和成群的鸡与鹅，无名无姓，算群众演员。<br>  谁可以成为《动物农场》上的主人公呢？一般人可能会在狗身上做文章，而且写狗狗的文学作品也确实不少。不过，奥威尔似乎只给三只狗起了名字——布鲁贝尔、杰西和平彻，因为正是这三只有名有姓的狗生了九只小狗，被拿破仑包养起来，后来成了他一步步独揽大权并成功地当上独裁者的有效工具，相当于希特勒豢养的无恶不作的党卫队，从而把狗的属性写到了本质。当然，马是人类最得力的好朋友，写马的文字，古今中外，几近汗牛充栋的程度。奥威尔写了三匹有名有姓的马，每一匹马代表一种性格，而且几乎是为了给这三匹马做映衬，才写了动物农场的哲学家驴子本杰明、略识文字的白山羊缪里尔。乌鸦摩西代表鸟类，没有腿而有翅膀，来去自由的一个形象，代表没有腿的动物。我没有想到奥威尔会把猪写成主人公，有名有姓的有四只；一只称为少校的老公猪，没有名字，但是十章容量的小说，作者用了几乎整整一章写少校的讲话，其核心价值是“人是所有动物的老爷”“所有人都是敌人”“所有动物都是同志”。待到动物们揭竿而起，把庄园农庄攻打下来，建立了政权，开始筹建乌托邦了，正是根据少校临终前的这番讲话的核心价值，归纳出了神圣的宪章性质的“七大戒律”：<br>　　一、凡是两条腿走路的都是敌人。<br>　　二、凡是四条腿走路的，或者长翅膀的，都是朋友。<br>　　三、任何动物都不准穿衣服。<br>　　四、任何动物都不准在床上睡觉。<br>　　五、任何动物都不准喝酒。<br>　　六、任何动物都不准杀害其他动物。<br>　　七、所有动物都生而平等。<br>　　这七大戒律最后围绕着独裁者拿破仑转圈圈，越转越小，把他舒舒服服地包裹起来，起先虽然只是在特定戒律上抠字眼地稍加涂改，但内容却发生了根本改变，比如第四条“任何动物都不准在床上睡觉”涂改成了“任何动物都不准在有被褥的床上睡觉”；动物在柴火窝里睡觉，充其量铺盖一些麦秸或杂草，铺了被褥睡觉就是人的行为了。又比如第五条“任何动物都不准喝酒”涂改成了“任何动物不得饮酒过度”。喝酒是享乐，酗酒则是堕落，这更是人的行为。动物们造反夺取政权，与人不共戴天，夺取政权后却偷偷摸摸地向人的生活靠近，而这样的更改戒律，又都是为了适应统治阶级和独裁者的一步步腐化和享受。到了最后，更具深刻寓意的是，七大戒律最后剩下了三行字，归纳成了一条规定：<br>  所有的动物生而平等，但是一些动物生来要比，另一些动物更平等。<br>写到这里，我又想起奥威尔另外一句深刻的语句：<br>  如果你们有你们的低等动物感到满意，那么我们有我们的低等阶级感到满意。<br>　　<br>  动物们造反，就是造琼斯的反。琼斯是庄园农庄的农场主，因为酗酒，渐渐对农场疏于管理，最终导致动物们揭竿而起，一举夺得庄园农庄，改名动物农场，成立了史无前例的动物当家的乌托邦。建立乌托邦是一回事儿，维持乌托邦是另一回事儿。乌托邦即“无托邦”，没有任何依托为依据，统治者便可以随心所欲地重塑他们心目中的无托邦。理想一个个破灭，怪事、丑事和恶事一起又一起地发生。贫穷始终像恶魔一样挥之不去，定量配给成了习以为常的分配制度。每当下层动物们发生重大疑问而发出不同声音、而统治者又理屈词穷时，统治阶级强词夺理的最后一根稻草就是：你们不想让琼斯回来吧。奥威尔是要用他笔下的动物形象来揭示人类极权主义的恐怖、丑陋和罪恶，不只是新旧社会的问题。在动物农场这个社会里，动物是主要角色，人是配角，却不可或缺。<br>  三匹有名有姓的马——博克塞、克洛弗和莫丽。莫丽是一匹年轻的牝马，爱捯饬，爱显摆，总忘不了在鬃毛上系一条彩带。动物农场走上集体道路后，她是集体活动中最爱迟到早退的主儿，干活儿也是磨洋工的时候多，卖力气干活儿的时候少，究其原因似乎主要是她吃不到她爱吃的一样东西——糖。中国古圣人说“食色性也”，把“食”放在第一位，无比正确。无论动物还是人类，从小挨饿而不得不觅食的主儿，一定比饱食终日的主儿要机灵得多，智慧得多。作者写莫丽的文字很有限，但是一个最有远见的问题却由她提了出来：造反之后还有糖吃吗？莫丽受不了苦，喜欢过甜蜜的日子，提出这个问题仅仅是因为她的胃，但是这个问题却是全书中最有远见的，类似鲁迅的“娜拉出走后怎么办？”莫丽是个现实主义者，看见造反后的日子每况愈下，定量配给都难以保障，吃糖成了奢望，便悄悄地溜之大吉，跑到别的农场去给人拉马车，从而过上了她有糖吃的甜蜜的生活，意味深长。<br>  克洛弗也是一匹牝马，总是陪伴在博克塞的身边。在劳动中她拼力劳作，试图减轻博克塞的劳动强度；在生活上她关心博克塞的冷暖，尤其在博克塞的蹄子受伤之后。和她的名字克洛弗一样，在英语里是“苜蓿”，又称“三叶草”，她恨不得让博克塞吃下肚子变得更强壮，有一个健康强大的身体，顶得住繁重的体力劳动。她是作者心目中的下等阶级的贤妻良母，不过作品赋予她的另一项使命似乎更重要：她是在动物农场每次发生重大变故后，唯一一个使用记忆的角色。她是文盲，脑子也不是很好使，但是她有心，有记忆，每当遇到疑惑不解的问题，就求教驴子本杰明或者白山羊缪里尔，或者帮助她回忆过去的事实，或者到“七大戒律”前面求证。记忆是奥威尔追究极权主义实质的重要依据，在《动物农场》里只是通过克洛弗这个动物角色进行了比较浅层的探讨，在动物们的身上似乎也只能写到为止，而只有在《一九八四》一书里人成为角色后，才能系统地揭示。尽管如此，克洛弗这匹善良的母马，留给人的印象足够深刻的。正是这匹善良的母马，在动物农场发生触目惊心的“大清洗”之后，作者给她来了画龙点睛之笔：“克洛弗望着山坡，不禁泪水盈眶。如果她能讲出她的思绪，千言万语汇成一句话：他们多年前费尽艰辛推翻人类，他们追求的目的可不是目前的样子……他们盼到一个谁都不敢讲心里话的时代，那些凶猛的狂吠的猛犬横行，而你不得不目睹你的同志在坦白了莫须有的罪过后统统被撕成了碎片。”随着年龄老去，克洛弗的记忆也变成了碎片，尤其目睹博克塞被送往屠宰场之后。<br>  就下层阶级而言，博克塞是作者着墨最多的一个形象：第一章写到动物们在一次秘密会议上粉墨登场，只对博克塞交代得最具体，描写也最多，用了大约一百零几个字。在六万字一部小说里，作者惜墨如金，这样刻画形象的篇幅算是很大了，而就这一百多个字来看，作者还有重点，那就是：他鼻梁上有一道白毛，他因此看上去有几分傻相，而实际上他也不是一流脑子。这匹身架高大到足有两匹普通马相加的个头与力量的大牡马，何止不具备一流智商，连把字母表认到D的智商都没有。他就知道干活儿，动物农场一半的活儿都是他干的，尤其在建设风车这样的超级工程中，他就是中流砥柱，而他也是在这项工程中被累垮的。<br>  从早到晚，他拉啊，拽啊，哪里有最累的活儿，他就出现在哪里。他早和一只打鸣的公鸡达成协议，请他早上提前半小时叫他起来，赶在别人前面，把那些最需要力气的活儿自愿干完，赶在日常的活儿开始之前。<br>动物农场是集体农庄，集体农庄上的劳模就是这个样子。如今，年纪五十岁开外的人，只要在这样的生产形式下干过活儿的人，这样的形象是再熟悉不过的，是一种既让人爱戴又让人可怜甚至遭人憎恨的形象。在我心目中最接近博克塞似的人物，是我们村里的一个我应该叫叔叔的农人，在我们村做了多年劳模，干活儿真的是披星戴月，积劳成疾。他最著名的事迹是他一大早上地，睡眼惺忪，经常胳肢窝夹了一个扫炕的笤帚，到了地头才明白把笤帚误当成了小勾锄。在生产队和公社组织的劳模讲用会上，他一次又一次讲起这些个事实，把一个农民很丢人的事实讲成了光荣事迹。当然，他的讲用材料是地方御用文人舞文弄墨的结果。在小说中，博克塞这样的劳模，与其说干活儿卖力是特色，不如说“他鼻梁上有一道白毛，他因此看上去有几分傻相”更含意味。博克塞的座右铭是：“拿破仑一贯正确，我会更加努力干活儿。”博克塞这样的劳模悲剧的一面，是要大家一起跟他学得愚蠢起来，殉道般地听任统治者恣意摆布。<br>  这样的形象之所以还受下层动物普遍尊重，劳动好是一个方面，品德底线是另一个方面。博克塞有良知，讲诚实，而正因这两点，在动物农场几个需要统一思想的场合里他表示了不同声音，便差一点成为大清洗的对象，多亏他力大无穷，眼见“三只猛犬……气汹汹扑来，用他的大蹄子迎住他们，在空中把一只猛犬踢中，一下子把他死死地踩在地上”。在一个控制脑力也控制体力的极权体制里，强有力的武力是一种绝对牵制，这也是独裁者必要时拉拢武夫的根本原因。博克塞不用独裁者拉拢，因他一生唯独裁者命是听，他最后走进了一辆前往屠宰场的货车，对上面“艾尔弗雷德·西蒙兹，马匹屠夫以及皮胶熬制人”的广告视而不见，不只是因为他不识字，更是因为他一辈子只会盲从。<br>  关于劳模博克塞的结局，官方说用货车送他去养老院了，而民众根据货车上的广告而断定是把他送进屠宰场了。作者给出的说法是：“听说猪们不知从什么地方弄来一笔钱，又为他们自己购买了一箱威士忌。”读者很容易忽略这个细节，而译者是想方设法让译文突出这样的信息：辛劳一生的博克塞的血肉钱，为猪们换来了威士忌！<br>  生活潦倒的琼斯到底没有回来，但是比琼斯更残忍的人还是回来过的。<br>群众是多数，多数总是最难对付的，而统治者对付多数最好的办法就是愚弄加欺骗。绵羊、奶牛、猫、鸽子和成群的鸡与鹅是动物农场上的群众，猫喜欢独来独往，鸽子可以飞来飞去做哨兵，奶牛越多就越有统治阶级的奶喝，这样，鸡、鹅和绵羊这类多数就成了更低一级的基本群众了，而这三种动物又有区别：鸡与鹅可以下蛋，供统治者享用，而绵羊只有杀身才能成仁。就人类而言，猪羊任其宰割，在家畜中命是最贱的。如今猪做了统治者，绵羊们不需要杀身成仁了，但必须为统治者服务，成为吹鼓手才算有了与压迫深反抗重相应的主人翁地位。于是，在动物农场宣传部长斯奎勒的专门指导和调教下，绵羊们成了群众动物中争先恐后充当墙头草的喽啰。每到群众性的阶级斗争大会或者领导互相倾轧的核心会议的关键时刻，绵羊们都会气势如虹地喊出：四条腿好，两条腿坏。这是政治形势的需要，因此在政治形势需要他们改换口径的时候，他们又会毫不犹豫地喊出“四条腿好，两条腿更好”的口号。这不是绵羊的脑子转弯快，而是绵羊任人宰割的天性决定的。群众在造反活动、游行示威、公审大会等场合确实声势浩大、势不可当，但是在分而治之的情况下，尤其利益相关之时，哪怕因为蝇头小利，他们又是最容易充当墙头草的。<br>  奥威尔一生同情下等阶级，对动物农场的群众动物的批评，温和而有分寸，基本是幽默式的讽刺笔触。在星期天的群众大会上，宣传部长斯奎勒“用蹄子夹住一张长长的纸条，给他们念出来一大串数字，表明每一级食物生产按照大好形势看来，都增加百分之二百、百分之三百或者百分之五百不等”；这样的形势报告做过，群众就得表态，一只母鸡因此会扯尖嗓子说：<br>  在我们的领袖拿破仑同志的英明领导下，我六天下了五个鸡蛋。<br>  奶牛们在饮水池边，一边大口喝水，一边由衷地赞扬说：感谢拿破仑同志的英明领导，这水喝来是多么甜啊！<br>  绵羊们在隆重的胜利大会结束时，则会咩咩地引吭高歌，合唱文人墨客精心修改过的《英格兰动物之歌》：<br>  无父的动物们的朋友！<br>  幸福的源头！<br>  食桶的主！啊，我的灵魂会面临<br>  大火，只要我注视您<br>  安详的威严的目光，如同天空的太阳，<br>  拿破仑同志！<br>  在极权体制下生活过的人们，对这样的表达是耳熟能详的，但是对生活在英格兰这样一片自由土地上的奥威尔来说，能形象地准确地写出这样的文字，不能不令人叹服。</p>\n","categories":["读书"],"tags":["社科"]},{"title":"A first look at C++ (2) copy 2","url":"/2023/01/18/A%20first%20look%20at%20C++%20(2)%20copy%202/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>C++核心编程<br>本阶段主要针对 C++==面向对象==编程技术做详细讲解，探讨 C++中的核心和精髓。</p>\n<p>1 内存分区模型<br>C++程序在执行时，将内存大方向划分为 4 个区域</p>\n<p>代码区：存放函数体的二进制代码，由操作系统进行管理的<br>全局区：存放全局变量和静态变量以及常量<br>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等<br>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收<br>内存四区意义：</p>\n<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>\n<p>1.1 程序运行前<br>​ 在程序编译后，生成了 exe 可执行程序，未执行该程序前分为两个区域</p>\n<p>​ 代码区：</p>\n<p>​ 存放 CPU 执行的机器指令</p>\n<p>​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>\n<p>​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令</p>\n<p>​ 全局区：</p>\n<p>​ 全局变量和静态变量存放在此.</p>\n<p>​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>\n<p>​ ==该区域的数据在程序结束后由操作系统释放==.</p>\n<p>示例：</p>\n<p>C++<br>//全局变量<br>int g_a = 10;<br>int g_b = 10;</p>\n<p>//全局常量<br>const int c_g_a = 10;<br>const int c_g_b = 10;</p>\n<p>int main() {</p>\n<pre><code>//局部变量\nint a = 10;\nint b = 10;\n\n//打印地址\ncout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;\ncout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;\n\ncout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt;  (int)&amp;g_a &lt;&lt; endl;\ncout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt;  (int)&amp;g_b &lt;&lt; endl;\n\n//静态变量\nstatic int s_a = 10;\nstatic int s_b = 10;\n\ncout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;\ncout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;\n\ncout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;\n\ncout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;\ncout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;\n\nconst int c_l_a = 10;\nconst int c_l_b = 10;\ncout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;\ncout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>打印结果：</p>\n<p>1545017602518<br>1545017602518</p>\n<p>总结：</p>\n<p>C++中在程序运行前分为全局区和代码区<br>代码区特点是共享和只读<br>全局区中存放全局变量、静态变量、常量<br>常量区中存放 const 修饰的全局常量 和 字符串常量<br>1.2 程序运行后<br>​ 栈区：</p>\n<p>​ 由编译器自动分配释放, 存放函数的参数值,局部变量等</p>\n<p>​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>\n<p>示例：</p>\n<p>C++<br>int * func()<br>{<br>int a = 10;<br>return &a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>​ 堆区：</p>\n<p>​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>\n<p>​ 在 C++中主要利用 new 在堆区开辟内存</p>\n<p>示例：</p>\n<p>C++<br>int* func()<br>{<br>int* a = new int(10);<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>堆区数据由程序员管理开辟和释放</p>\n<p>堆区数据利用 new 关键字进行开辟内存</p>\n<p>1.3 new 操作符<br>​ C++中利用==new==操作符在堆区开辟数据</p>\n<p>​ 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p>\n<p>​ 语法：new 数据类型</p>\n<p>​ 利用 new 创建的数据，会返回该数据对应的类型的指针</p>\n<p>示例 1： 基本语法</p>\n<p>C++<br>int* func()<br>{<br>int* a = new int(10);<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\n//利用delete释放堆区数据\ndelete p;\n\n//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：开辟数组</p>\n<p>C++<br>//堆区开辟数组<br>int main() {</p>\n<pre><code>int* arr = new int[10];\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    arr[i] = i + 100;\n}\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    cout &lt;&lt; arr[i] &lt;&lt; endl;\n}\n//释放数组 delete 后加 []\ndelete[] arr;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2 引用<br>2.1 引用的基本使用<br>*作用： *给变量起别名</p>\n<p>语法： 数据类型 &amp;别名 = 原名</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int a = 10;\nint &amp;b = a;\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n\nb = 100;\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2.2 引用注意事项<br>引用必须初始化<br>引用在初始化后，不可以改变<br>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int a = 10;\nint b = 20;\n//int &amp;c; //错误，引用必须初始化\nint &amp;c = a; //一旦初始化后，就不可以更改\nc = b; //这是赋值操作，不是更改引用\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\ncout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2.3 引用做函数参数<br>作用：函数传参时，可以利用引用的技术让形参修饰实参</p>\n<p>优点：可以简化指针修改实参</p>\n<p>示例：</p>\n<p>C++<br>//1. 值传递<br>void mySwap01(int a, int b) {<br>int temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>//2. 地址传递<br>void mySwap02(int* a, int* b) {<br>int temp = *a;<br>*a = *b;<br>*b = temp;<br>}</p>\n<p>//3. 引用传递<br>void mySwap03(int&amp; a, int&amp; b) {<br>int temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>int main() {</p>\n<pre><code>int a = 10;\nint b = 20;\n\nmySwap01(a, b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nmySwap02(&amp;a, &amp;b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nmySwap03(a, b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>\n<p>2.4 引用做函数返回值<br>作用：引用是可以作为函数的返回值存在的</p>\n<p>注意：不要返回局部变量引用</p>\n<p>用法：函数调用作为左值</p>\n<p>示例：</p>\n<p>C++<br>//返回局部变量引用<br>int&amp; test01() {<br>int a = 10; //局部变量<br>return a;<br>}</p>\n<p>//返回静态变量引用<br>int&amp; test02() {<br>static int a = 20;<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>//不能返回局部变量的引用\nint&amp; ref = test01();\ncout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\ncout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\n\n//如果函数做左值，那么必须返回引用\nint&amp; ref2 = test02();\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\ntest02() = 1000;\n\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>​</p>\n<p>2.5 引用的本质<br>本质：引用的本质在 c++内部实现是一个指针常量.</p>\n<p>讲解示例：</p>\n<p>C++<br>//发现是引用，转换为 int* const ref = &a;<br>void func(int&amp; ref){<br>ref = 100; // ref 是引用，转换为*ref = 100<br>}<br>int main(){<br>int a = 10;</p>\n<pre><code>//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改\nint&amp; ref = a;\nref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\n\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;\n\nfunc(a);\nreturn 0;</code></pre><p>}<br>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>\n<p>2.6 常量引用<br>作用：常量引用主要用来修饰形参，防止误操作</p>\n<p>在函数形参列表中，可以加==const 修饰形参==，防止形参改变实参</p>\n<p>示例：</p>\n<p>C++<br>//引用使用的场景，通常用来修饰形参<br>void showValue(const int&amp; v) {<br>//v += 10;<br>cout &lt;&lt; v &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误\n//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;\nconst int&amp; ref = 10;\n\n//ref = 100;  //加入const后不可以修改变量\ncout &lt;&lt; ref &lt;&lt; endl;\n\n//函数中利用常量引用防止误操作修改实参\nint a = 10;\nshowValue(a);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3 函数提高<br>3.1 函数默认参数<br>在 C++中，函数的形参列表中的形参是可以有默认值的。</p>\n<p>语法：返回值类型 函数名 （参数= 默认值）{}</p>\n<p>示例：</p>\n<p>C++<br>int func(int a, int b = 10, int c = 10) {<br>return a + b + c;<br>}</p>\n<p>//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值<br>//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数<br>int func2(int a = 10, int b = 10);<br>int func2(int a, int b) {<br>return a + b;<br>}</p>\n<p>int main() {</p>\n<pre><code>cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;\ncout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.2 函数占位参数<br>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>\n<p>语法： 返回值类型 函数名 (数据类型){}</p>\n<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>\n<p>示例：</p>\n<p>C++<br>//函数占位参数 ，占位参数也可以有默认参数<br>void func(int a, int) {<br>cout &lt;&lt; “this is func” &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>func(10,10); //占位参数必须填补\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.3 函数重载<br>3.3.1 函数重载概述<br>作用：函数名可以相同，提高复用性</p>\n<p>函数重载满足条件：</p>\n<p>同一个作用域下<br>函数名称相同<br>函数参数类型不同 或者 个数不同 或者 顺序不同<br>注意: 函数的返回值不可以作为函数重载的条件</p>\n<p>示例：</p>\n<p>C++<br>//函数重载需要函数都在同一个作用域下<br>void func()<br>{<br>cout &lt;&lt; “func 的调用！” &lt;&lt; endl;<br>}<br>void func(int a)<br>{<br>cout &lt;&lt; “func (int a) 的调用！” &lt;&lt; endl;<br>}<br>void func(double a)<br>{<br>cout &lt;&lt; “func (double a)的调用！” &lt;&lt; endl;<br>}<br>void func(int a ,double b)<br>{<br>cout &lt;&lt; “func (int a ,double b) 的调用！” &lt;&lt; endl;<br>}<br>void func(double a ,int b)<br>{<br>cout &lt;&lt; “func (double a ,int b)的调用！” &lt;&lt; endl;<br>}</p>\n<p>//函数返回值不可以作为函数重载条件<br>//int func(double a, int b)<br>//{<br>// cout &lt;&lt; “func (double a ,int b)的调用！” &lt;&lt; endl;<br>//}</p>\n<p>int main() {</p>\n<pre><code>func();\nfunc(10);\nfunc(3.14);\nfunc(10,3.14);\nfunc(3.14 , 10);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.3.2 函数重载注意事项<br>引用作为重载条件<br>函数重载碰到函数默认参数<br>示例：</p>\n<p>C++<br>//函数重载注意事项<br>//1、引用作为重载条件</p>\n<p>void func(int &amp;a)<br>{<br>cout &lt;&lt; “func (int &amp;a) 调用 “ &lt;&lt; endl;<br>}</p>\n<p>void func(const int &amp;a)<br>{<br>cout &lt;&lt; “func (const int &amp;a) 调用 “ &lt;&lt; endl;<br>}</p>\n<p>//2、函数重载碰到函数默认参数</p>\n<p>void func2(int a, int b = 10)<br>{<br>cout &lt;&lt; “func2(int a, int b = 10) 调用” &lt;&lt; endl;<br>}</p>\n<p>void func2(int a)<br>{<br>cout &lt;&lt; “func2(int a) 调用” &lt;&lt; endl;<br>}</p>\n<p>int main() {<br>int a = 10;<br>func(a); //调用无 const<br>func(10);//调用有 const</p>\n<pre><code>//func2(10); //碰到默认参数产生歧义，需要避免\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4 类和对象<br>C++面向对象的三大特性为：==封装、继承、多态==</p>\n<p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p>\n<p>例如：</p>\n<p>​ 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>\n<p>​ 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>\n<p>​ 具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p>\n<p>4.1 封装<br>4.1.1 封装的意义<br>封装是 C++面向对象三大特性之一</p>\n<p>封装的意义：</p>\n<p>将属性和行为作为一个整体，表现生活中的事物<br>将属性和行为加以权限控制<br>封装意义一：</p>\n<p>​ 在设计类的时候，属性和行为写在一起，表现事物</p>\n<p>语法： class 类名{ 访问权限： 属性 / 行为 };</p>\n<p>示例 1：设计一个圆类，求圆的周长</p>\n<p>示例代码：</p>\n<p>C++<br>//圆周率<br>const double PI = 3.14;</p>\n<p>//1、封装的意义<br>//将属性和行为作为一个整体，用来表现生活中的事物</p>\n<p>//封装一个圆类，求圆的周长<br>//class 代表设计一个类，后面跟着的是类名<br>class Circle<br>{<br>public: //访问权限 公共的权限</p>\n<pre><code>//属性\nint m_r;//半径\n\n//行为\n//获取到圆的周长\ndouble calculateZC()\n{\n    //2 * pi  * r\n    //获取圆的周长\n    return  2 * PI * m_r;\n}</code></pre><p>};</p>\n<p>int main() {</p>\n<pre><code>//通过圆类，创建圆的对象\n// c1就是一个具体的圆\nCircle c1;\nc1.m_r = 10; //给圆对象的半径 进行赋值操作\n\n//2 * pi * 10 = = 62.8\ncout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>\n<p>示例 2 代码：</p>\n<p>C++<br>//学生类<br>class Student {<br>public:<br>void setName(string name) {<br>m_name = name;<br>}<br>void setID(int id) {<br>m_id = id;<br>}</p>\n<pre><code>void showStudent() {\n    cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;\n}</code></pre><p>public:<br>string m_name;<br>int m_id;<br>};</p>\n<p>int main() {</p>\n<pre><code>Student stu;\nstu.setName(&quot;德玛西亚&quot;);\nstu.setID(250);\nstu.showStudent();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>封装意义二：</p>\n<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>\n<p>访问权限有三种：</p>\n<p>public 公共权限<br>protected 保护权限<br>private 私有权限<br>示例：</p>\n<p>C++<br>//三种权限<br>//公共权限 public 类内可以访问 类外可以访问<br>//保护权限 protected 类内可以访问 类外不可以访问<br>//私有权限 private 类内可以访问 类外不可以访问</p>\n<p>class Person<br>{<br>//姓名 公共权限<br>public:<br>string m_Name;</p>\n<pre><code>//汽车  保护权限</code></pre><p>protected:<br>string m_Car;</p>\n<pre><code>//银行卡密码  私有权限</code></pre><p>private:<br>int m_Password;</p>\n<p>public:<br>void func()<br>{<br>m_Name = “张三”;<br>m_Car = “拖拉机”;<br>m_Password = 123456;<br>}<br>};</p>\n<p>int main() {</p>\n<pre><code>Person p;\np.m_Name = &quot;李四&quot;;\n//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到\n//p.m_Password = 123; //私有权限类外访问不到\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.1.2 struct 和 class 区别<br>在 C++中 struct 和 class 唯一的区别就在于 默认的访问权限不同</p>\n<p>区别：</p>\n<p>struct 默认权限为公共<br>class 默认权限为私有<br>C++<br>class C1<br>{<br>int m_A; //默认是私有权限<br>};</p>\n<p>struct C2<br>{<br>int m_A; //默认是公共权限<br>};</p>\n<p>int main() {</p>\n<pre><code>C1 c1;\nc1.m_A = 10; //错误，访问权限是私有\n\nC2 c2;\nc2.m_A = 10; //正确，访问权限是公共\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.1.3 成员属性设置为私有<br>优点 1：将所有成员属性设置为私有，可以自己控制读写权限</p>\n<p>优点 2：对于写权限，我们可以检测数据的有效性</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:</p>\n<pre><code>//姓名设置可读可写\nvoid setName(string name) {\n    m_Name = name;\n}\nstring getName()\n{\n    return m_Name;\n}\n\n\n//获取年龄\nint getAge() {\n    return m_Age;\n}\n//设置年龄\nvoid setAge(int age) {\n    if (age &lt; 0 || age &gt; 150) {\n        cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;\n        return;\n    }\n    m_Age = age;\n}\n\n//情人设置为只写\nvoid setLover(string lover) {\n    m_Lover = lover;\n}</code></pre><p>private:<br>string m_Name; //可读可写 姓名<br>int m_Age; //只读 年龄</p>\n<pre><code>string m_Lover; //只写  情人</code></pre><p>};</p>\n<p>int main() {</p>\n<pre><code>Person p;\n//姓名设置\np.setName(&quot;张三&quot;);\ncout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;\n\n//年龄设置\np.setAge(50);\ncout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;\n\n//情人设置\np.setLover(&quot;苍井&quot;);\n//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>练习案例 1：设计立方体类</p>\n<p>设计立方体类(Cube)</p>\n<p>求出立方体的面积和体积</p>\n<p>分别用全局函数和成员函数判断两个立方体是否相等。</p>\n<p>1545533548532<br>1545533548532</p>\n<p>练习案例 2：点和圆的关系</p>\n<p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p>\n<p>1545533829184<br>1545533829184</p>\n<p>4.2 对象的初始化和清理<br>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全<br>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。<br>4.2.1 构造函数和析构函数<br>对象的初始化和清理也是两个非常重要的安全问题</p>\n<p>​ 一个对象或者变量没有初始状态，对其使用后果是未知</p>\n<p>​ 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>\n<p>c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>\n<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供</p>\n<p>编译器提供的构造函数和析构函数是空实现。</p>\n<p>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。<br>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。<br>构造函数语法：类名(){}</p>\n<p>构造函数，没有返回值也不写 void<br>函数名称与类名相同<br>构造函数可以有参数，因此可以发生重载<br>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次<br>析构函数语法： ~类名(){}</p>\n<p>析构函数，没有返回值也不写 void<br>函数名称与类名相同,在名称前加上符号 ~<br>析构函数不可以有参数，因此不可以发生重载<br>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次<br>C++<br>class Person<br>{<br>public:<br>//构造函数<br>Person()<br>{<br>cout &lt;&lt; “Person 的构造函数调用” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person()<br>{<br>cout &lt;&lt; “Person 的析构函数调用” &lt;&lt; endl;<br>}</p>\n<p>};</p>\n<p>void test01()<br>{<br>Person p;<br>}</p>\n<p>int main() {<br>test01();</p>\n<pre><code>system(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.2 构造函数的分类及调用<br>两种分类方式：</p>\n<p>​ 按参数分为： 有参构造和无参构造</p>\n<p>​ 按类型分为： 普通构造和拷贝构造</p>\n<p>三种调用方式：</p>\n<p>​ 括号法</p>\n<p>​ 显示法</p>\n<p>​ 隐式转换法</p>\n<p>示例：</p>\n<p>C++<br>//1、构造函数分类<br>// 按照参数分类分为 有参和无参构造 无参又称为默认构造函数<br>// 按照类型分类分为 普通构造和拷贝构造</p>\n<p>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int a) {<br>age = a;<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>}<br>//拷贝构造函数<br>Person(const Person&amp; p) {<br>age = p.age;<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int age;<br>};</p>\n<p>//2、构造函数的调用<br>//调用无参构造函数<br>void test01() {<br>Person p; //调用无参构造函数<br>}</p>\n<p>//调用有参的构造函数<br>void test02() {</p>\n<pre><code>//2.1  括号法，常用\nPerson p1(10);\n//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n//Person p2();\n\n//2.2 显式法\nPerson p2 = Person(10);\nPerson p3 = Person(p2);\n//Person(10)单独写就是匿名对象  当前行结束之后，马上析构\n\n//2.3 隐式转换法\nPerson p4 = 10; // Person p4 = Person(10);\nPerson p5 = p4; // Person p5 = Person(p4);\n\n//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\n//Person p5(p4);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n//test02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.3 拷贝构造函数调用时机<br>C++中拷贝构造函数调用时机通常有三种情况</p>\n<p>使用一个已经创建完毕的对象来初始化一个新对象<br>值传递的方式给函数参数传值<br>以值方式返回局部对象<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>mAge = 0;<br>}<br>Person(int age) {<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>mAge = age;<br>}<br>Person(const Person&amp; p) {<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>mAge = p.mAge;<br>}<br>//析构函数在释放内存之前调用<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int mAge;<br>};</p>\n<p>//1. 使用一个已经创建完毕的对象来初始化一个新对象<br>void test01() {</p>\n<pre><code>Person man(100); //p对象已经创建完毕\nPerson newman(man); //调用拷贝构造函数\nPerson newman2 = man; //拷贝构造\n\n//Person newman3;\n//newman3 = man; //不是调用拷贝构造函数，赋值操作</code></pre><p>}</p>\n<p>//2. 值传递的方式给函数参数传值<br>//相当于 Person p1 = p;<br>void doWork(Person p1) {}<br>void test02() {<br>Person p; //无参构造函数<br>doWork(p);<br>}</p>\n<p>//3. 以值方式返回局部对象<br>Person doWork2()<br>{<br>Person p1;<br>cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;<br>return p1;<br>}</p>\n<p>void test03()<br>{<br>Person p = doWork2();<br>cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n//test02();\ntest03();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.4 构造函数调用规则<br>默认情况下，c++编译器至少给一个类添加 3 个函数</p>\n<p>1．默认构造函数(无参，函数体为空)</p>\n<p>2．默认析构函数(无参，函数体为空)</p>\n<p>3．默认拷贝构造函数，对属性进行值拷贝</p>\n<p>构造函数调用规则如下：</p>\n<p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造<br>如果用户定义拷贝构造函数，c++不会再提供其他构造函数<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int a) {<br>age = a;<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>}<br>//拷贝构造函数<br>Person(const Person&amp; p) {<br>age = p.age;<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int age;<br>};</p>\n<p>void test01()<br>{<br>Person p1(18);<br>//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作<br>Person p2(p1);</p>\n<pre><code>cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;</code></pre><p>}</p>\n<p>void test02()<br>{<br>//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造<br>Person p1; //此时如果用户自己没有提供默认构造，会出错<br>Person p2(10); //用户提供的有参<br>Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供</p>\n<pre><code>//如果用户提供拷贝构造，编译器不会提供其他构造函数\nPerson p4; //此时如果用户自己没有提供默认构造，会出错\nPerson p5(10); //此时如果用户自己没有提供有参，会出错\nPerson p6(p5); //用户自己提供拷贝构造</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.5 深拷贝与浅拷贝<br>深浅拷贝是面试经典问题，也是常见的一个坑</p>\n<p>浅拷贝：简单的赋值拷贝操作</p>\n<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int age ,int height) {<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;</p>\n<pre><code>    m_age = age;\n    m_height = new int(height);\n\n}\n//拷贝构造函数\nPerson(const Person&amp; p) {\n    cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n    //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题\n    m_age = p.m_age;\n    m_height = new int(*p.m_height);\n\n}\n\n//析构函数\n~Person() {\n    cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n    if (m_height != NULL)\n    {\n        delete m_height;\n    }\n}</code></pre><p>public:<br>int m_age;<br>int* m_height;<br>};</p>\n<p>void test01()<br>{<br>Person p1(18, 180);</p>\n<pre><code>Person p2(p1);\n\ncout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>\n<p>4.2.6 初始化列表<br>作用：</p>\n<p>C++提供了初始化列表语法，用来初始化属性</p>\n<p>语法：构造函数()：属性 1(值 1),属性 2（值 2）… {}</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:</p>\n<pre><code>////传统方式初始化\n//Person(int a, int b, int c) {\n//    m_A = a;\n//    m_B = b;\n//    m_C = c;\n//}\n\n//初始化列表方式初始化\nPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}\nvoid PrintPerson() {\n    cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;\n    cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;\n    cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;\n}</code></pre><p>private:<br>int m_A;<br>int m_B;<br>int m_C;<br>};</p>\n<p>int main() {</p>\n<pre><code>Person p(1, 2, 3);\np.PrintPerson();\n\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.7 类对象作为类成员<br>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>\n<p>例如：</p>\n<p>C++<br>class A {}<br>class B<br>{<br>A a；<br>}<br>B 类中有对象 A 作为成员，A 为对象成员</p>\n<p>那么当创建 B 对象时，A 与 B 的构造和析构的顺序是谁先谁后？</p>\n<p>示例：</p>\n<p>C++<br>class Phone<br>{<br>public:<br>Phone(string name)<br>{<br>m_PhoneName = name;<br>cout &lt;&lt; “Phone 构造” &lt;&lt; endl;<br>}</p>\n<pre><code>~Phone()\n{\n    cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;\n}\n\nstring m_PhoneName;</code></pre><p>};</p>\n<p>class Person<br>{<br>public:</p>\n<pre><code>//初始化列表可以告诉编译器调用哪一个构造函数\nPerson(string name, string pName) :m_Name(name), m_Phone(pName)\n{\n    cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;\n}\n\n~Person()\n{\n    cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;\n}\n\nvoid playGame()\n{\n    cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;\n}\n\nstring m_Name;\nPhone m_Phone;</code></pre><p>};<br>void test01()<br>{<br>//当类中成员是其他类对象时，我们称该成员为 对象成员<br>//构造的顺序是 ：先调用对象成员的构造，再调用本类构造<br>//析构顺序与构造相反<br>Person p(“张三” , “苹果 X”);<br>p.playGame();</p>\n<p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.8 静态成员<br>静态成员就是在成员变量和成员函数前加上关键字 static，称为静态成员</p>\n<p>静态成员分为：</p>\n<p>静态成员变量<br>所有对象共享同一份数据<br>在编译阶段分配内存<br>类内声明，类外初始化<br>静态成员函数<br>所有对象共享同一个函数<br>静态成员函数只能访问静态成员变量<br>示例 1 ：静态成员变量</p>\n<p>C++<br>class Person<br>{<br>public:</p>\n<pre><code>static int m_A; //静态成员变量\n\n//静态成员变量特点：\n//1 在编译阶段分配内存\n//2 类内声明，类外初始化\n//3 所有对象共享同一份数据</code></pre><p>private:<br>static int m_B; //静态成员变量也是有访问权限的<br>};<br>int Person::m_A = 10;<br>int Person::m_B = 10;</p>\n<p>void test01()<br>{<br>//静态成员变量两种访问方式</p>\n<pre><code>//1、通过对象\nPerson p1;\np1.m_A = 100;\ncout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl;\n\nPerson p2;\np2.m_A = 200;\ncout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据\ncout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl;\n\n//2、通过类名\ncout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl;\n\n\n//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：静态成员函数</p>\n<p>C++<br>class Person<br>{</p>\n<p>public:</p>\n<pre><code>//静态成员函数特点：\n//1 程序共享一个函数\n//2 静态成员函数只能访问静态成员变量\n\nstatic void func()\n{\n    cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;\n    m_A = 100;\n    //m_B = 100; //错误，不可以访问非静态成员变量\n}\n\nstatic int m_A; //静态成员变量\nint m_B; //</code></pre><p>private:</p>\n<pre><code>//静态成员函数也是有访问权限的\nstatic void func2()\n{\n    cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;\n}</code></pre><p>};<br>int Person::m_A = 10;</p>\n<p>void test01()<br>{<br>//静态成员变量两种访问方式</p>\n<pre><code>//1、通过对象\nPerson p1;\np1.func();\n\n//2、通过类名\nPerson::func();\n\n\n//Person::func2(); //私有权限访问不到</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3 C++对象模型和 this 指针<br>4.3.1 成员变量和成员函数分开存储<br>在 C++中，类内的成员变量和成员函数分开存储</p>\n<p>只有非静态成员变量才属于类的对象上</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>mA = 0;<br>}<br>//非静态成员变量占对象空间<br>int mA;<br>//静态成员变量不占对象空间<br>static int mB;<br>//函数也不占对象空间，所有函数共享一个函数实例<br>void func() {<br>cout &lt;&lt; “mA:” &lt;&lt; this-&gt;mA &lt;&lt; endl;<br>}<br>//静态成员函数也不占对象空间<br>static void sfunc() {<br>}<br>};</p>\n<p>int main() {</p>\n<pre><code>cout &lt;&lt; sizeof(Person) &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.2 this 指针概念<br>通过 4.3.1 我们知道在 C++中成员变量和成员函数是分开存储的</p>\n<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>\n<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>\n<p>c++通过提供特殊的对象指针，this 指针，解决上述问题。this 指针指向被调用的成员函数所属的对象</p>\n<p>this 指针是隐含每一个非静态成员函数内的一种指针</p>\n<p>this 指针不需要定义，直接使用即可</p>\n<p>this 指针的用途：</p>\n<p>当形参和成员变量同名时，可用 this 指针来区分<br>在类的非静态成员函数中返回对象本身，可使用 return *this<br>C++<br>class Person<br>{<br>public:</p>\n<pre><code>Person(int age)\n{\n    //1、当形参和成员变量同名时，可用this指针来区分\n    this-&gt;age = age;\n}\n\nPerson&amp; PersonAddPerson(Person p)\n{\n    this-&gt;age += p.age;\n    //返回对象本身\n    return *this;\n}\n\nint age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>Person p1(10);<br>cout &lt;&lt; “p1.age = “ &lt;&lt; p1.age &lt;&lt; endl;</p>\n<pre><code>Person p2(10);\np2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\ncout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.3 空指针访问成员函数<br>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针</p>\n<p>如果用到 this 指针，需要加以判断保证代码的健壮性</p>\n<p>示例：</p>\n<p>C++<br>//空指针访问成员函数<br>class Person {<br>public:</p>\n<pre><code>void ShowClassName() {\n    cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;\n}\n\nvoid ShowPerson() {\n    if (this == NULL) {\n        return;\n    }\n    cout &lt;&lt; mAge &lt;&lt; endl;\n}</code></pre><p>public:<br>int mAge;<br>};</p>\n<p>void test01()<br>{<br>Person * p = NULL;<br>p-&gt;ShowClassName(); //空指针，可以调用成员函数<br>p-&gt;ShowPerson(); //但是如果成员函数中用到了 this 指针，就不可以了<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.4 const 修饰成员函数<br>常函数：</p>\n<p>成员函数后加 const 后我们称为这个函数为常函数<br>常函数内不可以修改成员属性<br>成员属性声明时加关键字 mutable 后，在常函数中依然可以修改<br>常对象：</p>\n<p>声明对象前加 const 称该对象为常对象<br>常对象只能调用常函数<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>m_A = 0;<br>m_B = 0;<br>}</p>\n<pre><code>//this指针的本质是一个指针常量，指针的指向不可修改\n//如果想让指针指向的值也不可以修改，需要声明常函数\nvoid ShowPerson() const {\n    //const Type* const pointer;\n    //this = NULL; //不能修改指针的指向 Person* const this;\n    //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的\n\n    //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量\n    this-&gt;m_B = 100;\n}\n\nvoid MyFunc() const {\n    //mA = 10000;\n}</code></pre><p>public:<br>int m_A;<br>mutable int m_B; //可修改 可变的<br>};</p>\n<p>//const 修饰对象 常对象<br>void test01() {</p>\n<pre><code>const Person person; //常量对象\ncout &lt;&lt; person.m_A &lt;&lt; endl;\n//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问\nperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量\n\n//常对象访问成员函数\nperson.MyFunc(); //常对象不能调用const的函数</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.4 友元<br>生活中你的家有客厅(Public)，有你的卧室(Private)</p>\n<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>\n<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>\n<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>\n<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>\n<p>友元的关键字为 ==friend==</p>\n<p>友元的三种实现</p>\n<p>全局函数做友元<br>类做友元<br>成员函数做友元<br>4.4.1 全局函数做友元<br>C++<br>class Building<br>{<br>//告诉编译器 goodGay 全局函数 是 Building 类的好朋友，可以访问类中的私有内容<br>friend void goodGay(Building * building);</p>\n<p>public:</p>\n<pre><code>Building()\n{\n    this-&gt;m_SittingRoom = &quot;客厅&quot;;\n    this-&gt;m_BedRoom = &quot;卧室&quot;;\n}</code></pre><p>public:<br>string m_SittingRoom; //客厅</p>\n<p>private:<br>string m_BedRoom; //卧室<br>};</p>\n<p>void goodGay(Building * building)<br>{<br>cout &lt;&lt; “好基友正在访问： “ &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问： “ &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>Building b;<br>goodGay(&amp;b);<br>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.4.2 类做友元<br>C++<br>class Building;<br>class goodGay<br>{<br>public:</p>\n<pre><code>goodGay();\nvoid visit();</code></pre><p>private:<br>Building *building;<br>};</p>\n<p>class Building<br>{<br>//告诉编译器 goodGay 类是 Building 类的好朋友，可以访问到 Building 类中私有内容<br>friend class goodGay;</p>\n<p>public:<br>Building();</p>\n<p>public:<br>string m_SittingRoom; //客厅<br>private:<br>string m_BedRoom;//卧室<br>};</p>\n<p>Building::Building()<br>{<br>this-&gt;m_SittingRoom = “客厅”;<br>this-&gt;m_BedRoom = “卧室”;<br>}</p>\n<p>goodGay::goodGay()<br>{<br>building = new Building;<br>}</p>\n<p>void goodGay::visit()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>goodGay gg;<br>gg.visit();</p>\n<p>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.4.3 成员函数做友元<br>C++</p>\n<p>class Building;<br>class goodGay<br>{<br>public:</p>\n<pre><code>goodGay();\nvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\nvoid visit2();</code></pre><p>private:<br>Building *building;<br>};</p>\n<p>class Building<br>{<br>//告诉编译器 goodGay 类中的 visit 成员函数 是 Building 好朋友，可以访问私有内容<br>friend void goodGay::visit();</p>\n<p>public:<br>Building();</p>\n<p>public:<br>string m_SittingRoom; //客厅<br>private:<br>string m_BedRoom;//卧室<br>};</p>\n<p>Building::Building()<br>{<br>this-&gt;m_SittingRoom = “客厅”;<br>this-&gt;m_BedRoom = “卧室”;<br>}</p>\n<p>goodGay::goodGay()<br>{<br>building = new Building;<br>}</p>\n<p>void goodGay::visit()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void goodGay::visit2()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>//cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>goodGay gg;<br>gg.visit();</p>\n<p>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.5 运算符重载<br>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>\n<p>4.5.1 加号运算符重载<br>作用：实现两个自定义数据类型相加的运算</p>\n<p>C++<br>class Person {<br>public:<br>Person() {};<br>Person(int a, int b)<br>{<br>this-&gt;m_A = a;<br>this-&gt;m_B = b;<br>}<br>//成员函数实现 + 号运算符重载<br>Person operator+(const Person&amp; p) {<br>Person temp;<br>temp.m_A = this-&gt;m_A + p.m_A;<br>temp.m_B = this-&gt;m_B + p.m_B;<br>return temp;<br>}</p>\n<p>public:<br>int m_A;<br>int m_B;<br>};</p>\n<p>//全局函数实现 + 号运算符重载<br>//Person operator+(const Person&amp; p1, const Person&amp; p2) {<br>// Person temp(0, 0);<br>// temp.m_A = p1.m_A + p2.m_A;<br>// temp.m_B = p1.m_B + p2.m_B;<br>// return temp;<br>//}</p>\n<p>//运算符重载 可以发生函数重载<br>Person operator+(const Person&amp; p2, int val)<br>{<br>Person temp;<br>temp.m_A = p2.m_A + val;<br>temp.m_B = p2.m_B + val;<br>return temp;<br>}</p>\n<p>void test() {</p>\n<pre><code>Person p1(10, 10);\nPerson p2(20, 20);\n\n//成员函数方式\nPerson p3 = p2 + p1;  //相当于 p2.operaor+(p1)\ncout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;\n\n\nPerson p4 = p3 + 10; //相当于 operator+(p3,10)\ncout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结 1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>\n<p>总结 2：不要滥用运算符重载</p>\n<p>4.5.2 左移运算符重载<br>作用：可以输出自定义数据类型</p>\n<p>C++<br>class Person {<br>friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);</p>\n<p>public:</p>\n<pre><code>Person(int a, int b)\n{\n    this-&gt;m_A = a;\n    this-&gt;m_B = b;\n}\n\n//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果\n//void operator&lt;&lt;(Person&amp; p){\n//}</code></pre><p>private:<br>int m_A;<br>int m_B;<br>};</p>\n<p>//全局函数实现左移重载<br>//ostream 对象只能有一个<br>ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) {<br>out &lt;&lt; “a:” &lt;&lt; p.m_A &lt;&lt; “ b:” &lt;&lt; p.m_B;<br>return out;<br>}</p>\n<p>void test() {</p>\n<pre><code>Person p1(10, 20);\n\ncout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>\n<p>4.5.3 递增运算符重载<br>作用： 通过重载递增运算符，实现自己的整型数据</p>\n<p>C++</p>\n<p>class MyInteger {</p>\n<pre><code>friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);</code></pre><p>public:<br>MyInteger() {<br>m_Num = 0;<br>}<br>//前置++<br>MyInteger&amp; operator++() {<br>//先++<br>m_Num++;<br>//再返回<br>return *this;<br>}</p>\n<pre><code>//后置++\nMyInteger operator++(int) {\n    //先返回\n    MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；\n    m_Num++;\n    return temp;\n}</code></pre><p>private:<br>int m_Num;<br>};</p>\n<p>ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) {<br>out &lt;&lt; myint.m_Num;<br>return out;<br>}</p>\n<p>//前置++ 先++ 再返回<br>void test01() {<br>MyInteger myInt;<br>cout &lt;&lt; ++myInt &lt;&lt; endl;<br>cout &lt;&lt; myInt &lt;&lt; endl;<br>}</p>\n<p>//后置++ 先返回 再++<br>void test02() {</p>\n<pre><code>MyInteger myInt;\ncout &lt;&lt; myInt++ &lt;&lt; endl;\ncout &lt;&lt; myInt &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n//test02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 前置递增返回引用，后置递增返回值</p>\n<p>4.5.4 赋值运算符重载<br>c++编译器至少给一个类添加 4 个函数</p>\n<p>默认构造函数(无参，函数体为空)<br>默认析构函数(无参，函数体为空)<br>默认拷贝构造函数，对属性进行值拷贝<br>赋值运算符 operator=, 对属性进行值拷贝<br>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>\n<p>示例：</p>\n<p>C++<br>class Person<br>{<br>public:</p>\n<pre><code>Person(int age)\n{\n    //将年龄数据开辟到堆区\n    m_Age = new int(age);\n}\n\n//重载赋值运算符\nPerson&amp; operator=(Person &amp;p)\n{\n    if (m_Age != NULL)\n    {\n        delete m_Age;\n        m_Age = NULL;\n    }\n    //编译器提供的代码是浅拷贝\n    //m_Age = p.m_Age;\n\n    //提供深拷贝 解决浅拷贝的问题\n    m_Age = new int(*p.m_Age);\n\n    //返回自身\n    return *this;\n}\n\n\n~Person()\n{\n    if (m_Age != NULL)\n    {\n        delete m_Age;\n        m_Age = NULL;\n    }\n}\n\n//年龄的指针\nint *m_Age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>Person p1(18);</p>\n<pre><code>Person p2(20);\n\nPerson p3(30);\n\np3 = p2 = p1; //赋值操作\n\ncout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\n//int a = 10;\n//int b = 20;\n//int c = 30;\n\n//c = b = a;\n//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\n//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.5.5 关系运算符重载<br>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p>\n<p>示例：</p>\n<p>C++<br>class Person<br>{<br>public:<br>Person(string name, int age)<br>{<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>};</p>\n<pre><code>bool operator==(Person &amp; p)\n{\n    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nbool operator!=(Person &amp; p)\n{\n    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}\n\nstring m_Name;\nint m_Age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>//int a = 0;<br>//int b = 0;</p>\n<pre><code>Person a(&quot;孙悟空&quot;, 18);\nPerson b(&quot;孙悟空&quot;, 18);\n\nif (a == b)\n{\n    cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n}\n\nif (a != b)\n{\n    cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.5.6 函数调用运算符重载<br>函数调用运算符 () 也可以重载<br>由于重载后使用的方式非常像函数的调用，因此称为仿函数<br>仿函数没有固定写法，非常灵活<br>示例：</p>\n<p>C++<br>class MyPrint<br>{<br>public:<br>void operator()(string text)<br>{<br>cout &lt;&lt; text &lt;&lt; endl;<br>}</p>\n<p>};<br>void test01()<br>{<br>//重载的（）操作符 也称为仿函数<br>MyPrint myFunc;<br>myFunc(“hello world”);<br>}</p>\n<p>class MyAdd<br>{<br>public:<br>int operator()(int v1, int v2)<br>{<br>return v1 + v2;<br>}<br>};</p>\n<p>void test02()<br>{<br>MyAdd add;<br>int ret = add(10, 10);<br>cout &lt;&lt; “ret = “ &lt;&lt; ret &lt;&lt; endl;</p>\n<pre><code>//匿名对象调用\ncout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.6 继承<br>继承是面向对象三大特性之一</p>\n<p>有些类与类之间存在特殊的关系，例如下图中：</p>\n<p>1544861202252<br>1544861202252</p>\n<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>\n<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>\n<p>4.6.1 继承的基本语法<br>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>\n<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>\n<p>普通实现：</p>\n<p>C++<br>//Java 页面<br>class Java<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “JAVA 学科视频” &lt;&lt; endl;<br>}<br>};<br>//Python 页面<br>class Python<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “Python 学科视频” &lt;&lt; endl;<br>}<br>};<br>//C++页面<br>class CPP<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “C++学科视频” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//Java 页面<br>cout &lt;&lt; “Java 下载视频页面如下： “ &lt;&lt; endl;<br>Java ja;<br>ja.header();<br>ja.footer();<br>ja.left();<br>ja.content();<br>cout &lt;&lt; “——————–” &lt;&lt; endl;</p>\n<pre><code>//Python页面\ncout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\nPython py;\npy.header();\npy.footer();\npy.left();\npy.content();\ncout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n//C++页面\ncout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\nCPP cp;\ncp.header();\ncp.footer();\ncp.left();\ncp.content();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>继承实现：</p>\n<p>C++<br>//公共页面<br>class BasePage<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}</p>\n<pre><code>void footer()\n{\n    cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\n}\nvoid left()\n{\n    cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\n}</code></pre><p>};</p>\n<p>//Java 页面<br>class Java : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “JAVA 学科视频” &lt;&lt; endl;<br>}<br>};<br>//Python 页面<br>class Python : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “Python 学科视频” &lt;&lt; endl;<br>}<br>};<br>//C++页面<br>class CPP : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “C++学科视频” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//Java 页面<br>cout &lt;&lt; “Java 下载视频页面如下： “ &lt;&lt; endl;<br>Java ja;<br>ja.header();<br>ja.footer();<br>ja.left();<br>ja.content();<br>cout &lt;&lt; “——————–” &lt;&lt; endl;</p>\n<pre><code>//Python页面\ncout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\nPython py;\npy.header();\npy.footer();\npy.left();\npy.content();\ncout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n//C++页面\ncout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\nCPP cp;\ncp.header();\ncp.footer();\ncp.left();\ncp.content();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>继承的好处：==可以减少重复的代码==</p>\n<p>class A : public B;</p>\n<p>A 类称为子类 或 派生类</p>\n<p>B 类称为父类 或 基类</p>\n<p>派生类中的成员，包含两大部分：</p>\n<p>一类是从基类继承过来的，一类是自己增加的成员。</p>\n<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>\n<p>4.6.2 继承方式<br>继承的语法：class 子类 : 继承方式 父类</p>\n<p>继承方式一共有三种：</p>\n<p>公共继承<br>保护继承<br>私有继承<br>img<br>img</p>\n<p>示例：</p>\n<p>C++<br>class Base1<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};</p>\n<p>//公共继承<br>class Son1 :public Base1<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 public 权限<br>m_B; //可访问 protected 权限<br>//m_C; //不可访问<br>}<br>};</p>\n<p>void myClass()<br>{<br>Son1 s1;<br>s1.m_A; //其他类只能访问到公共权限<br>}</p>\n<p>//保护继承<br>class Base2<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};<br>class Son2:protected Base2<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 protected 权限<br>m_B; //可访问 protected 权限<br>//m_C; //不可访问<br>}<br>};<br>void myClass2()<br>{<br>Son2 s;<br>//s.m_A; //不可访问<br>}</p>\n<p>//私有继承<br>class Base3<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};<br>class Son3:private Base3<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 private 权限<br>m_B; //可访问 private 权限<br>//m_C; //不可访问<br>}<br>};<br>class GrandSon3 :public Son3<br>{<br>public:<br>void func()<br>{<br>//Son3 是私有继承，所以继承 Son3 的属性在 GrandSon3 中都无法访问到<br>//m_A;<br>//m_B;<br>//m_C;<br>}<br>};<br>4.6.3 继承中的对象模型<br>问题：从父类继承过来的成员，哪些属于子类对象中？</p>\n<p>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C; //私有成员只是被隐藏了，但是还是会继承下去<br>};</p>\n<p>//公共继承<br>class Son :public Base<br>{<br>public:<br>int m_D;<br>};</p>\n<p>void test01()<br>{<br>cout &lt;&lt; “sizeof Son = “ &lt;&lt; sizeof(Son) &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>利用工具查看：</p>\n<p>1545881904150<br>1545881904150</p>\n<p>打开工具窗口后，定位到当前 CPP 文件的盘符</p>\n<p>然后输入： cl /d1 reportSingleClassLayout 查看的类名 所属文件名</p>\n<p>效果如下图：</p>\n<p>1545882158050<br>1545882158050</p>\n<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>\n<p>4.6.4 继承中构造和析构顺序<br>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>\n<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>\n<p>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>Base()<br>{<br>cout &lt;&lt; “Base 构造函数!” &lt;&lt; endl;<br>}<br>~Base()<br>{<br>cout &lt;&lt; “Base 析构函数!” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Son : public Base<br>{<br>public:<br>Son()<br>{<br>cout &lt;&lt; “Son 构造函数!” &lt;&lt; endl;<br>}<br>~Son()<br>{<br>cout &lt;&lt; “Son 析构函数!” &lt;&lt; endl;<br>}</p>\n<p>};</p>\n<p>void test01()<br>{<br>//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反<br>Son s;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>\n<p>4.6.5 继承同名成员处理方式<br>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>\n<p>访问子类同名成员 直接访问即可<br>访问父类同名成员 需要加作用域<br>示例：</p>\n<p>C++<br>class Base {<br>public:<br>Base()<br>{<br>m_A = 100;<br>}</p>\n<pre><code>void func()\n{\n    cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;\n}\n\nvoid func(int a)\n{\n    cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;\n}</code></pre><p>public:<br>int m_A;<br>};</p>\n<p>class Son : public Base {<br>public:<br>Son()<br>{<br>m_A = 200;<br>}</p>\n<pre><code>//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\n//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\nvoid func()\n{\n    cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;\n}</code></pre><p>public:<br>int m_A;<br>};</p>\n<p>void test01()<br>{<br>Son s;</p>\n<pre><code>cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;\ncout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\n\ns.func();\ns.Base::func();\ns.Base::func(10);</code></pre><p>}<br>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn EXIT_SUCCESS;</code></pre><p>}<br>总结：</p>\n<p>子类对象可以直接访问到子类中同名成员<br>子类对象加作用域可以访问到父类同名成员<br>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数<br>4.6.6 继承同名静态成员处理方式<br>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>\n<p>静态成员和非静态成员出现同名，处理方式一致</p>\n<p>访问子类同名成员 直接访问即可<br>访问父类同名成员 需要加作用域<br>示例：</p>\n<p>C++<br>class Base {<br>public:<br>static void func()<br>{<br>cout &lt;&lt; “Base - static void func()” &lt;&lt; endl;<br>}<br>static void func(int a)<br>{<br>cout &lt;&lt; “Base - static void func(int a)” &lt;&lt; endl;<br>}</p>\n<pre><code>static int m_A;</code></pre><p>};</p>\n<p>int Base::m_A = 100;</p>\n<p>class Son : public Base {<br>public:<br>static void func()<br>{<br>cout &lt;&lt; “Son - static void func()” &lt;&lt; endl;<br>}<br>static int m_A;<br>};</p>\n<p>int Son::m_A = 200;</p>\n<p>//同名成员属性<br>void test01()<br>{<br>//通过对象访问<br>cout &lt;&lt; “通过对象访问： “ &lt;&lt; endl;<br>Son s;<br>cout &lt;&lt; “Son 下 m_A = “ &lt;&lt; s.m_A &lt;&lt; endl;<br>cout &lt;&lt; “Base 下 m_A = “ &lt;&lt; s.Base::m_A &lt;&lt; endl;</p>\n<pre><code>//通过类名访问\ncout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;\ncout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;</code></pre><p>}</p>\n<p>//同名成员函数<br>void test02()<br>{<br>//通过对象访问<br>cout &lt;&lt; “通过对象访问： “ &lt;&lt; endl;<br>Son s;<br>s.func();<br>s.Base::func();</p>\n<pre><code>cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\nSon::func();\nSon::Base::func();\n//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\nSon::Base::func(100);</code></pre><p>}<br>int main() {</p>\n<pre><code>//test01();\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>\n<p>4.6.7 多继承语法<br>C++允许一个类继承多个类</p>\n<p>语法：class 子类 ：继承方式 父类 1 ， 继承方式 父类 2…</p>\n<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>\n<p>C++实际开发中不建议用多继承</p>\n<p>示例：</p>\n<p>C++<br>class Base1 {<br>public:<br>Base1()<br>{<br>m_A = 100;<br>}<br>public:<br>int m_A;<br>};</p>\n<p>class Base2 {<br>public:<br>Base2()<br>{<br>m_A = 200; //开始是 m_B 不会出问题，但是改为 mA 就会出现不明确<br>}<br>public:<br>int m_A;<br>};</p>\n<p>//语法：class 子类：继承方式 父类 1 ，继承方式 父类 2<br>class Son : public Base2, public Base1<br>{<br>public:<br>Son()<br>{<br>m_C = 300;<br>m_D = 400;<br>}<br>public:<br>int m_C;<br>int m_D;<br>};</p>\n<p>//多继承容易产生成员同名的情况<br>//通过使用类名作用域可以区分调用哪一个基类的成员<br>void test01()<br>{<br>Son s;<br>cout &lt;&lt; “sizeof Son = “ &lt;&lt; sizeof(s) &lt;&lt; endl;<br>cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;<br>cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>\n<p>4.6.8 菱形继承<br>菱形继承概念：</p>\n<p>​ 两个派生类继承同一个基类</p>\n<p>​ 又有某个类同时继承者两个派生类</p>\n<p>​ 这种继承被称为菱形继承，或者钻石继承</p>\n<p>典型的菱形继承案例：</p>\n<p>IMG_256<br>IMG_256</p>\n<p>菱形继承问题：</p>\n<p>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</p>\n<p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>\n<p>示例：</p>\n<p>C++<br>class Animal<br>{<br>public:<br>int m_Age;<br>};</p>\n<p>//继承前加 virtual 关键字后，变为虚继承<br>//此时公共的父类 Animal 称为虚基类<br>class Sheep : virtual public Animal {};<br>class Tuo : virtual public Animal {};<br>class SheepTuo : public Sheep, public Tuo {};</p>\n<p>void test01()<br>{<br>SheepTuo st;<br>st.Sheep::m_Age = 100;<br>st.Tuo::m_Age = 200;</p>\n<pre><code>cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;\ncout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;\ncout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义<br>利用虚继承可以解决菱形继承问题<br>4.7 多态<br>4.7.1 多态的基本概念<br>多态是 C++面向对象三大特性之一</p>\n<p>多态分为两类</p>\n<p>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名<br>动态多态: 派生类和虚函数实现运行时多态<br>静态多态和动态多态区别：</p>\n<p>静态多态的函数地址早绑定 - 编译阶段确定函数地址<br>动态多态的函数地址晚绑定 - 运行阶段确定函数地址<br>下面通过案例进行讲解多态</p>\n<p>C++<br>class Animal<br>{<br>public:<br>//Speak 函数就是虚函数<br>//函数前面加上 virtual 关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。<br>virtual void speak()<br>{<br>cout &lt;&lt; “动物在说话” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Cat :public Animal<br>{<br>public:<br>void speak()<br>{<br>cout &lt;&lt; “小猫在说话” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Dog :public Animal<br>{<br>public:</p>\n<pre><code>void speak()\n{\n    cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;\n}</code></pre><p>};<br>//我们希望传入什么对象，那么就调用什么对象的函数<br>//如果函数地址在编译阶段就能确定，那么静态联编<br>//如果函数地址在运行阶段才能确定，就是动态联编</p>\n<p>void DoSpeak(Animal &amp; animal)<br>{<br>animal.speak();<br>}<br>//<br>//多态满足条件：<br>//1、有继承关系<br>//2、子类重写父类中的虚函数<br>//多态使用：<br>//父类指针或引用指向子类对象</p>\n<p>void test01()<br>{<br>Cat cat;<br>DoSpeak(cat);</p>\n<pre><code>Dog dog;\nDoSpeak(dog);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>多态满足条件</p>\n<p>有继承关系<br>子类重写父类中的虚函数<br>多态使用条件</p>\n<p>父类指针或引用指向子类对象<br>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p>\n<p>4.7.2 多态案例一-计算器类<br>案例描述：</p>\n<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>\n<p>多态的优点：</p>\n<p>代码组织结构清晰<br>可读性强<br>利于前期和后期的扩展以及维护<br>示例：</p>\n<p>C++<br>//普通实现<br>class Calculator {<br>public:<br>int getResult(string oper)<br>{<br>if (oper == “+”) {<br>return m_Num1 + m_Num2;<br>}<br>else if (oper == “-“) {<br>return m_Num1 - m_Num2;<br>}<br>else if (oper == “_”) {<br>return m_Num1 _ m_Num2;<br>}<br>//如果要提供新的运算，需要修改源码<br>}<br>public:<br>int m_Num1;<br>int m_Num2;<br>};</p>\n<p>void test01()<br>{<br>//普通实现测试<br>Calculator c;<br>c.m_Num1 = 10;<br>c.m_Num2 = 10;<br>cout &lt;&lt; c.m_Num1 &lt;&lt; “ + “ &lt;&lt; c.m_Num2 &lt;&lt; “ = “ &lt;&lt; c.getResult(“+”) &lt;&lt; endl;</p>\n<pre><code>cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;\n\ncout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;</code></pre><p>}</p>\n<p>//多态实现<br>//抽象计算器类<br>//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护<br>class AbstractCalculator<br>{<br>public :</p>\n<pre><code>virtual int getResult()\n{\n    return 0;\n}\n\nint m_Num1;\nint m_Num2;</code></pre><p>};</p>\n<p>//加法计算器<br>class AddCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 + m_Num2;<br>}<br>};</p>\n<p>//减法计算器<br>class SubCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 - m_Num2;<br>}<br>};</p>\n<p>//乘法计算器<br>class MulCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 * m_Num2;<br>}<br>};</p>\n<p>void test02()<br>{<br>//创建加法计算器<br>AbstractCalculator *abc = new AddCalculator;<br>abc-&gt;m_Num1 = 10;<br>abc-&gt;m_Num2 = 10;<br>cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; “ + “ &lt;&lt; abc-&gt;m_Num2 &lt;&lt; “ = “ &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;<br>delete abc; //用完了记得销毁</p>\n<pre><code>//创建减法计算器\nabc = new SubCalculator;\nabc-&gt;m_Num1 = 10;\nabc-&gt;m_Num2 = 10;\ncout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\ndelete abc;\n\n//创建乘法计算器\nabc = new MulCalculator;\nabc-&gt;m_Num1 = 10;\nabc-&gt;m_Num2 = 10;\ncout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\ndelete abc;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>\n<p>4.7.3 纯虚函数和抽象类<br>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>\n<p>因此可以将虚函数改为纯虚函数</p>\n<p>纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ;</p>\n<p>当类中有了纯虚函数，这个类也称为==抽象类==</p>\n<p>抽象类特点：</p>\n<p>无法实例化对象<br>子类必须重写抽象类中的纯虚函数，否则也属于抽象类<br>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>//纯虚函数<br>//类中只要有一个纯虚函数就称为抽象类<br>//抽象类无法实例化对象<br>//子类必须重写父类中的纯虚函数，否则也属于抽象类<br>virtual void func() = 0;<br>};</p>\n<p>class Son :public Base<br>{<br>public:<br>virtual void func()<br>{<br>cout &lt;&lt; “func 调用” &lt;&lt; endl;<br>};<br>};</p>\n<p>void test01()<br>{<br>Base * base = NULL;<br>//base = new Base; // 错误，抽象类无法实例化对象<br>base = new Son;<br>base-&gt;func();<br>delete base;//记得销毁<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.7.4 多态案例二-制作饮品<br>案例描述：</p>\n<p>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</p>\n<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>\n<p>1545985945198<br>1545985945198</p>\n<p>示例：</p>\n<p>C++<br>//抽象制作饮品<br>class AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() = 0;<br>//冲泡<br>virtual void Brew() = 0;<br>//倒入杯中<br>virtual void PourInCup() = 0;<br>//加入辅料<br>virtual void PutSomething() = 0;<br>//规定流程<br>void MakeDrink() {<br>Boil();<br>Brew();<br>PourInCup();<br>PutSomething();<br>}<br>};</p>\n<p>//制作咖啡<br>class Coffee : public AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() {<br>cout &lt;&lt; “煮农夫山泉!” &lt;&lt; endl;<br>}<br>//冲泡<br>virtual void Brew() {<br>cout &lt;&lt; “冲泡咖啡!” &lt;&lt; endl;<br>}<br>//倒入杯中<br>virtual void PourInCup() {<br>cout &lt;&lt; “将咖啡倒入杯中!” &lt;&lt; endl;<br>}<br>//加入辅料<br>virtual void PutSomething() {<br>cout &lt;&lt; “加入牛奶!” &lt;&lt; endl;<br>}<br>};</p>\n<p>//制作茶水<br>class Tea : public AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() {<br>cout &lt;&lt; “煮自来水!” &lt;&lt; endl;<br>}<br>//冲泡<br>virtual void Brew() {<br>cout &lt;&lt; “冲泡茶叶!” &lt;&lt; endl;<br>}<br>//倒入杯中<br>virtual void PourInCup() {<br>cout &lt;&lt; “将茶水倒入杯中!” &lt;&lt; endl;<br>}<br>//加入辅料<br>virtual void PutSomething() {<br>cout &lt;&lt; “加入枸杞!” &lt;&lt; endl;<br>}<br>};</p>\n<p>//业务函数<br>void DoWork(AbstractDrinking* drink) {<br>drink-&gt;MakeDrink();<br>delete drink;<br>}</p>\n<p>void test01() {<br>DoWork(new Coffee);<br>cout &lt;&lt; “————–” &lt;&lt; endl;<br>DoWork(new Tea);<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.7.5 虚析构和纯虚析构<br>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>\n<p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p>\n<p>虚析构和纯虚析构共性：</p>\n<p>可以解决父类指针释放子类对象<br>都需要有具体的函数实现<br>虚析构和纯虚析构区别：</p>\n<p>如果是纯虚析构，该类属于抽象类，无法实例化对象<br>虚析构语法：</p>\n<p>virtual ~类名(){}</p>\n<p>纯虚析构语法：</p>\n<p>virtual ~类名() = 0;</p>\n<p>类名::~类名(){}</p>\n<p>示例：</p>\n<p>C++<br>class Animal {<br>public:</p>\n<pre><code>Animal()\n{\n    cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;\n}\nvirtual void Speak() = 0;\n\n//析构函数加上virtual关键字，变成虚析构函数\n//virtual ~Animal()\n//{\n//    cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;\n//}\n\n\nvirtual ~Animal() = 0;</code></pre><p>};</p>\n<p>Animal::~Animal()<br>{<br>cout &lt;&lt; “Animal 纯虚析构函数调用！” &lt;&lt; endl;<br>}</p>\n<p>//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</p>\n<p>class Cat : public Animal {<br>public:<br>Cat(string name)<br>{<br>cout &lt;&lt; “Cat 构造函数调用！” &lt;&lt; endl;<br>m_Name = new string(name);<br>}<br>virtual void Speak()<br>{<br>cout &lt;&lt; *m_Name &lt;&lt; “小猫在说话!” &lt;&lt; endl;<br>}<br>~Cat()<br>{<br>cout &lt;&lt; “Cat 析构函数调用!” &lt;&lt; endl;<br>if (this-&gt;m_Name != NULL) {<br>delete m_Name;<br>m_Name = NULL;<br>}<br>}</p>\n<p>public:<br>string *m_Name;<br>};</p>\n<p>void test01()<br>{<br>Animal *animal = new Cat(“Tom”);<br>animal-&gt;Speak();</p>\n<pre><code>//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\n//怎么解决？给基类增加一个虚析构函数\n//虚析构函数就是用来解决通过父类指针释放子类对象\ndelete animal;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>\n<p>​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>\n<p>​ 3. 拥有纯虚析构函数的类也属于抽象类</p>\n<p>4.7.6 多态案例三-电脑组装<br>案例描述：</p>\n<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>\n<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如 Intel 厂商和 Lenovo 厂商</p>\n<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>\n<p>测试时组装三台不同的电脑进行工作</p>\n<p>示例：</p>\n<p>C++<br>#include<iostream><br>using namespace std;</p>\n<p>//抽象 CPU 类<br>class CPU<br>{<br>public:<br>//抽象的计算函数<br>virtual void calculate() = 0;<br>};</p>\n<p>//抽象显卡类<br>class VideoCard<br>{<br>public:<br>//抽象的显示函数<br>virtual void display() = 0;<br>};</p>\n<p>//抽象内存条类<br>class Memory<br>{<br>public:<br>//抽象的存储函数<br>virtual void storage() = 0;<br>};</p>\n<p>//电脑类<br>class Computer<br>{<br>public:<br>Computer(CPU _ cpu, VideoCard _ vc, Memory * mem)<br>{<br>m_cpu = cpu;<br>m_vc = vc;<br>m_mem = mem;<br>}</p>\n<pre><code>//提供工作的函数\nvoid work()\n{\n    //让零件工作起来，调用接口\n    m_cpu-&gt;calculate();\n\n    m_vc-&gt;display();\n\n    m_mem-&gt;storage();\n}\n\n//提供析构函数 释放3个电脑零件\n~Computer()\n{\n\n    //释放CPU零件\n    if (m_cpu != NULL)\n    {\n        delete m_cpu;\n        m_cpu = NULL;\n    }\n\n    //释放显卡零件\n    if (m_vc != NULL)\n    {\n        delete m_vc;\n        m_vc = NULL;\n    }\n\n    //释放内存条零件\n    if (m_mem != NULL)\n    {\n        delete m_mem;\n        m_mem = NULL;\n    }\n}</code></pre><p>private:</p>\n<pre><code>CPU * m_cpu; //CPU的零件指针\nVideoCard * m_vc; //显卡零件指针\nMemory * m_mem; //内存条零件指针</code></pre><p>};</p>\n<p>//具体厂商<br>//Intel 厂商<br>class IntelCPU :public CPU<br>{<br>public:<br>virtual void calculate()<br>{<br>cout &lt;&lt; “Intel 的 CPU 开始计算了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class IntelVideoCard :public VideoCard<br>{<br>public:<br>virtual void display()<br>{<br>cout &lt;&lt; “Intel 的显卡开始显示了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class IntelMemory :public Memory<br>{<br>public:<br>virtual void storage()<br>{<br>cout &lt;&lt; “Intel 的内存条开始存储了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>//Lenovo 厂商<br>class LenovoCPU :public CPU<br>{<br>public:<br>virtual void calculate()<br>{<br>cout &lt;&lt; “Lenovo 的 CPU 开始计算了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class LenovoVideoCard :public VideoCard<br>{<br>public:<br>virtual void display()<br>{<br>cout &lt;&lt; “Lenovo 的显卡开始显示了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class LenovoMemory :public Memory<br>{<br>public:<br>virtual void storage()<br>{<br>cout &lt;&lt; “Lenovo 的内存条开始存储了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//第一台电脑零件<br>CPU _ intelCpu = new IntelCPU;<br>VideoCard _ intelCard = new IntelVideoCard;<br>Memory * intelMem = new IntelMemory;</p>\n<pre><code>cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;\n//创建第一台电脑\nComputer * computer1 = new Computer(intelCpu, intelCard, intelMem);\ncomputer1-&gt;work();\ndelete computer1;\n\ncout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;\n//第二台电脑组装\nComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\ncomputer2-&gt;work();\ndelete computer2;\n\ncout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;\n//第三台电脑组装\nComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\ncomputer3-&gt;work();\ndelete computer3;</code></pre><p>}<br>5 文件操作<br>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>\n<p>通过文件可以将数据持久化</p>\n<p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p>\n<p>文件类型分为两种：</p>\n<p>文本文件 - 文件以文本的 ASCII 码形式存储在计算机中<br>二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们<br>操作文件的三大类:</p>\n<p>ofstream：写操作<br>ifstream： 读操作<br>fstream ： 读写操作<br>5.1 文本文件<br>5.1.1 写文件<br>写文件步骤如下：</p>\n<p>包含头文件</p>\n<p>#include <fstream></p>\n<p>创建流对象</p>\n<p>ofstream ofs;</p>\n<p>打开文件</p>\n<p>ofs.open(“文件路径”,打开方式);</p>\n<p>写数据</p>\n<p>ofs &lt;&lt; “写入的数据”;</p>\n<p>关闭文件</p>\n<p>ofs.close();</p>\n<p>文件打开方式：</p>\n<p>打开方式 解释<br>ios::in 为读文件而打开文件<br>ios::out 为写文件而打开文件<br>ios::ate 初始位置：文件尾<br>ios::app 追加方式写文件<br>ios::trunc 如果文件存在先删除，再创建<br>ios::binary 二进制方式<br>注意： 文件打开方式可以配合使用，利用|操作符</p>\n<p>例如：用二进制方式写文件 ios::binary | ios:: out</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream></p>\n<p>void test01()<br>{<br>ofstream ofs;<br>ofs.open(“test.txt”, ios::out);</p>\n<pre><code>ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;\nofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;\nofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;\n\nofs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>文件操作必须包含头文件 fstream<br>读文件可以利用 ofstream ，或者 fstream 类<br>打开文件时候需要指定操作文件的路径，以及打开方式<br>利用&lt;&lt;可以向文件中写数据<br>操作完毕，要关闭文件<br>5.1.2 读文件<br>读文件与写文件步骤相似，但是读取方式相对于比较多</p>\n<p>读文件步骤如下：</p>\n<p>包含头文件</p>\n<p>#include <fstream></p>\n<p>创建流对象</p>\n<p>ifstream ifs;</p>\n<p>打开文件并判断文件是否打开成功</p>\n<p>ifs.open(“文件路径”,打开方式);</p>\n<p>读数据</p>\n<p>四种方式读取</p>\n<p>关闭文件</p>\n<p>ifs.close();</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string><br>void test01()<br>{<br>ifstream ifs;<br>ifs.open(“test.txt”, ios::in);</p>\n<pre><code>if (!ifs.is_open())\n{\n    cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;\n    return;\n}\n\n//第一种方式\n//char buf[1024] = { 0 };\n//while (ifs &gt;&gt; buf)\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\n//第二种\n//char buf[1024] = { 0 };\n//while (ifs.getline(buf,sizeof(buf)))\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\n//第三种\n//string buf;\n//while (getline(ifs, buf))\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\nchar c;\nwhile ((c = ifs.get()) != EOF)\n{\n    cout &lt;&lt; c;\n}\n\nifs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>读文件可以利用 ifstream ，或者 fstream 类<br>利用 is_open 函数可以判断文件是否打开成功<br>close 关闭文件<br>5.2 二进制文件<br>以二进制的方式对文件进行读写操作</p>\n<p>打开方式要指定为 ==ios::binary==</p>\n<p>5.2.1 写文件<br>二进制方式写文件主要利用流对象调用成员函数 write</p>\n<p>函数原型 ：ostream&amp; write(const char * buffer,int len);</p>\n<p>参数解释：字符指针 buffer 指向内存中一段存储空间。len 是读写的字节数</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string></p>\n<p>class Person<br>{<br>public:<br>char m_Name[64];<br>int m_Age;<br>};</p>\n<p>//二进制文件 写文件<br>void test01()<br>{<br>//1、包含头文件</p>\n<pre><code>//2、创建输出流对象\nofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary);\n\n//3、打开文件\n//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);\n\nPerson p = {&quot;张三&quot;  , 18};\n\n//4、写文件\nofs.write((const char *)&amp;p, sizeof(p));\n\n//5、关闭文件\nofs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>文件输出流对象 可以通过 write 函数，以二进制方式写数据<br>5.2.2 读文件<br>二进制方式读文件主要利用流对象调用成员函数 read</p>\n<p>函数原型：istream&amp; read(char *buffer,int len);</p>\n<p>参数解释：字符指针 buffer 指向内存中一段存储空间。len 是读写的字节数</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string></p>\n<p>class Person<br>{<br>public:<br>char m_Name[64];<br>int m_Age;<br>};</p>\n<p>void test01()<br>{<br>ifstream ifs(“person.txt”, ios::in | ios::binary);<br>if (!ifs.is_open())<br>{<br>cout &lt;&lt; “文件打开失败” &lt;&lt; endl;<br>}</p>\n<pre><code>Person p;\nifs.read((char *)&amp;p, sizeof(p));\n\ncout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>文件输入流对象 可以通过 read 函数，以二进制方式读数据</p>\n"},{"title":"A first look at C++ (2) copy 3","url":"/2023/01/18/A%20first%20look%20at%20C++%20(2)%20copy%203/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>C++核心编程<br>本阶段主要针对 C++==面向对象==编程技术做详细讲解，探讨 C++中的核心和精髓。</p>\n<p>1 内存分区模型<br>C++程序在执行时，将内存大方向划分为 4 个区域</p>\n<p>代码区：存放函数体的二进制代码，由操作系统进行管理的<br>全局区：存放全局变量和静态变量以及常量<br>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等<br>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收<br>内存四区意义：</p>\n<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>\n<p>1.1 程序运行前<br>​ 在程序编译后，生成了 exe 可执行程序，未执行该程序前分为两个区域</p>\n<p>​ 代码区：</p>\n<p>​ 存放 CPU 执行的机器指令</p>\n<p>​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>\n<p>​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令</p>\n<p>​ 全局区：</p>\n<p>​ 全局变量和静态变量存放在此.</p>\n<p>​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>\n<p>​ ==该区域的数据在程序结束后由操作系统释放==.</p>\n<p>示例：</p>\n<p>C++<br>//全局变量<br>int g_a = 10;<br>int g_b = 10;</p>\n<p>//全局常量<br>const int c_g_a = 10;<br>const int c_g_b = 10;</p>\n<p>int main() {</p>\n<pre><code>//局部变量\nint a = 10;\nint b = 10;\n\n//打印地址\ncout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;\ncout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;\n\ncout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt;  (int)&amp;g_a &lt;&lt; endl;\ncout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt;  (int)&amp;g_b &lt;&lt; endl;\n\n//静态变量\nstatic int s_a = 10;\nstatic int s_b = 10;\n\ncout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;\ncout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;\n\ncout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;\n\ncout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;\ncout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;\n\nconst int c_l_a = 10;\nconst int c_l_b = 10;\ncout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;\ncout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>打印结果：</p>\n<p>1545017602518<br>1545017602518</p>\n<p>总结：</p>\n<p>C++中在程序运行前分为全局区和代码区<br>代码区特点是共享和只读<br>全局区中存放全局变量、静态变量、常量<br>常量区中存放 const 修饰的全局常量 和 字符串常量<br>1.2 程序运行后<br>​ 栈区：</p>\n<p>​ 由编译器自动分配释放, 存放函数的参数值,局部变量等</p>\n<p>​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>\n<p>示例：</p>\n<p>C++<br>int * func()<br>{<br>int a = 10;<br>return &a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>​ 堆区：</p>\n<p>​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>\n<p>​ 在 C++中主要利用 new 在堆区开辟内存</p>\n<p>示例：</p>\n<p>C++<br>int* func()<br>{<br>int* a = new int(10);<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>堆区数据由程序员管理开辟和释放</p>\n<p>堆区数据利用 new 关键字进行开辟内存</p>\n<p>1.3 new 操作符<br>​ C++中利用==new==操作符在堆区开辟数据</p>\n<p>​ 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p>\n<p>​ 语法：new 数据类型</p>\n<p>​ 利用 new 创建的数据，会返回该数据对应的类型的指针</p>\n<p>示例 1： 基本语法</p>\n<p>C++<br>int* func()<br>{<br>int* a = new int(10);<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\n//利用delete释放堆区数据\ndelete p;\n\n//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：开辟数组</p>\n<p>C++<br>//堆区开辟数组<br>int main() {</p>\n<pre><code>int* arr = new int[10];\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    arr[i] = i + 100;\n}\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    cout &lt;&lt; arr[i] &lt;&lt; endl;\n}\n//释放数组 delete 后加 []\ndelete[] arr;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2 引用<br>2.1 引用的基本使用<br>*作用： *给变量起别名</p>\n<p>语法： 数据类型 &amp;别名 = 原名</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int a = 10;\nint &amp;b = a;\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n\nb = 100;\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2.2 引用注意事项<br>引用必须初始化<br>引用在初始化后，不可以改变<br>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int a = 10;\nint b = 20;\n//int &amp;c; //错误，引用必须初始化\nint &amp;c = a; //一旦初始化后，就不可以更改\nc = b; //这是赋值操作，不是更改引用\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\ncout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2.3 引用做函数参数<br>作用：函数传参时，可以利用引用的技术让形参修饰实参</p>\n<p>优点：可以简化指针修改实参</p>\n<p>示例：</p>\n<p>C++<br>//1. 值传递<br>void mySwap01(int a, int b) {<br>int temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>//2. 地址传递<br>void mySwap02(int* a, int* b) {<br>int temp = *a;<br>*a = *b;<br>*b = temp;<br>}</p>\n<p>//3. 引用传递<br>void mySwap03(int&amp; a, int&amp; b) {<br>int temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>int main() {</p>\n<pre><code>int a = 10;\nint b = 20;\n\nmySwap01(a, b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nmySwap02(&amp;a, &amp;b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nmySwap03(a, b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>\n<p>2.4 引用做函数返回值<br>作用：引用是可以作为函数的返回值存在的</p>\n<p>注意：不要返回局部变量引用</p>\n<p>用法：函数调用作为左值</p>\n<p>示例：</p>\n<p>C++<br>//返回局部变量引用<br>int&amp; test01() {<br>int a = 10; //局部变量<br>return a;<br>}</p>\n<p>//返回静态变量引用<br>int&amp; test02() {<br>static int a = 20;<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>//不能返回局部变量的引用\nint&amp; ref = test01();\ncout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\ncout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\n\n//如果函数做左值，那么必须返回引用\nint&amp; ref2 = test02();\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\ntest02() = 1000;\n\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>​</p>\n<p>2.5 引用的本质<br>本质：引用的本质在 c++内部实现是一个指针常量.</p>\n<p>讲解示例：</p>\n<p>C++<br>//发现是引用，转换为 int* const ref = &a;<br>void func(int&amp; ref){<br>ref = 100; // ref 是引用，转换为*ref = 100<br>}<br>int main(){<br>int a = 10;</p>\n<pre><code>//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改\nint&amp; ref = a;\nref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\n\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;\n\nfunc(a);\nreturn 0;</code></pre><p>}<br>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>\n<p>2.6 常量引用<br>作用：常量引用主要用来修饰形参，防止误操作</p>\n<p>在函数形参列表中，可以加==const 修饰形参==，防止形参改变实参</p>\n<p>示例：</p>\n<p>C++<br>//引用使用的场景，通常用来修饰形参<br>void showValue(const int&amp; v) {<br>//v += 10;<br>cout &lt;&lt; v &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误\n//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;\nconst int&amp; ref = 10;\n\n//ref = 100;  //加入const后不可以修改变量\ncout &lt;&lt; ref &lt;&lt; endl;\n\n//函数中利用常量引用防止误操作修改实参\nint a = 10;\nshowValue(a);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3 函数提高<br>3.1 函数默认参数<br>在 C++中，函数的形参列表中的形参是可以有默认值的。</p>\n<p>语法：返回值类型 函数名 （参数= 默认值）{}</p>\n<p>示例：</p>\n<p>C++<br>int func(int a, int b = 10, int c = 10) {<br>return a + b + c;<br>}</p>\n<p>//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值<br>//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数<br>int func2(int a = 10, int b = 10);<br>int func2(int a, int b) {<br>return a + b;<br>}</p>\n<p>int main() {</p>\n<pre><code>cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;\ncout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.2 函数占位参数<br>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>\n<p>语法： 返回值类型 函数名 (数据类型){}</p>\n<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>\n<p>示例：</p>\n<p>C++<br>//函数占位参数 ，占位参数也可以有默认参数<br>void func(int a, int) {<br>cout &lt;&lt; “this is func” &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>func(10,10); //占位参数必须填补\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.3 函数重载<br>3.3.1 函数重载概述<br>作用：函数名可以相同，提高复用性</p>\n<p>函数重载满足条件：</p>\n<p>同一个作用域下<br>函数名称相同<br>函数参数类型不同 或者 个数不同 或者 顺序不同<br>注意: 函数的返回值不可以作为函数重载的条件</p>\n<p>示例：</p>\n<p>C++<br>//函数重载需要函数都在同一个作用域下<br>void func()<br>{<br>cout &lt;&lt; “func 的调用！” &lt;&lt; endl;<br>}<br>void func(int a)<br>{<br>cout &lt;&lt; “func (int a) 的调用！” &lt;&lt; endl;<br>}<br>void func(double a)<br>{<br>cout &lt;&lt; “func (double a)的调用！” &lt;&lt; endl;<br>}<br>void func(int a ,double b)<br>{<br>cout &lt;&lt; “func (int a ,double b) 的调用！” &lt;&lt; endl;<br>}<br>void func(double a ,int b)<br>{<br>cout &lt;&lt; “func (double a ,int b)的调用！” &lt;&lt; endl;<br>}</p>\n<p>//函数返回值不可以作为函数重载条件<br>//int func(double a, int b)<br>//{<br>// cout &lt;&lt; “func (double a ,int b)的调用！” &lt;&lt; endl;<br>//}</p>\n<p>int main() {</p>\n<pre><code>func();\nfunc(10);\nfunc(3.14);\nfunc(10,3.14);\nfunc(3.14 , 10);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.3.2 函数重载注意事项<br>引用作为重载条件<br>函数重载碰到函数默认参数<br>示例：</p>\n<p>C++<br>//函数重载注意事项<br>//1、引用作为重载条件</p>\n<p>void func(int &amp;a)<br>{<br>cout &lt;&lt; “func (int &amp;a) 调用 “ &lt;&lt; endl;<br>}</p>\n<p>void func(const int &amp;a)<br>{<br>cout &lt;&lt; “func (const int &amp;a) 调用 “ &lt;&lt; endl;<br>}</p>\n<p>//2、函数重载碰到函数默认参数</p>\n<p>void func2(int a, int b = 10)<br>{<br>cout &lt;&lt; “func2(int a, int b = 10) 调用” &lt;&lt; endl;<br>}</p>\n<p>void func2(int a)<br>{<br>cout &lt;&lt; “func2(int a) 调用” &lt;&lt; endl;<br>}</p>\n<p>int main() {<br>int a = 10;<br>func(a); //调用无 const<br>func(10);//调用有 const</p>\n<pre><code>//func2(10); //碰到默认参数产生歧义，需要避免\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4 类和对象<br>C++面向对象的三大特性为：==封装、继承、多态==</p>\n<p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p>\n<p>例如：</p>\n<p>​ 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>\n<p>​ 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>\n<p>​ 具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p>\n<p>4.1 封装<br>4.1.1 封装的意义<br>封装是 C++面向对象三大特性之一</p>\n<p>封装的意义：</p>\n<p>将属性和行为作为一个整体，表现生活中的事物<br>将属性和行为加以权限控制<br>封装意义一：</p>\n<p>​ 在设计类的时候，属性和行为写在一起，表现事物</p>\n<p>语法： class 类名{ 访问权限： 属性 / 行为 };</p>\n<p>示例 1：设计一个圆类，求圆的周长</p>\n<p>示例代码：</p>\n<p>C++<br>//圆周率<br>const double PI = 3.14;</p>\n<p>//1、封装的意义<br>//将属性和行为作为一个整体，用来表现生活中的事物</p>\n<p>//封装一个圆类，求圆的周长<br>//class 代表设计一个类，后面跟着的是类名<br>class Circle<br>{<br>public: //访问权限 公共的权限</p>\n<pre><code>//属性\nint m_r;//半径\n\n//行为\n//获取到圆的周长\ndouble calculateZC()\n{\n    //2 * pi  * r\n    //获取圆的周长\n    return  2 * PI * m_r;\n}</code></pre><p>};</p>\n<p>int main() {</p>\n<pre><code>//通过圆类，创建圆的对象\n// c1就是一个具体的圆\nCircle c1;\nc1.m_r = 10; //给圆对象的半径 进行赋值操作\n\n//2 * pi * 10 = = 62.8\ncout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>\n<p>示例 2 代码：</p>\n<p>C++<br>//学生类<br>class Student {<br>public:<br>void setName(string name) {<br>m_name = name;<br>}<br>void setID(int id) {<br>m_id = id;<br>}</p>\n<pre><code>void showStudent() {\n    cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;\n}</code></pre><p>public:<br>string m_name;<br>int m_id;<br>};</p>\n<p>int main() {</p>\n<pre><code>Student stu;\nstu.setName(&quot;德玛西亚&quot;);\nstu.setID(250);\nstu.showStudent();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>封装意义二：</p>\n<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>\n<p>访问权限有三种：</p>\n<p>public 公共权限<br>protected 保护权限<br>private 私有权限<br>示例：</p>\n<p>C++<br>//三种权限<br>//公共权限 public 类内可以访问 类外可以访问<br>//保护权限 protected 类内可以访问 类外不可以访问<br>//私有权限 private 类内可以访问 类外不可以访问</p>\n<p>class Person<br>{<br>//姓名 公共权限<br>public:<br>string m_Name;</p>\n<pre><code>//汽车  保护权限</code></pre><p>protected:<br>string m_Car;</p>\n<pre><code>//银行卡密码  私有权限</code></pre><p>private:<br>int m_Password;</p>\n<p>public:<br>void func()<br>{<br>m_Name = “张三”;<br>m_Car = “拖拉机”;<br>m_Password = 123456;<br>}<br>};</p>\n<p>int main() {</p>\n<pre><code>Person p;\np.m_Name = &quot;李四&quot;;\n//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到\n//p.m_Password = 123; //私有权限类外访问不到\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.1.2 struct 和 class 区别<br>在 C++中 struct 和 class 唯一的区别就在于 默认的访问权限不同</p>\n<p>区别：</p>\n<p>struct 默认权限为公共<br>class 默认权限为私有<br>C++<br>class C1<br>{<br>int m_A; //默认是私有权限<br>};</p>\n<p>struct C2<br>{<br>int m_A; //默认是公共权限<br>};</p>\n<p>int main() {</p>\n<pre><code>C1 c1;\nc1.m_A = 10; //错误，访问权限是私有\n\nC2 c2;\nc2.m_A = 10; //正确，访问权限是公共\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.1.3 成员属性设置为私有<br>优点 1：将所有成员属性设置为私有，可以自己控制读写权限</p>\n<p>优点 2：对于写权限，我们可以检测数据的有效性</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:</p>\n<pre><code>//姓名设置可读可写\nvoid setName(string name) {\n    m_Name = name;\n}\nstring getName()\n{\n    return m_Name;\n}\n\n\n//获取年龄\nint getAge() {\n    return m_Age;\n}\n//设置年龄\nvoid setAge(int age) {\n    if (age &lt; 0 || age &gt; 150) {\n        cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;\n        return;\n    }\n    m_Age = age;\n}\n\n//情人设置为只写\nvoid setLover(string lover) {\n    m_Lover = lover;\n}</code></pre><p>private:<br>string m_Name; //可读可写 姓名<br>int m_Age; //只读 年龄</p>\n<pre><code>string m_Lover; //只写  情人</code></pre><p>};</p>\n<p>int main() {</p>\n<pre><code>Person p;\n//姓名设置\np.setName(&quot;张三&quot;);\ncout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;\n\n//年龄设置\np.setAge(50);\ncout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;\n\n//情人设置\np.setLover(&quot;苍井&quot;);\n//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>练习案例 1：设计立方体类</p>\n<p>设计立方体类(Cube)</p>\n<p>求出立方体的面积和体积</p>\n<p>分别用全局函数和成员函数判断两个立方体是否相等。</p>\n<p>1545533548532<br>1545533548532</p>\n<p>练习案例 2：点和圆的关系</p>\n<p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p>\n<p>1545533829184<br>1545533829184</p>\n<p>4.2 对象的初始化和清理<br>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全<br>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。<br>4.2.1 构造函数和析构函数<br>对象的初始化和清理也是两个非常重要的安全问题</p>\n<p>​ 一个对象或者变量没有初始状态，对其使用后果是未知</p>\n<p>​ 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>\n<p>c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>\n<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供</p>\n<p>编译器提供的构造函数和析构函数是空实现。</p>\n<p>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。<br>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。<br>构造函数语法：类名(){}</p>\n<p>构造函数，没有返回值也不写 void<br>函数名称与类名相同<br>构造函数可以有参数，因此可以发生重载<br>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次<br>析构函数语法： ~类名(){}</p>\n<p>析构函数，没有返回值也不写 void<br>函数名称与类名相同,在名称前加上符号 ~<br>析构函数不可以有参数，因此不可以发生重载<br>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次<br>C++<br>class Person<br>{<br>public:<br>//构造函数<br>Person()<br>{<br>cout &lt;&lt; “Person 的构造函数调用” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person()<br>{<br>cout &lt;&lt; “Person 的析构函数调用” &lt;&lt; endl;<br>}</p>\n<p>};</p>\n<p>void test01()<br>{<br>Person p;<br>}</p>\n<p>int main() {<br>test01();</p>\n<pre><code>system(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.2 构造函数的分类及调用<br>两种分类方式：</p>\n<p>​ 按参数分为： 有参构造和无参构造</p>\n<p>​ 按类型分为： 普通构造和拷贝构造</p>\n<p>三种调用方式：</p>\n<p>​ 括号法</p>\n<p>​ 显示法</p>\n<p>​ 隐式转换法</p>\n<p>示例：</p>\n<p>C++<br>//1、构造函数分类<br>// 按照参数分类分为 有参和无参构造 无参又称为默认构造函数<br>// 按照类型分类分为 普通构造和拷贝构造</p>\n<p>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int a) {<br>age = a;<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>}<br>//拷贝构造函数<br>Person(const Person&amp; p) {<br>age = p.age;<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int age;<br>};</p>\n<p>//2、构造函数的调用<br>//调用无参构造函数<br>void test01() {<br>Person p; //调用无参构造函数<br>}</p>\n<p>//调用有参的构造函数<br>void test02() {</p>\n<pre><code>//2.1  括号法，常用\nPerson p1(10);\n//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n//Person p2();\n\n//2.2 显式法\nPerson p2 = Person(10);\nPerson p3 = Person(p2);\n//Person(10)单独写就是匿名对象  当前行结束之后，马上析构\n\n//2.3 隐式转换法\nPerson p4 = 10; // Person p4 = Person(10);\nPerson p5 = p4; // Person p5 = Person(p4);\n\n//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\n//Person p5(p4);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n//test02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.3 拷贝构造函数调用时机<br>C++中拷贝构造函数调用时机通常有三种情况</p>\n<p>使用一个已经创建完毕的对象来初始化一个新对象<br>值传递的方式给函数参数传值<br>以值方式返回局部对象<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>mAge = 0;<br>}<br>Person(int age) {<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>mAge = age;<br>}<br>Person(const Person&amp; p) {<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>mAge = p.mAge;<br>}<br>//析构函数在释放内存之前调用<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int mAge;<br>};</p>\n<p>//1. 使用一个已经创建完毕的对象来初始化一个新对象<br>void test01() {</p>\n<pre><code>Person man(100); //p对象已经创建完毕\nPerson newman(man); //调用拷贝构造函数\nPerson newman2 = man; //拷贝构造\n\n//Person newman3;\n//newman3 = man; //不是调用拷贝构造函数，赋值操作</code></pre><p>}</p>\n<p>//2. 值传递的方式给函数参数传值<br>//相当于 Person p1 = p;<br>void doWork(Person p1) {}<br>void test02() {<br>Person p; //无参构造函数<br>doWork(p);<br>}</p>\n<p>//3. 以值方式返回局部对象<br>Person doWork2()<br>{<br>Person p1;<br>cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;<br>return p1;<br>}</p>\n<p>void test03()<br>{<br>Person p = doWork2();<br>cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n//test02();\ntest03();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.4 构造函数调用规则<br>默认情况下，c++编译器至少给一个类添加 3 个函数</p>\n<p>1．默认构造函数(无参，函数体为空)</p>\n<p>2．默认析构函数(无参，函数体为空)</p>\n<p>3．默认拷贝构造函数，对属性进行值拷贝</p>\n<p>构造函数调用规则如下：</p>\n<p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造<br>如果用户定义拷贝构造函数，c++不会再提供其他构造函数<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int a) {<br>age = a;<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>}<br>//拷贝构造函数<br>Person(const Person&amp; p) {<br>age = p.age;<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int age;<br>};</p>\n<p>void test01()<br>{<br>Person p1(18);<br>//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作<br>Person p2(p1);</p>\n<pre><code>cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;</code></pre><p>}</p>\n<p>void test02()<br>{<br>//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造<br>Person p1; //此时如果用户自己没有提供默认构造，会出错<br>Person p2(10); //用户提供的有参<br>Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供</p>\n<pre><code>//如果用户提供拷贝构造，编译器不会提供其他构造函数\nPerson p4; //此时如果用户自己没有提供默认构造，会出错\nPerson p5(10); //此时如果用户自己没有提供有参，会出错\nPerson p6(p5); //用户自己提供拷贝构造</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.5 深拷贝与浅拷贝<br>深浅拷贝是面试经典问题，也是常见的一个坑</p>\n<p>浅拷贝：简单的赋值拷贝操作</p>\n<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int age ,int height) {<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;</p>\n<pre><code>    m_age = age;\n    m_height = new int(height);\n\n}\n//拷贝构造函数\nPerson(const Person&amp; p) {\n    cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n    //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题\n    m_age = p.m_age;\n    m_height = new int(*p.m_height);\n\n}\n\n//析构函数\n~Person() {\n    cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n    if (m_height != NULL)\n    {\n        delete m_height;\n    }\n}</code></pre><p>public:<br>int m_age;<br>int* m_height;<br>};</p>\n<p>void test01()<br>{<br>Person p1(18, 180);</p>\n<pre><code>Person p2(p1);\n\ncout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>\n<p>4.2.6 初始化列表<br>作用：</p>\n<p>C++提供了初始化列表语法，用来初始化属性</p>\n<p>语法：构造函数()：属性 1(值 1),属性 2（值 2）… {}</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:</p>\n<pre><code>////传统方式初始化\n//Person(int a, int b, int c) {\n//    m_A = a;\n//    m_B = b;\n//    m_C = c;\n//}\n\n//初始化列表方式初始化\nPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}\nvoid PrintPerson() {\n    cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;\n    cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;\n    cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;\n}</code></pre><p>private:<br>int m_A;<br>int m_B;<br>int m_C;<br>};</p>\n<p>int main() {</p>\n<pre><code>Person p(1, 2, 3);\np.PrintPerson();\n\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.7 类对象作为类成员<br>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>\n<p>例如：</p>\n<p>C++<br>class A {}<br>class B<br>{<br>A a；<br>}<br>B 类中有对象 A 作为成员，A 为对象成员</p>\n<p>那么当创建 B 对象时，A 与 B 的构造和析构的顺序是谁先谁后？</p>\n<p>示例：</p>\n<p>C++<br>class Phone<br>{<br>public:<br>Phone(string name)<br>{<br>m_PhoneName = name;<br>cout &lt;&lt; “Phone 构造” &lt;&lt; endl;<br>}</p>\n<pre><code>~Phone()\n{\n    cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;\n}\n\nstring m_PhoneName;</code></pre><p>};</p>\n<p>class Person<br>{<br>public:</p>\n<pre><code>//初始化列表可以告诉编译器调用哪一个构造函数\nPerson(string name, string pName) :m_Name(name), m_Phone(pName)\n{\n    cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;\n}\n\n~Person()\n{\n    cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;\n}\n\nvoid playGame()\n{\n    cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;\n}\n\nstring m_Name;\nPhone m_Phone;</code></pre><p>};<br>void test01()<br>{<br>//当类中成员是其他类对象时，我们称该成员为 对象成员<br>//构造的顺序是 ：先调用对象成员的构造，再调用本类构造<br>//析构顺序与构造相反<br>Person p(“张三” , “苹果 X”);<br>p.playGame();</p>\n<p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.8 静态成员<br>静态成员就是在成员变量和成员函数前加上关键字 static，称为静态成员</p>\n<p>静态成员分为：</p>\n<p>静态成员变量<br>所有对象共享同一份数据<br>在编译阶段分配内存<br>类内声明，类外初始化<br>静态成员函数<br>所有对象共享同一个函数<br>静态成员函数只能访问静态成员变量<br>示例 1 ：静态成员变量</p>\n<p>C++<br>class Person<br>{<br>public:</p>\n<pre><code>static int m_A; //静态成员变量\n\n//静态成员变量特点：\n//1 在编译阶段分配内存\n//2 类内声明，类外初始化\n//3 所有对象共享同一份数据</code></pre><p>private:<br>static int m_B; //静态成员变量也是有访问权限的<br>};<br>int Person::m_A = 10;<br>int Person::m_B = 10;</p>\n<p>void test01()<br>{<br>//静态成员变量两种访问方式</p>\n<pre><code>//1、通过对象\nPerson p1;\np1.m_A = 100;\ncout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl;\n\nPerson p2;\np2.m_A = 200;\ncout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据\ncout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl;\n\n//2、通过类名\ncout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl;\n\n\n//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：静态成员函数</p>\n<p>C++<br>class Person<br>{</p>\n<p>public:</p>\n<pre><code>//静态成员函数特点：\n//1 程序共享一个函数\n//2 静态成员函数只能访问静态成员变量\n\nstatic void func()\n{\n    cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;\n    m_A = 100;\n    //m_B = 100; //错误，不可以访问非静态成员变量\n}\n\nstatic int m_A; //静态成员变量\nint m_B; //</code></pre><p>private:</p>\n<pre><code>//静态成员函数也是有访问权限的\nstatic void func2()\n{\n    cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;\n}</code></pre><p>};<br>int Person::m_A = 10;</p>\n<p>void test01()<br>{<br>//静态成员变量两种访问方式</p>\n<pre><code>//1、通过对象\nPerson p1;\np1.func();\n\n//2、通过类名\nPerson::func();\n\n\n//Person::func2(); //私有权限访问不到</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3 C++对象模型和 this 指针<br>4.3.1 成员变量和成员函数分开存储<br>在 C++中，类内的成员变量和成员函数分开存储</p>\n<p>只有非静态成员变量才属于类的对象上</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>mA = 0;<br>}<br>//非静态成员变量占对象空间<br>int mA;<br>//静态成员变量不占对象空间<br>static int mB;<br>//函数也不占对象空间，所有函数共享一个函数实例<br>void func() {<br>cout &lt;&lt; “mA:” &lt;&lt; this-&gt;mA &lt;&lt; endl;<br>}<br>//静态成员函数也不占对象空间<br>static void sfunc() {<br>}<br>};</p>\n<p>int main() {</p>\n<pre><code>cout &lt;&lt; sizeof(Person) &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.2 this 指针概念<br>通过 4.3.1 我们知道在 C++中成员变量和成员函数是分开存储的</p>\n<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>\n<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>\n<p>c++通过提供特殊的对象指针，this 指针，解决上述问题。this 指针指向被调用的成员函数所属的对象</p>\n<p>this 指针是隐含每一个非静态成员函数内的一种指针</p>\n<p>this 指针不需要定义，直接使用即可</p>\n<p>this 指针的用途：</p>\n<p>当形参和成员变量同名时，可用 this 指针来区分<br>在类的非静态成员函数中返回对象本身，可使用 return *this<br>C++<br>class Person<br>{<br>public:</p>\n<pre><code>Person(int age)\n{\n    //1、当形参和成员变量同名时，可用this指针来区分\n    this-&gt;age = age;\n}\n\nPerson&amp; PersonAddPerson(Person p)\n{\n    this-&gt;age += p.age;\n    //返回对象本身\n    return *this;\n}\n\nint age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>Person p1(10);<br>cout &lt;&lt; “p1.age = “ &lt;&lt; p1.age &lt;&lt; endl;</p>\n<pre><code>Person p2(10);\np2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\ncout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.3 空指针访问成员函数<br>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针</p>\n<p>如果用到 this 指针，需要加以判断保证代码的健壮性</p>\n<p>示例：</p>\n<p>C++<br>//空指针访问成员函数<br>class Person {<br>public:</p>\n<pre><code>void ShowClassName() {\n    cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;\n}\n\nvoid ShowPerson() {\n    if (this == NULL) {\n        return;\n    }\n    cout &lt;&lt; mAge &lt;&lt; endl;\n}</code></pre><p>public:<br>int mAge;<br>};</p>\n<p>void test01()<br>{<br>Person * p = NULL;<br>p-&gt;ShowClassName(); //空指针，可以调用成员函数<br>p-&gt;ShowPerson(); //但是如果成员函数中用到了 this 指针，就不可以了<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.4 const 修饰成员函数<br>常函数：</p>\n<p>成员函数后加 const 后我们称为这个函数为常函数<br>常函数内不可以修改成员属性<br>成员属性声明时加关键字 mutable 后，在常函数中依然可以修改<br>常对象：</p>\n<p>声明对象前加 const 称该对象为常对象<br>常对象只能调用常函数<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>m_A = 0;<br>m_B = 0;<br>}</p>\n<pre><code>//this指针的本质是一个指针常量，指针的指向不可修改\n//如果想让指针指向的值也不可以修改，需要声明常函数\nvoid ShowPerson() const {\n    //const Type* const pointer;\n    //this = NULL; //不能修改指针的指向 Person* const this;\n    //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的\n\n    //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量\n    this-&gt;m_B = 100;\n}\n\nvoid MyFunc() const {\n    //mA = 10000;\n}</code></pre><p>public:<br>int m_A;<br>mutable int m_B; //可修改 可变的<br>};</p>\n<p>//const 修饰对象 常对象<br>void test01() {</p>\n<pre><code>const Person person; //常量对象\ncout &lt;&lt; person.m_A &lt;&lt; endl;\n//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问\nperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量\n\n//常对象访问成员函数\nperson.MyFunc(); //常对象不能调用const的函数</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.4 友元<br>生活中你的家有客厅(Public)，有你的卧室(Private)</p>\n<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>\n<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>\n<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>\n<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>\n<p>友元的关键字为 ==friend==</p>\n<p>友元的三种实现</p>\n<p>全局函数做友元<br>类做友元<br>成员函数做友元<br>4.4.1 全局函数做友元<br>C++<br>class Building<br>{<br>//告诉编译器 goodGay 全局函数 是 Building 类的好朋友，可以访问类中的私有内容<br>friend void goodGay(Building * building);</p>\n<p>public:</p>\n<pre><code>Building()\n{\n    this-&gt;m_SittingRoom = &quot;客厅&quot;;\n    this-&gt;m_BedRoom = &quot;卧室&quot;;\n}</code></pre><p>public:<br>string m_SittingRoom; //客厅</p>\n<p>private:<br>string m_BedRoom; //卧室<br>};</p>\n<p>void goodGay(Building * building)<br>{<br>cout &lt;&lt; “好基友正在访问： “ &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问： “ &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>Building b;<br>goodGay(&amp;b);<br>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.4.2 类做友元<br>C++<br>class Building;<br>class goodGay<br>{<br>public:</p>\n<pre><code>goodGay();\nvoid visit();</code></pre><p>private:<br>Building *building;<br>};</p>\n<p>class Building<br>{<br>//告诉编译器 goodGay 类是 Building 类的好朋友，可以访问到 Building 类中私有内容<br>friend class goodGay;</p>\n<p>public:<br>Building();</p>\n<p>public:<br>string m_SittingRoom; //客厅<br>private:<br>string m_BedRoom;//卧室<br>};</p>\n<p>Building::Building()<br>{<br>this-&gt;m_SittingRoom = “客厅”;<br>this-&gt;m_BedRoom = “卧室”;<br>}</p>\n<p>goodGay::goodGay()<br>{<br>building = new Building;<br>}</p>\n<p>void goodGay::visit()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>goodGay gg;<br>gg.visit();</p>\n<p>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.4.3 成员函数做友元<br>C++</p>\n<p>class Building;<br>class goodGay<br>{<br>public:</p>\n<pre><code>goodGay();\nvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\nvoid visit2();</code></pre><p>private:<br>Building *building;<br>};</p>\n<p>class Building<br>{<br>//告诉编译器 goodGay 类中的 visit 成员函数 是 Building 好朋友，可以访问私有内容<br>friend void goodGay::visit();</p>\n<p>public:<br>Building();</p>\n<p>public:<br>string m_SittingRoom; //客厅<br>private:<br>string m_BedRoom;//卧室<br>};</p>\n<p>Building::Building()<br>{<br>this-&gt;m_SittingRoom = “客厅”;<br>this-&gt;m_BedRoom = “卧室”;<br>}</p>\n<p>goodGay::goodGay()<br>{<br>building = new Building;<br>}</p>\n<p>void goodGay::visit()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void goodGay::visit2()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>//cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>goodGay gg;<br>gg.visit();</p>\n<p>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.5 运算符重载<br>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>\n<p>4.5.1 加号运算符重载<br>作用：实现两个自定义数据类型相加的运算</p>\n<p>C++<br>class Person {<br>public:<br>Person() {};<br>Person(int a, int b)<br>{<br>this-&gt;m_A = a;<br>this-&gt;m_B = b;<br>}<br>//成员函数实现 + 号运算符重载<br>Person operator+(const Person&amp; p) {<br>Person temp;<br>temp.m_A = this-&gt;m_A + p.m_A;<br>temp.m_B = this-&gt;m_B + p.m_B;<br>return temp;<br>}</p>\n<p>public:<br>int m_A;<br>int m_B;<br>};</p>\n<p>//全局函数实现 + 号运算符重载<br>//Person operator+(const Person&amp; p1, const Person&amp; p2) {<br>// Person temp(0, 0);<br>// temp.m_A = p1.m_A + p2.m_A;<br>// temp.m_B = p1.m_B + p2.m_B;<br>// return temp;<br>//}</p>\n<p>//运算符重载 可以发生函数重载<br>Person operator+(const Person&amp; p2, int val)<br>{<br>Person temp;<br>temp.m_A = p2.m_A + val;<br>temp.m_B = p2.m_B + val;<br>return temp;<br>}</p>\n<p>void test() {</p>\n<pre><code>Person p1(10, 10);\nPerson p2(20, 20);\n\n//成员函数方式\nPerson p3 = p2 + p1;  //相当于 p2.operaor+(p1)\ncout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;\n\n\nPerson p4 = p3 + 10; //相当于 operator+(p3,10)\ncout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结 1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>\n<p>总结 2：不要滥用运算符重载</p>\n<p>4.5.2 左移运算符重载<br>作用：可以输出自定义数据类型</p>\n<p>C++<br>class Person {<br>friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);</p>\n<p>public:</p>\n<pre><code>Person(int a, int b)\n{\n    this-&gt;m_A = a;\n    this-&gt;m_B = b;\n}\n\n//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果\n//void operator&lt;&lt;(Person&amp; p){\n//}</code></pre><p>private:<br>int m_A;<br>int m_B;<br>};</p>\n<p>//全局函数实现左移重载<br>//ostream 对象只能有一个<br>ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) {<br>out &lt;&lt; “a:” &lt;&lt; p.m_A &lt;&lt; “ b:” &lt;&lt; p.m_B;<br>return out;<br>}</p>\n<p>void test() {</p>\n<pre><code>Person p1(10, 20);\n\ncout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>\n<p>4.5.3 递增运算符重载<br>作用： 通过重载递增运算符，实现自己的整型数据</p>\n<p>C++</p>\n<p>class MyInteger {</p>\n<pre><code>friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);</code></pre><p>public:<br>MyInteger() {<br>m_Num = 0;<br>}<br>//前置++<br>MyInteger&amp; operator++() {<br>//先++<br>m_Num++;<br>//再返回<br>return *this;<br>}</p>\n<pre><code>//后置++\nMyInteger operator++(int) {\n    //先返回\n    MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；\n    m_Num++;\n    return temp;\n}</code></pre><p>private:<br>int m_Num;<br>};</p>\n<p>ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) {<br>out &lt;&lt; myint.m_Num;<br>return out;<br>}</p>\n<p>//前置++ 先++ 再返回<br>void test01() {<br>MyInteger myInt;<br>cout &lt;&lt; ++myInt &lt;&lt; endl;<br>cout &lt;&lt; myInt &lt;&lt; endl;<br>}</p>\n<p>//后置++ 先返回 再++<br>void test02() {</p>\n<pre><code>MyInteger myInt;\ncout &lt;&lt; myInt++ &lt;&lt; endl;\ncout &lt;&lt; myInt &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n//test02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 前置递增返回引用，后置递增返回值</p>\n<p>4.5.4 赋值运算符重载<br>c++编译器至少给一个类添加 4 个函数</p>\n<p>默认构造函数(无参，函数体为空)<br>默认析构函数(无参，函数体为空)<br>默认拷贝构造函数，对属性进行值拷贝<br>赋值运算符 operator=, 对属性进行值拷贝<br>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>\n<p>示例：</p>\n<p>C++<br>class Person<br>{<br>public:</p>\n<pre><code>Person(int age)\n{\n    //将年龄数据开辟到堆区\n    m_Age = new int(age);\n}\n\n//重载赋值运算符\nPerson&amp; operator=(Person &amp;p)\n{\n    if (m_Age != NULL)\n    {\n        delete m_Age;\n        m_Age = NULL;\n    }\n    //编译器提供的代码是浅拷贝\n    //m_Age = p.m_Age;\n\n    //提供深拷贝 解决浅拷贝的问题\n    m_Age = new int(*p.m_Age);\n\n    //返回自身\n    return *this;\n}\n\n\n~Person()\n{\n    if (m_Age != NULL)\n    {\n        delete m_Age;\n        m_Age = NULL;\n    }\n}\n\n//年龄的指针\nint *m_Age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>Person p1(18);</p>\n<pre><code>Person p2(20);\n\nPerson p3(30);\n\np3 = p2 = p1; //赋值操作\n\ncout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\n//int a = 10;\n//int b = 20;\n//int c = 30;\n\n//c = b = a;\n//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\n//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.5.5 关系运算符重载<br>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p>\n<p>示例：</p>\n<p>C++<br>class Person<br>{<br>public:<br>Person(string name, int age)<br>{<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>};</p>\n<pre><code>bool operator==(Person &amp; p)\n{\n    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nbool operator!=(Person &amp; p)\n{\n    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}\n\nstring m_Name;\nint m_Age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>//int a = 0;<br>//int b = 0;</p>\n<pre><code>Person a(&quot;孙悟空&quot;, 18);\nPerson b(&quot;孙悟空&quot;, 18);\n\nif (a == b)\n{\n    cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n}\n\nif (a != b)\n{\n    cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.5.6 函数调用运算符重载<br>函数调用运算符 () 也可以重载<br>由于重载后使用的方式非常像函数的调用，因此称为仿函数<br>仿函数没有固定写法，非常灵活<br>示例：</p>\n<p>C++<br>class MyPrint<br>{<br>public:<br>void operator()(string text)<br>{<br>cout &lt;&lt; text &lt;&lt; endl;<br>}</p>\n<p>};<br>void test01()<br>{<br>//重载的（）操作符 也称为仿函数<br>MyPrint myFunc;<br>myFunc(“hello world”);<br>}</p>\n<p>class MyAdd<br>{<br>public:<br>int operator()(int v1, int v2)<br>{<br>return v1 + v2;<br>}<br>};</p>\n<p>void test02()<br>{<br>MyAdd add;<br>int ret = add(10, 10);<br>cout &lt;&lt; “ret = “ &lt;&lt; ret &lt;&lt; endl;</p>\n<pre><code>//匿名对象调用\ncout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.6 继承<br>继承是面向对象三大特性之一</p>\n<p>有些类与类之间存在特殊的关系，例如下图中：</p>\n<p>1544861202252<br>1544861202252</p>\n<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>\n<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>\n<p>4.6.1 继承的基本语法<br>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>\n<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>\n<p>普通实现：</p>\n<p>C++<br>//Java 页面<br>class Java<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “JAVA 学科视频” &lt;&lt; endl;<br>}<br>};<br>//Python 页面<br>class Python<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “Python 学科视频” &lt;&lt; endl;<br>}<br>};<br>//C++页面<br>class CPP<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “C++学科视频” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//Java 页面<br>cout &lt;&lt; “Java 下载视频页面如下： “ &lt;&lt; endl;<br>Java ja;<br>ja.header();<br>ja.footer();<br>ja.left();<br>ja.content();<br>cout &lt;&lt; “——————–” &lt;&lt; endl;</p>\n<pre><code>//Python页面\ncout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\nPython py;\npy.header();\npy.footer();\npy.left();\npy.content();\ncout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n//C++页面\ncout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\nCPP cp;\ncp.header();\ncp.footer();\ncp.left();\ncp.content();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>继承实现：</p>\n<p>C++<br>//公共页面<br>class BasePage<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}</p>\n<pre><code>void footer()\n{\n    cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\n}\nvoid left()\n{\n    cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\n}</code></pre><p>};</p>\n<p>//Java 页面<br>class Java : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “JAVA 学科视频” &lt;&lt; endl;<br>}<br>};<br>//Python 页面<br>class Python : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “Python 学科视频” &lt;&lt; endl;<br>}<br>};<br>//C++页面<br>class CPP : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “C++学科视频” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//Java 页面<br>cout &lt;&lt; “Java 下载视频页面如下： “ &lt;&lt; endl;<br>Java ja;<br>ja.header();<br>ja.footer();<br>ja.left();<br>ja.content();<br>cout &lt;&lt; “——————–” &lt;&lt; endl;</p>\n<pre><code>//Python页面\ncout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\nPython py;\npy.header();\npy.footer();\npy.left();\npy.content();\ncout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n//C++页面\ncout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\nCPP cp;\ncp.header();\ncp.footer();\ncp.left();\ncp.content();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>继承的好处：==可以减少重复的代码==</p>\n<p>class A : public B;</p>\n<p>A 类称为子类 或 派生类</p>\n<p>B 类称为父类 或 基类</p>\n<p>派生类中的成员，包含两大部分：</p>\n<p>一类是从基类继承过来的，一类是自己增加的成员。</p>\n<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>\n<p>4.6.2 继承方式<br>继承的语法：class 子类 : 继承方式 父类</p>\n<p>继承方式一共有三种：</p>\n<p>公共继承<br>保护继承<br>私有继承<br>img<br>img</p>\n<p>示例：</p>\n<p>C++<br>class Base1<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};</p>\n<p>//公共继承<br>class Son1 :public Base1<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 public 权限<br>m_B; //可访问 protected 权限<br>//m_C; //不可访问<br>}<br>};</p>\n<p>void myClass()<br>{<br>Son1 s1;<br>s1.m_A; //其他类只能访问到公共权限<br>}</p>\n<p>//保护继承<br>class Base2<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};<br>class Son2:protected Base2<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 protected 权限<br>m_B; //可访问 protected 权限<br>//m_C; //不可访问<br>}<br>};<br>void myClass2()<br>{<br>Son2 s;<br>//s.m_A; //不可访问<br>}</p>\n<p>//私有继承<br>class Base3<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};<br>class Son3:private Base3<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 private 权限<br>m_B; //可访问 private 权限<br>//m_C; //不可访问<br>}<br>};<br>class GrandSon3 :public Son3<br>{<br>public:<br>void func()<br>{<br>//Son3 是私有继承，所以继承 Son3 的属性在 GrandSon3 中都无法访问到<br>//m_A;<br>//m_B;<br>//m_C;<br>}<br>};<br>4.6.3 继承中的对象模型<br>问题：从父类继承过来的成员，哪些属于子类对象中？</p>\n<p>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C; //私有成员只是被隐藏了，但是还是会继承下去<br>};</p>\n<p>//公共继承<br>class Son :public Base<br>{<br>public:<br>int m_D;<br>};</p>\n<p>void test01()<br>{<br>cout &lt;&lt; “sizeof Son = “ &lt;&lt; sizeof(Son) &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>利用工具查看：</p>\n<p>1545881904150<br>1545881904150</p>\n<p>打开工具窗口后，定位到当前 CPP 文件的盘符</p>\n<p>然后输入： cl /d1 reportSingleClassLayout 查看的类名 所属文件名</p>\n<p>效果如下图：</p>\n<p>1545882158050<br>1545882158050</p>\n<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>\n<p>4.6.4 继承中构造和析构顺序<br>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>\n<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>\n<p>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>Base()<br>{<br>cout &lt;&lt; “Base 构造函数!” &lt;&lt; endl;<br>}<br>~Base()<br>{<br>cout &lt;&lt; “Base 析构函数!” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Son : public Base<br>{<br>public:<br>Son()<br>{<br>cout &lt;&lt; “Son 构造函数!” &lt;&lt; endl;<br>}<br>~Son()<br>{<br>cout &lt;&lt; “Son 析构函数!” &lt;&lt; endl;<br>}</p>\n<p>};</p>\n<p>void test01()<br>{<br>//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反<br>Son s;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>\n<p>4.6.5 继承同名成员处理方式<br>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>\n<p>访问子类同名成员 直接访问即可<br>访问父类同名成员 需要加作用域<br>示例：</p>\n<p>C++<br>class Base {<br>public:<br>Base()<br>{<br>m_A = 100;<br>}</p>\n<pre><code>void func()\n{\n    cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;\n}\n\nvoid func(int a)\n{\n    cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;\n}</code></pre><p>public:<br>int m_A;<br>};</p>\n<p>class Son : public Base {<br>public:<br>Son()<br>{<br>m_A = 200;<br>}</p>\n<pre><code>//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\n//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\nvoid func()\n{\n    cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;\n}</code></pre><p>public:<br>int m_A;<br>};</p>\n<p>void test01()<br>{<br>Son s;</p>\n<pre><code>cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;\ncout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\n\ns.func();\ns.Base::func();\ns.Base::func(10);</code></pre><p>}<br>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn EXIT_SUCCESS;</code></pre><p>}<br>总结：</p>\n<p>子类对象可以直接访问到子类中同名成员<br>子类对象加作用域可以访问到父类同名成员<br>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数<br>4.6.6 继承同名静态成员处理方式<br>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>\n<p>静态成员和非静态成员出现同名，处理方式一致</p>\n<p>访问子类同名成员 直接访问即可<br>访问父类同名成员 需要加作用域<br>示例：</p>\n<p>C++<br>class Base {<br>public:<br>static void func()<br>{<br>cout &lt;&lt; “Base - static void func()” &lt;&lt; endl;<br>}<br>static void func(int a)<br>{<br>cout &lt;&lt; “Base - static void func(int a)” &lt;&lt; endl;<br>}</p>\n<pre><code>static int m_A;</code></pre><p>};</p>\n<p>int Base::m_A = 100;</p>\n<p>class Son : public Base {<br>public:<br>static void func()<br>{<br>cout &lt;&lt; “Son - static void func()” &lt;&lt; endl;<br>}<br>static int m_A;<br>};</p>\n<p>int Son::m_A = 200;</p>\n<p>//同名成员属性<br>void test01()<br>{<br>//通过对象访问<br>cout &lt;&lt; “通过对象访问： “ &lt;&lt; endl;<br>Son s;<br>cout &lt;&lt; “Son 下 m_A = “ &lt;&lt; s.m_A &lt;&lt; endl;<br>cout &lt;&lt; “Base 下 m_A = “ &lt;&lt; s.Base::m_A &lt;&lt; endl;</p>\n<pre><code>//通过类名访问\ncout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;\ncout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;</code></pre><p>}</p>\n<p>//同名成员函数<br>void test02()<br>{<br>//通过对象访问<br>cout &lt;&lt; “通过对象访问： “ &lt;&lt; endl;<br>Son s;<br>s.func();<br>s.Base::func();</p>\n<pre><code>cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\nSon::func();\nSon::Base::func();\n//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\nSon::Base::func(100);</code></pre><p>}<br>int main() {</p>\n<pre><code>//test01();\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>\n<p>4.6.7 多继承语法<br>C++允许一个类继承多个类</p>\n<p>语法：class 子类 ：继承方式 父类 1 ， 继承方式 父类 2…</p>\n<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>\n<p>C++实际开发中不建议用多继承</p>\n<p>示例：</p>\n<p>C++<br>class Base1 {<br>public:<br>Base1()<br>{<br>m_A = 100;<br>}<br>public:<br>int m_A;<br>};</p>\n<p>class Base2 {<br>public:<br>Base2()<br>{<br>m_A = 200; //开始是 m_B 不会出问题，但是改为 mA 就会出现不明确<br>}<br>public:<br>int m_A;<br>};</p>\n<p>//语法：class 子类：继承方式 父类 1 ，继承方式 父类 2<br>class Son : public Base2, public Base1<br>{<br>public:<br>Son()<br>{<br>m_C = 300;<br>m_D = 400;<br>}<br>public:<br>int m_C;<br>int m_D;<br>};</p>\n<p>//多继承容易产生成员同名的情况<br>//通过使用类名作用域可以区分调用哪一个基类的成员<br>void test01()<br>{<br>Son s;<br>cout &lt;&lt; “sizeof Son = “ &lt;&lt; sizeof(s) &lt;&lt; endl;<br>cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;<br>cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>\n<p>4.6.8 菱形继承<br>菱形继承概念：</p>\n<p>​ 两个派生类继承同一个基类</p>\n<p>​ 又有某个类同时继承者两个派生类</p>\n<p>​ 这种继承被称为菱形继承，或者钻石继承</p>\n<p>典型的菱形继承案例：</p>\n<p>IMG_256<br>IMG_256</p>\n<p>菱形继承问题：</p>\n<p>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</p>\n<p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>\n<p>示例：</p>\n<p>C++<br>class Animal<br>{<br>public:<br>int m_Age;<br>};</p>\n<p>//继承前加 virtual 关键字后，变为虚继承<br>//此时公共的父类 Animal 称为虚基类<br>class Sheep : virtual public Animal {};<br>class Tuo : virtual public Animal {};<br>class SheepTuo : public Sheep, public Tuo {};</p>\n<p>void test01()<br>{<br>SheepTuo st;<br>st.Sheep::m_Age = 100;<br>st.Tuo::m_Age = 200;</p>\n<pre><code>cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;\ncout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;\ncout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义<br>利用虚继承可以解决菱形继承问题<br>4.7 多态<br>4.7.1 多态的基本概念<br>多态是 C++面向对象三大特性之一</p>\n<p>多态分为两类</p>\n<p>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名<br>动态多态: 派生类和虚函数实现运行时多态<br>静态多态和动态多态区别：</p>\n<p>静态多态的函数地址早绑定 - 编译阶段确定函数地址<br>动态多态的函数地址晚绑定 - 运行阶段确定函数地址<br>下面通过案例进行讲解多态</p>\n<p>C++<br>class Animal<br>{<br>public:<br>//Speak 函数就是虚函数<br>//函数前面加上 virtual 关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。<br>virtual void speak()<br>{<br>cout &lt;&lt; “动物在说话” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Cat :public Animal<br>{<br>public:<br>void speak()<br>{<br>cout &lt;&lt; “小猫在说话” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Dog :public Animal<br>{<br>public:</p>\n<pre><code>void speak()\n{\n    cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;\n}</code></pre><p>};<br>//我们希望传入什么对象，那么就调用什么对象的函数<br>//如果函数地址在编译阶段就能确定，那么静态联编<br>//如果函数地址在运行阶段才能确定，就是动态联编</p>\n<p>void DoSpeak(Animal &amp; animal)<br>{<br>animal.speak();<br>}<br>//<br>//多态满足条件：<br>//1、有继承关系<br>//2、子类重写父类中的虚函数<br>//多态使用：<br>//父类指针或引用指向子类对象</p>\n<p>void test01()<br>{<br>Cat cat;<br>DoSpeak(cat);</p>\n<pre><code>Dog dog;\nDoSpeak(dog);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>多态满足条件</p>\n<p>有继承关系<br>子类重写父类中的虚函数<br>多态使用条件</p>\n<p>父类指针或引用指向子类对象<br>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p>\n<p>4.7.2 多态案例一-计算器类<br>案例描述：</p>\n<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>\n<p>多态的优点：</p>\n<p>代码组织结构清晰<br>可读性强<br>利于前期和后期的扩展以及维护<br>示例：</p>\n<p>C++<br>//普通实现<br>class Calculator {<br>public:<br>int getResult(string oper)<br>{<br>if (oper == “+”) {<br>return m_Num1 + m_Num2;<br>}<br>else if (oper == “-“) {<br>return m_Num1 - m_Num2;<br>}<br>else if (oper == “_”) {<br>return m_Num1 _ m_Num2;<br>}<br>//如果要提供新的运算，需要修改源码<br>}<br>public:<br>int m_Num1;<br>int m_Num2;<br>};</p>\n<p>void test01()<br>{<br>//普通实现测试<br>Calculator c;<br>c.m_Num1 = 10;<br>c.m_Num2 = 10;<br>cout &lt;&lt; c.m_Num1 &lt;&lt; “ + “ &lt;&lt; c.m_Num2 &lt;&lt; “ = “ &lt;&lt; c.getResult(“+”) &lt;&lt; endl;</p>\n<pre><code>cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;\n\ncout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;</code></pre><p>}</p>\n<p>//多态实现<br>//抽象计算器类<br>//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护<br>class AbstractCalculator<br>{<br>public :</p>\n<pre><code>virtual int getResult()\n{\n    return 0;\n}\n\nint m_Num1;\nint m_Num2;</code></pre><p>};</p>\n<p>//加法计算器<br>class AddCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 + m_Num2;<br>}<br>};</p>\n<p>//减法计算器<br>class SubCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 - m_Num2;<br>}<br>};</p>\n<p>//乘法计算器<br>class MulCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 * m_Num2;<br>}<br>};</p>\n<p>void test02()<br>{<br>//创建加法计算器<br>AbstractCalculator *abc = new AddCalculator;<br>abc-&gt;m_Num1 = 10;<br>abc-&gt;m_Num2 = 10;<br>cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; “ + “ &lt;&lt; abc-&gt;m_Num2 &lt;&lt; “ = “ &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;<br>delete abc; //用完了记得销毁</p>\n<pre><code>//创建减法计算器\nabc = new SubCalculator;\nabc-&gt;m_Num1 = 10;\nabc-&gt;m_Num2 = 10;\ncout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\ndelete abc;\n\n//创建乘法计算器\nabc = new MulCalculator;\nabc-&gt;m_Num1 = 10;\nabc-&gt;m_Num2 = 10;\ncout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\ndelete abc;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>\n<p>4.7.3 纯虚函数和抽象类<br>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>\n<p>因此可以将虚函数改为纯虚函数</p>\n<p>纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ;</p>\n<p>当类中有了纯虚函数，这个类也称为==抽象类==</p>\n<p>抽象类特点：</p>\n<p>无法实例化对象<br>子类必须重写抽象类中的纯虚函数，否则也属于抽象类<br>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>//纯虚函数<br>//类中只要有一个纯虚函数就称为抽象类<br>//抽象类无法实例化对象<br>//子类必须重写父类中的纯虚函数，否则也属于抽象类<br>virtual void func() = 0;<br>};</p>\n<p>class Son :public Base<br>{<br>public:<br>virtual void func()<br>{<br>cout &lt;&lt; “func 调用” &lt;&lt; endl;<br>};<br>};</p>\n<p>void test01()<br>{<br>Base * base = NULL;<br>//base = new Base; // 错误，抽象类无法实例化对象<br>base = new Son;<br>base-&gt;func();<br>delete base;//记得销毁<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.7.4 多态案例二-制作饮品<br>案例描述：</p>\n<p>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</p>\n<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>\n<p>1545985945198<br>1545985945198</p>\n<p>示例：</p>\n<p>C++<br>//抽象制作饮品<br>class AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() = 0;<br>//冲泡<br>virtual void Brew() = 0;<br>//倒入杯中<br>virtual void PourInCup() = 0;<br>//加入辅料<br>virtual void PutSomething() = 0;<br>//规定流程<br>void MakeDrink() {<br>Boil();<br>Brew();<br>PourInCup();<br>PutSomething();<br>}<br>};</p>\n<p>//制作咖啡<br>class Coffee : public AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() {<br>cout &lt;&lt; “煮农夫山泉!” &lt;&lt; endl;<br>}<br>//冲泡<br>virtual void Brew() {<br>cout &lt;&lt; “冲泡咖啡!” &lt;&lt; endl;<br>}<br>//倒入杯中<br>virtual void PourInCup() {<br>cout &lt;&lt; “将咖啡倒入杯中!” &lt;&lt; endl;<br>}<br>//加入辅料<br>virtual void PutSomething() {<br>cout &lt;&lt; “加入牛奶!” &lt;&lt; endl;<br>}<br>};</p>\n<p>//制作茶水<br>class Tea : public AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() {<br>cout &lt;&lt; “煮自来水!” &lt;&lt; endl;<br>}<br>//冲泡<br>virtual void Brew() {<br>cout &lt;&lt; “冲泡茶叶!” &lt;&lt; endl;<br>}<br>//倒入杯中<br>virtual void PourInCup() {<br>cout &lt;&lt; “将茶水倒入杯中!” &lt;&lt; endl;<br>}<br>//加入辅料<br>virtual void PutSomething() {<br>cout &lt;&lt; “加入枸杞!” &lt;&lt; endl;<br>}<br>};</p>\n<p>//业务函数<br>void DoWork(AbstractDrinking* drink) {<br>drink-&gt;MakeDrink();<br>delete drink;<br>}</p>\n<p>void test01() {<br>DoWork(new Coffee);<br>cout &lt;&lt; “————–” &lt;&lt; endl;<br>DoWork(new Tea);<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.7.5 虚析构和纯虚析构<br>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>\n<p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p>\n<p>虚析构和纯虚析构共性：</p>\n<p>可以解决父类指针释放子类对象<br>都需要有具体的函数实现<br>虚析构和纯虚析构区别：</p>\n<p>如果是纯虚析构，该类属于抽象类，无法实例化对象<br>虚析构语法：</p>\n<p>virtual ~类名(){}</p>\n<p>纯虚析构语法：</p>\n<p>virtual ~类名() = 0;</p>\n<p>类名::~类名(){}</p>\n<p>示例：</p>\n<p>C++<br>class Animal {<br>public:</p>\n<pre><code>Animal()\n{\n    cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;\n}\nvirtual void Speak() = 0;\n\n//析构函数加上virtual关键字，变成虚析构函数\n//virtual ~Animal()\n//{\n//    cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;\n//}\n\n\nvirtual ~Animal() = 0;</code></pre><p>};</p>\n<p>Animal::~Animal()<br>{<br>cout &lt;&lt; “Animal 纯虚析构函数调用！” &lt;&lt; endl;<br>}</p>\n<p>//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</p>\n<p>class Cat : public Animal {<br>public:<br>Cat(string name)<br>{<br>cout &lt;&lt; “Cat 构造函数调用！” &lt;&lt; endl;<br>m_Name = new string(name);<br>}<br>virtual void Speak()<br>{<br>cout &lt;&lt; *m_Name &lt;&lt; “小猫在说话!” &lt;&lt; endl;<br>}<br>~Cat()<br>{<br>cout &lt;&lt; “Cat 析构函数调用!” &lt;&lt; endl;<br>if (this-&gt;m_Name != NULL) {<br>delete m_Name;<br>m_Name = NULL;<br>}<br>}</p>\n<p>public:<br>string *m_Name;<br>};</p>\n<p>void test01()<br>{<br>Animal *animal = new Cat(“Tom”);<br>animal-&gt;Speak();</p>\n<pre><code>//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\n//怎么解决？给基类增加一个虚析构函数\n//虚析构函数就是用来解决通过父类指针释放子类对象\ndelete animal;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>\n<p>​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>\n<p>​ 3. 拥有纯虚析构函数的类也属于抽象类</p>\n<p>4.7.6 多态案例三-电脑组装<br>案例描述：</p>\n<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>\n<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如 Intel 厂商和 Lenovo 厂商</p>\n<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>\n<p>测试时组装三台不同的电脑进行工作</p>\n<p>示例：</p>\n<p>C++<br>#include<iostream><br>using namespace std;</p>\n<p>//抽象 CPU 类<br>class CPU<br>{<br>public:<br>//抽象的计算函数<br>virtual void calculate() = 0;<br>};</p>\n<p>//抽象显卡类<br>class VideoCard<br>{<br>public:<br>//抽象的显示函数<br>virtual void display() = 0;<br>};</p>\n<p>//抽象内存条类<br>class Memory<br>{<br>public:<br>//抽象的存储函数<br>virtual void storage() = 0;<br>};</p>\n<p>//电脑类<br>class Computer<br>{<br>public:<br>Computer(CPU _ cpu, VideoCard _ vc, Memory * mem)<br>{<br>m_cpu = cpu;<br>m_vc = vc;<br>m_mem = mem;<br>}</p>\n<pre><code>//提供工作的函数\nvoid work()\n{\n    //让零件工作起来，调用接口\n    m_cpu-&gt;calculate();\n\n    m_vc-&gt;display();\n\n    m_mem-&gt;storage();\n}\n\n//提供析构函数 释放3个电脑零件\n~Computer()\n{\n\n    //释放CPU零件\n    if (m_cpu != NULL)\n    {\n        delete m_cpu;\n        m_cpu = NULL;\n    }\n\n    //释放显卡零件\n    if (m_vc != NULL)\n    {\n        delete m_vc;\n        m_vc = NULL;\n    }\n\n    //释放内存条零件\n    if (m_mem != NULL)\n    {\n        delete m_mem;\n        m_mem = NULL;\n    }\n}</code></pre><p>private:</p>\n<pre><code>CPU * m_cpu; //CPU的零件指针\nVideoCard * m_vc; //显卡零件指针\nMemory * m_mem; //内存条零件指针</code></pre><p>};</p>\n<p>//具体厂商<br>//Intel 厂商<br>class IntelCPU :public CPU<br>{<br>public:<br>virtual void calculate()<br>{<br>cout &lt;&lt; “Intel 的 CPU 开始计算了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class IntelVideoCard :public VideoCard<br>{<br>public:<br>virtual void display()<br>{<br>cout &lt;&lt; “Intel 的显卡开始显示了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class IntelMemory :public Memory<br>{<br>public:<br>virtual void storage()<br>{<br>cout &lt;&lt; “Intel 的内存条开始存储了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>//Lenovo 厂商<br>class LenovoCPU :public CPU<br>{<br>public:<br>virtual void calculate()<br>{<br>cout &lt;&lt; “Lenovo 的 CPU 开始计算了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class LenovoVideoCard :public VideoCard<br>{<br>public:<br>virtual void display()<br>{<br>cout &lt;&lt; “Lenovo 的显卡开始显示了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class LenovoMemory :public Memory<br>{<br>public:<br>virtual void storage()<br>{<br>cout &lt;&lt; “Lenovo 的内存条开始存储了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//第一台电脑零件<br>CPU _ intelCpu = new IntelCPU;<br>VideoCard _ intelCard = new IntelVideoCard;<br>Memory * intelMem = new IntelMemory;</p>\n<pre><code>cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;\n//创建第一台电脑\nComputer * computer1 = new Computer(intelCpu, intelCard, intelMem);\ncomputer1-&gt;work();\ndelete computer1;\n\ncout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;\n//第二台电脑组装\nComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\ncomputer2-&gt;work();\ndelete computer2;\n\ncout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;\n//第三台电脑组装\nComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\ncomputer3-&gt;work();\ndelete computer3;</code></pre><p>}<br>5 文件操作<br>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>\n<p>通过文件可以将数据持久化</p>\n<p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p>\n<p>文件类型分为两种：</p>\n<p>文本文件 - 文件以文本的 ASCII 码形式存储在计算机中<br>二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们<br>操作文件的三大类:</p>\n<p>ofstream：写操作<br>ifstream： 读操作<br>fstream ： 读写操作<br>5.1 文本文件<br>5.1.1 写文件<br>写文件步骤如下：</p>\n<p>包含头文件</p>\n<p>#include <fstream></p>\n<p>创建流对象</p>\n<p>ofstream ofs;</p>\n<p>打开文件</p>\n<p>ofs.open(“文件路径”,打开方式);</p>\n<p>写数据</p>\n<p>ofs &lt;&lt; “写入的数据”;</p>\n<p>关闭文件</p>\n<p>ofs.close();</p>\n<p>文件打开方式：</p>\n<p>打开方式 解释<br>ios::in 为读文件而打开文件<br>ios::out 为写文件而打开文件<br>ios::ate 初始位置：文件尾<br>ios::app 追加方式写文件<br>ios::trunc 如果文件存在先删除，再创建<br>ios::binary 二进制方式<br>注意： 文件打开方式可以配合使用，利用|操作符</p>\n<p>例如：用二进制方式写文件 ios::binary | ios:: out</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream></p>\n<p>void test01()<br>{<br>ofstream ofs;<br>ofs.open(“test.txt”, ios::out);</p>\n<pre><code>ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;\nofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;\nofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;\n\nofs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>文件操作必须包含头文件 fstream<br>读文件可以利用 ofstream ，或者 fstream 类<br>打开文件时候需要指定操作文件的路径，以及打开方式<br>利用&lt;&lt;可以向文件中写数据<br>操作完毕，要关闭文件<br>5.1.2 读文件<br>读文件与写文件步骤相似，但是读取方式相对于比较多</p>\n<p>读文件步骤如下：</p>\n<p>包含头文件</p>\n<p>#include <fstream></p>\n<p>创建流对象</p>\n<p>ifstream ifs;</p>\n<p>打开文件并判断文件是否打开成功</p>\n<p>ifs.open(“文件路径”,打开方式);</p>\n<p>读数据</p>\n<p>四种方式读取</p>\n<p>关闭文件</p>\n<p>ifs.close();</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string><br>void test01()<br>{<br>ifstream ifs;<br>ifs.open(“test.txt”, ios::in);</p>\n<pre><code>if (!ifs.is_open())\n{\n    cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;\n    return;\n}\n\n//第一种方式\n//char buf[1024] = { 0 };\n//while (ifs &gt;&gt; buf)\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\n//第二种\n//char buf[1024] = { 0 };\n//while (ifs.getline(buf,sizeof(buf)))\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\n//第三种\n//string buf;\n//while (getline(ifs, buf))\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\nchar c;\nwhile ((c = ifs.get()) != EOF)\n{\n    cout &lt;&lt; c;\n}\n\nifs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>读文件可以利用 ifstream ，或者 fstream 类<br>利用 is_open 函数可以判断文件是否打开成功<br>close 关闭文件<br>5.2 二进制文件<br>以二进制的方式对文件进行读写操作</p>\n<p>打开方式要指定为 ==ios::binary==</p>\n<p>5.2.1 写文件<br>二进制方式写文件主要利用流对象调用成员函数 write</p>\n<p>函数原型 ：ostream&amp; write(const char * buffer,int len);</p>\n<p>参数解释：字符指针 buffer 指向内存中一段存储空间。len 是读写的字节数</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string></p>\n<p>class Person<br>{<br>public:<br>char m_Name[64];<br>int m_Age;<br>};</p>\n<p>//二进制文件 写文件<br>void test01()<br>{<br>//1、包含头文件</p>\n<pre><code>//2、创建输出流对象\nofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary);\n\n//3、打开文件\n//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);\n\nPerson p = {&quot;张三&quot;  , 18};\n\n//4、写文件\nofs.write((const char *)&amp;p, sizeof(p));\n\n//5、关闭文件\nofs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>文件输出流对象 可以通过 write 函数，以二进制方式写数据<br>5.2.2 读文件<br>二进制方式读文件主要利用流对象调用成员函数 read</p>\n<p>函数原型：istream&amp; read(char *buffer,int len);</p>\n<p>参数解释：字符指针 buffer 指向内存中一段存储空间。len 是读写的字节数</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string></p>\n<p>class Person<br>{<br>public:<br>char m_Name[64];<br>int m_Age;<br>};</p>\n<p>void test01()<br>{<br>ifstream ifs(“person.txt”, ios::in | ios::binary);<br>if (!ifs.is_open())<br>{<br>cout &lt;&lt; “文件打开失败” &lt;&lt; endl;<br>}</p>\n<pre><code>Person p;\nifs.read((char *)&amp;p, sizeof(p));\n\ncout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>文件输入流对象 可以通过 read 函数，以二进制方式读数据</p>\n"},{"title":"A first look at C++ (8)","url":"/2023/01/18/A%20first%20look%20at%20C++%20(8)/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"c-first-look\"><a href=\"#c-first-look\" class=\"headerlink\" title=\"c++ first look\"></a>c++ first look</h1><h1 id=\"C-operator-overloading-easy-to-understand\"><a href=\"#C-operator-overloading-easy-to-understand\" class=\"headerlink\" title=\"C++ operator overloading (easy to understand)\"></a>C++ operator overloading (easy to understand)</h1><p>Operator overloading is the process of redefining existing operators and giving them another function to suit different data types.</p>\n<p>You can redefine or overload most of C++’s built-in operators. For example, +, -, *, /, and</p>\n<p>++, -, &gt;&gt;, &lt;&lt;, and so on, so that you can use custom types of operators.</p>\n<p>Basic format of operator overloading<br>An overloaded operator is a function with a special name, and the function name is defined by the keyword operator and</p>\n<p>followed by the operator symbol to be overloaded. Like other functions, overloaded operators have a</p>\n<p>return type and a list of arguments.</p>\n<p>Point operator+(const Point &amp;);</p>\n<p>There are two types of operator overloading: in-class overloading (operator overloaded functions as members of the class) and out-of-class overloading (operator overloaded functions as friend functions of the class)</p>\n<p>In-class overloading</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Point()&#123;&#125;;</span><br><span class=\"line\">    Point (<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class=\"line\">    Point <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point &amp;a)&#123; <span class=\"comment\">//in-class overloading, operator overloading function as a member of the class</span></span><br><span class=\"line\">        Point ret;</span><br><span class=\"line\">        ret.x = <span class=\"keyword\">this</span>-&gt;x + a.x;</span><br><span class=\"line\">        ret.y = <span class=\"keyword\">this</span>-&gt;y + a.y;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Point a(2,4),b(5,3);</span><br><span class=\"line\">    Point c = a + b;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt; <span class=\"string\">\"x :\"</span> &lt;&lt; c.x &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt; <span class=\"string\">\"y :\"</span> &lt;&lt; c.y &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>When the above code is compiled and executed, it produces the following results.</p>\n<p>x : 7</p>\n<p>y: 7</p>\n<p>When operator overloading is intra-class overloading, the operator overloaded function is used as a member function of the class, in the case of the above code a + b is equivalent to a object calling the + method and passing in the arguments when b object</p>\n<p>Out-of-class overloading</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Point()&#123;&#125;;</span><br><span class=\"line\">    Point (<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> Point <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point &amp;, <span class=\"keyword\">const</span> Point &amp;);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Point <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point &amp;a,<span class=\"keyword\">const</span> Point &amp;b)&#123;<span class=\"comment\">//extra class overload, operator overload function as friend function of class</span></span><br><span class=\"line\">    Point ret;</span><br><span class=\"line\">    ret.x = a.x + b.x;</span><br><span class=\"line\">    ret.y = a.y + b.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     Point a(2,4),b(5,3);</span><br><span class=\"line\">    Point c = a + b;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt; <span class=\"string\">\"x :\"</span> &lt;&lt; c.x &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt; <span class=\"string\">\"y :\"</span> &lt;&lt; c.y &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>When the above code is compiled and executed, it produces the same result as above</p>\n<p>Examples of various operator overloads<br>The following code demonstration of various operator overloading examples will demonstrate several basic operator overloading.</p>\n<p>Insertion operator overloading &gt;&gt; and Extraction operator overloading &lt;&lt;<br>Take the example of the extract operator overload &lt;&lt;. cout is an object of the ostream class. ostream class and cout are both declared in the header file <iostream>. ostream class overloads &lt;&lt; as a member function.</p>\n<p>Here we overload &lt;&lt; to output a object using cout</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Point()&#123;&#125;;</span><br><span class=\"line\">    Point (<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> Point <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point &amp;, <span class=\"keyword\">const</span> Point &amp;);</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;out , <span class=\"keyword\">const</span> Point &amp;a);</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Point <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point &amp;a,<span class=\"keyword\">const</span> Point &amp;b)&#123;</span><br><span class=\"line\">    Point ret;</span><br><span class=\"line\">    ret.x = a.x + b.x;</span><br><span class=\"line\">    ret.y = a.y + b.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;out , <span class=\"keyword\">const</span> Point &amp;a)&#123;</span><br><span class=\"line\">    out &lt;&lt; &lt; <span class=\"string\">\"&lt;Point&gt;( \"</span> &lt;&lt; a.x &lt;&lt; <span class=\"string\">\", \"</span> &lt;&lt; a.y &lt;&lt; <span class=\"string\">\")\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Point a(2,4),b(5,3);</span><br><span class=\"line\">    Point c = a + b;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; c&lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>When the above code is compiled and executed, it produces the following results.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt; Point&gt;( <span class=\"number\">7</span>, <span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n\n<p>Note: When overloading <code>&lt;&lt;</code>, it is an out-of-class overload, and it is customary to use <code>cin&gt;&gt;</code> and <code>cout&lt;&lt;</code>. You have to use a friend function to overload the operator, and if you use a member function to overload it, you will get <code>c&lt;&lt;cout;</code> which is unnatural code.</p>\n<p>Also there should be some confusion about the <code>ostream &amp;operator&lt;&lt;(ostream &amp;out , const Point &amp;a)</code> function, first of all when overloading &lt;&lt;, the return value type is <code>ostream&amp;</code> and the first argument is also <code>ostream&amp;</code>. That is, the return value of the expression <code>cout&lt;&lt;c</code> is still <code>cout</code>, so <code>cout&lt;&lt;c&lt;&lt;endl;</code> can hold</p>\n<p>Pre-operator overload ++ and post-operator overload ++</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Point()&#123;&#125;;</span><br><span class=\"line\">    Point (<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> Point <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point &amp;, <span class=\"keyword\">const</span> Point &amp;);</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;out , <span class=\"keyword\">const</span> Point &amp;a);</span><br><span class=\"line\">    Point&amp; <span class=\"keyword\">operator</span>++()&#123; <span class=\"comment\">// Preceding operator, requires reference return, no arguments. Returns the value after self-incrementing, and returns a left value</span></span><br><span class=\"line\">        x++;</span><br><span class=\"line\">        y++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> Point <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>)&#123;<span class=\"comment\">//Post++, no reference return, parameter differentiation required. Returns the value before the self-increment and returns a right value</span></span><br><span class=\"line\">        <span class=\"function\">Point <span class=\"title\">temp</span><span class=\"params\">(x,y)</span></span>;</span><br><span class=\"line\">        x++;</span><br><span class=\"line\">        y++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Point <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point &amp;a,<span class=\"keyword\">const</span> Point &amp;b)&#123;</span><br><span class=\"line\">    Point ret;</span><br><span class=\"line\">    ret.x = a.x + b.x;</span><br><span class=\"line\">    ret.y = a.y + b.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;out , <span class=\"keyword\">const</span> Point &amp;a)&#123;</span><br><span class=\"line\">    out &lt;&lt; &lt; <span class=\"string\">\"&lt;Point&gt;(\"</span> &lt;&lt; a.x &lt;&lt; <span class=\"string\">\" , \"</span> &lt;&lt; a.y &lt;&lt; <span class=\"string\">\")\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Point a(2,4),b(5,3);</span><br><span class=\"line\">    Point c = a + b;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    c++;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    ++c;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>When the above code is compiled and executed, it produces the following results.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(7 , 7)</span><br><span class=\"line\">&lt; Point&gt;(8 , 8)</span><br><span class=\"line\">&lt; Point&gt;(9 , 9)</span><br></pre></td></tr></table></figure>\n\n<p>1&gt; In order to distinguish between the preceding and the following operators, it is necessary to add the parameter “int” to the latter operator overload function, although this type does not represent any real meaning here except to show the difference.</p>\n<p>2&gt; The predecessor returns a reference to a variable, the posterior returns a constant. So ++++c is legal, but c++++ is not;</p>\n<p>3&gt;Why not let c++++ be legal too? If you want to make c++++ legal, you must make the posterior return a variable or a reference to a variable. c++ returns the value of c before +1, so it is impossible to return c. Then you can only create a local variable to save the initial value of c, and then return the local variable (local variables are not allowed to return references), but after returning the local variable, if you do the next ++ operation in a row, the one that participates in the operation is the value of this So at this point, c++++ is actually equivalent to c++, and there is no point of existence.</p>\n<h1 id=\"The-difference-between-new-delete-and-malloc-free-in-C\"><a href=\"#The-difference-between-new-delete-and-malloc-free-in-C\" class=\"headerlink\" title=\"The difference between new/delete and malloc/free in C++\"></a>The difference between new/delete and malloc/free in C++</h1><p>1、new and delete are operators in C++, while malloc and free are standard library functions.</p>\n<p>2, for non-internal data objects, only use malloc is unable to complete the dynamic object requirements, generally in the creation of objects need to call the constructor, object extinction, the automatic call destructor. The malloc free is a library function instead of an operator, which is not under the compiler’s control and cannot automatically call the constructor and destructor. NEW, on the other hand, can automatically call the constructor when requesting memory space for an object, and can also complete the initialization of the object. Similarly, delete can also automatically call destructors. And mallloc just does one thing, it just allocates memory for the variable, and by the same token, free just releases the memory of the variable.</p>\n<ol start=\"3\">\n<li>new returns a pointer of the specified type and can automatically calculate the size of the requested memory. malloc, on the other hand, requires us to calculate the size of the requested memory and forcibly convert it to a pointer of the actual type upon return.</li>\n</ol>\n<p>What exactly are new and delete?<br>If you are looking for a job and read some interview books, I believe you will encounter the question: sizeof is not a function, and then you will give a bunch of reasons to prove that sizeof is not a function. Here, similar to sizeof, new and delete are also not functions, they are keywords defined by C++ and can be composed into expressions by a specific syntax. Unlike sizeof, which determines its return value at compile time, the mechanism behind new and delete is more complex.<br>Before you go any further, think about what you think new should do. Perhaps your first response is that new is not the same as the malloc function in C, which is used to dynamically request space. You’re half right. Look at the following statement.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> *ps = <span class=\"keyword\">new</span> <span class=\"built_in\">string</span>(<span class=\"string\">\"hello world\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>You can see that new and malloc are still a bit different. malloc doesn’t do the necessary initialization of memory after requesting space, while new does. So what goes on behind the scenes of the new expression is not as simple as you might think. Before I explain the mechanism behind new with an example, you need to know what operator new and operator delete are.</p>\n<p>operator new and operator delete<br>are actually library functions of the C++ language standard library, with the following prototypes.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"keyword\">operator</span> <span class=\"title\">new</span><span class=\"params\">(<span class=\"keyword\">size_t</span>)</span></span>; <span class=\"comment\">//allocate an object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"keyword\">operator</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"keyword\">void</span> *)</span></span>; <span class=\"comment\">//free an object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> *<span class=\"keyword\">operator</span> <span class=\"keyword\">new</span>[](<span class=\"keyword\">size_t</span>); <span class=\"comment\">//allocate an array</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> *<span class=\"keyword\">operator</span> <span class=\"keyword\">delete</span>[](<span class=\"keyword\">void</span> *); <span class=\"comment\">//free an array</span></span><br></pre></td></tr></table></figure>\n\n<p>You can leave the last two alone for now, they will be described later. The first two are C++ standard library functions, you may think this is a function? The C++ Primer book says that this is not an overloading of the new and delete expressions (as operator= is an overloading of the = operator), because new and delete are not allowed to be overloaded. But I haven’t figured out why operator new and operator delete are named, which is rather confusing. We just need to know what they mean. These two functions are a bit like the malloc and free functions in C. They are both used to request and release memory, and operator new does not initialize the memory after requesting it, but directly returns a pointer to the requested memory.</p>\n<p>We can use these functions directly in our programs.</p>\n<p>The mechanism behind new and delete<br>Once we know the above two functions, let’s explain the mechanism behind new and delete with an example.</p>\n<p>Instead of using a simple C++ built-in type as an example, let’s use a more complex class type and define a class A.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    A(<span class=\"keyword\">int</span> v) : var(v)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fopen_s(&amp;file, <span class=\"string\">\"test\"</span>, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~A()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fclose(file);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> var;</span><br><span class=\"line\">    FILE *file;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>The constructor initializes the private variable var and opens a file, and the destructor closes the open file.</p>\n<p>We use</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> *<span class=\"title\">pA</span> = <span class=\"title\">new</span> <span class=\"title\">A</span>(10);</span></span><br></pre></td></tr></table></figure>\n\n<p>The following diagram shows the work done behind new.</p>\n<p>To summarize briefly.</p>\n<p>First, you need to call the operator new standard library function mentioned above, and pass in the parameter for the size of class A. Here it is 8 bytes, as to why it is 8 bytes, you can take a look at the book “Deeper into C++ Object Model”, not much explanation here. This function returns the starting address of the allocated memory, which is assumed to be 0x007da290.<br>The memory allocated above is uninitialized and untyped. The second step is to initialize the class object on this piece of raw memory, calling the corresponding constructor, here is a call to A:A(10); This function, as you can see from the diagram, also initializes this piece of applied memory, var=10, file points to the open file.<br>The last step is to return a pointer to the newly allocated and constructed object, here pA points to the 0x007da290 block of memory, and pA is of type pointer to the class A object.<br>You can find the assembly code for all three of these steps by disassembling, so I won’t list them here.</p>\n<p>Okay, so what does delete do? To continue with the above example, what if we want to release the object of the requested class at this point? Of course we can use the following statement to do that.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> pA;</span><br></pre></td></tr></table></figure>\n\n<p>What delete does is shown in the following figure.</p>\n<p>img<br>img</p>\n<p>delete then does two things.</p>\n<p>Call the destructor function of the object pointed to by pA to close the open file.<br>The object’s memory is freed by the standard library function operator delete mentioned above, and the argument passed to the function is the value of pA, which is 0x007d290.<br>Well, after explaining what is done behind new and delete, don’t you think it is very simple? It’s just one more call to the constructor and destructor.</p>\n<p>How to request and release an array?<br>We often need to dynamically allocate an array, perhaps like this.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> *psa = <span class=\"keyword\">new</span> <span class=\"built_in\">string</span>[<span class=\"number\">10</span>]; <span class=\"comment\">//array of 10 empty strings</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *pia = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>]; <span class=\"comment\">//array of 10 uninitialized ints</span></span><br></pre></td></tr></table></figure>\n\n<p>The above is done by using the new [] expression when requesting an array. According to our knowledge of new and delete mentioned above, the first array is of type string, and after allocating the memory space to store the objects, the default constructor of type string will be called to initialize each element of the array in turn; the second is to request an array with built-in types, and allocate the memory space to store 10 int objects. The second is an application for an array with built-in types, which allocates memory space to store 10 int objects, but does not initialize them.</p>\n<p>If we want to free up the space, we can use the following two statements.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> [] psa;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> [] pia;</span><br></pre></td></tr></table></figure>\n\n<p>Both use the delete [] expression, and note that the [] in this place cannot be left out in general! We can also imagine what these two statements do: the first one calls the destructor on each of the 10 string objects, and then frees all the memory space allocated for the object; the second one frees all the memory space allocated for the 10 int types directly because there is no destructor for the built-in types.</p>\n<p>Here is a question for the first case: how do we know the size of the array that psa refers to? How do we know how many times to call the destructor?</p>\n<p>This problem directly leads to the need to save the dimension of the array when we new [] an array of objects. The C++ approach is to allocate an extra 4 bytes of array space, specifically to save the size of the array.</p>\n<p>We define a class A, but do not describe the contents of the class specifically, this class has a display of the constructor, destructor and so on. So when we call</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> \\*<span class=\"title\">pAa</span> = <span class=\"title\">new</span> <span class=\"title\">A</span>[3];</span></span><br></pre></td></tr></table></figure>\n\n<p>what needs to be done when we call class A is as follows.</p>\n<p>img<br>img</p>\n<p>From this diagram we can see that the application allocates an additional 4 bytes on top of the array object to preserve the size of the array, but the final return is a pointer to the object array, not the starting address of all the allocated space.</p>\n<p>In this case, the release is simple.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> [] pAa;</span><br></pre></td></tr></table></figure>\n\n<p>img<br>img</p>\n<p>The two points to note here are.</p>\n<p>the number of calls to the destructor function is taken from the 4 bytes preceding the pointer to the array object.<br>The argument passed to the operator delete[] function is not the pointer to the array object, pAa, but the value of pAa minus 4.<br>Why do new/delete and new []/delete[] need to be used in pairs?<br>Actually, after all this, I haven’t gotten to the original intention of writing this article. From the above explanation, you should understand how new/delete and new[]/delete[] work, because there are differences between them, so they need to be used in pairs. But the problem is not that simple, and that is the problem I encountered with the following code.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> \\*pia = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">delete</span> []pia;</span><br></pre></td></tr></table></figure>\n\n<p>This is certainly fine, but if we replace delete []pia; with delete pia;, will something go wrong?</p>\n<p>This brings us to the question that was not mentioned in the section above. I mentioned above the reason for allocating 4 extra bytes in new [], because we need to know the size of the array when destructing it, but what if we don’t call the destructor (as in the case of built-in types, in this case int arrays)? We don’t need to allocate those 4 extra bytes in new [], and when we delete [] we go directly to the second step to free the space allocated for the int array. If we use delete pia here; then the operator delete function will be called, and the argument passed in is the starting address of the allocated array, and all it does is free up that memory space. There is no problem.</p>\n<p>The requirement for using new [] to free an object with delete is that the object is of a built-in type or a class type without a custom destructor!</p>\n<p>Let’s see what happens if we use new [] to create an array of class objects and delete to free them for a class type with a custom destructor. To illustrate with the above example.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> \\*<span class=\"title\">pAa</span> = <span class=\"title\">new</span> <span class=\"title\">class</span> <span class=\"title\">A</span>[3];</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pAa;</span><br></pre></td></tr></table></figure>\n\n<p>Then delete pAa; does two things.</p>\n<p>calls once the destructor of the object pointed to by pAa.<br>Call operator delete(pAa); to free memory.<br>Obviously, the destructor is called only for the first class object of the array, and not for the next two objects. If a large amount of memory is requested in the class object and needs to be freed in the destructor, and you undercall the destructor when destroying the array object, this will cause a memory leak.</p>\n<p>If you say it’s okay for the above problem, then the second point is fatal! Freeing the memory space pointed to by pAa directly will always cause a serious segment error and the program will surely crash! Because the starting address of the allocated space is the place where pAa points minus 4 bytes. You should pass in the parameter set to that address!</p>\n<p>Similarly, you can analyze what will happen if you use new to allocate and delete [] to free? Does it always lead to program errors?</p>\n<p>In general, just remember one thing: new/delete, new[]/delete[] should always be used together!</p>\n<h1 id=\"Explanation-of-iostream-and-using-namespace-std\"><a href=\"#Explanation-of-iostream-and-using-namespace-std\" class=\"headerlink\" title=\"Explanation of iostream and using namespace std\"></a>Explanation of iostream and using namespace std</h1><p>When we practice programming with C++ syntax, we often write the first two lines of the code like this</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">include&lt;iostream&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Do you have any doubts when you are learning C++?</p>\n<p>When you practice C programming, you only need to declare one header file: #include&lt;stdio.h&gt;. But in C++, why do we need to write two lines of code, include and using namespace std;?</p>\n<p>The first line, include, is barely understandable, as it is similar to #include&lt;stdio.h&gt; in C, i.e., declaring the standard input and output header files. But what exactly does using namespace std do?</p>\n<p>There are a lot of professional arguments on the web for this question, but the long and complicated content is too much of a headache for beginners to read, so I hope to explain clearly the role of using namespace std in concise language. I think the correct order of study is</p>\n<p>I think the correct order of learning is: we must first learn to define, use and understand namespace (namespace), and then go back to study the role of using namespace std; this can play a half-hearted effect, then the next focus will come.</p>\n<p>Defining namespaces<br>(1) Simple namespace</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. Define namespace A</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">0</span>;<span class=\"comment\">//define variable a in namespace A</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Defining a namespace is as simple as this: in this namespace A, there is an int-type variable with the name “a”. So let’s go straight to the hard part! Define a complex namespace.</p>\n<p>(2) Complex namespaces</p>\n<p>Requirement: Define namespace B, and define namespace C in namespace B, and define the structure Teacher in namespace C</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//2. Complex namespaces</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> B <span class=\"comment\">//define namespace B</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;<span class=\"comment\">//you can also define the variable a in namespace B, because they are not in the same namespace</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> C <span class=\"comment\">//You can also define another namespace C in namespace B</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span>//<span class=\"title\">define</span> <span class=\"title\">the</span> <span class=\"title\">structure</span> <span class=\"title\">Teacher</span> <span class=\"title\">in</span> <span class=\"title\">namespace</span> <span class=\"title\">C</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> a[<span class=\"number\">32</span>];<span class=\"comment\">//The variable a can also be defined in the structure, because the three \"a \"s are not in the same namespace</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Using namespaces<br>(1) The basic method of using namespaces</p>\n<p>We have defined namespaces A, B and C, and the same variable “a” is defined in all three namespaces, so let’s use them.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//The basic way to use namespaces 1</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> A;<span class=\"comment\">//Tell the compiler that I want to use the functions in namespace A</span></span><br><span class=\"line\">a=<span class=\"number\">10</span>; <span class=\"comment\">//Change variable \"a\" in namespace A from 0 to 10</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>; <span class=\"comment\">//check if the change is done, the screen should output \"10</span></span><br></pre></td></tr></table></figure>\n\n<p>Note: At this time, only namespace A is used, so only the variable a in namespace A will be accessed, but not the variables a in namespace B and C.</p>\n<p>In fact, for the above three lines of code, as long as the variable “a” is clearly pointed out in the third line of code, the first line “using namespace A” can be omitted, as follows.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//The basic method of using namespaces 2</span></span><br><span class=\"line\"><span class=\"comment\">// Since it is sufficient to use one of these two methods in the code, I added the \"//\" comment notation here for the second method, as follows two lines of code.</span></span><br><span class=\"line\"><span class=\"comment\">// a=10;</span></span><br><span class=\"line\"><span class=\"comment\">// cout&lt;&lt;A::a&lt;endl; // \"A::a\" explicitly points to variable a in namespace A (with a double colon::)</span></span><br></pre></td></tr></table></figure>\n\n<p>The above two ways of using namespaces are for you to pick and choose ^_^</p>\n<p>(2) Using complex namespaces</p>\n<p>The use of namespace A is relatively simple, but there is a namespace C nested in namespace B, and there is a structure Teacher nested in namespace C. So how do we use namespace B and namespace C?</p>\n<p>Next, if we use namespace B in addition to namespace A, the statement “a=10;” is not clear: there is a variable a in namespace B, so there are now two “a “s that can be accessed so there are now two “a “s that can be accessed. So: if you want to access a specific variable a, you need to point explicitly!</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> B;</span><br><span class=\"line\"><span class=\"comment\">// If you want to access a specific variable a, you need to point to it explicitly! as follows.</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;A::a&lt;&lt;<span class=\"built_in\">endl</span>; <span class=\"comment\">//explicitly points to the \"namespace A\"</span></span><br><span class=\"line\"><span class=\"comment\">//Although there are two namespaces, A and B, and the variable \"a\" is in both namespaces, by pointing explicitly, we can specify whether the variable we are accessing is \"a\" in namespace A or \"a\" in namespace B \"a\" in namespace B</span></span><br></pre></td></tr></table></figure>\n\n<p>(3) Using the variables in the structure Teacher</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//How to use Teacher</span></span><br><span class=\"line\"><span class=\"comment\">//Method 1: This method requires for each structure defined: \"B::C::Teacher structure name\"</span></span><br><span class=\"line\"><span class=\"comment\">//B::C::Teacher t1;// Define the structure t1 using the structure template (Teacher) from namespace C in namespace B</span></span><br><span class=\"line\"><span class=\"comment\">//t1.b=33;//Note: t1.a is syntactically incorrect! It is because a is a pointer (address), which cannot be modified, otherwise the memory cannot be freed later</span></span><br><span class=\"line\"> <span class=\"comment\">//Method 2: Define the \"structure type\" data type directly in one breath, and then use the structure in the same way as you define variables by data type</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> B::C::Teacher;</span><br><span class=\"line\">Teacher t2;</span><br><span class=\"line\">t2.b=<span class=\"number\">22</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ðŸ™' ðŸ™'</span><br><span class=\"line\"></span><br><span class=\"line\">The analysis of iostream <span class=\"keyword\">and</span> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span> \\*\\*\\\\*\\*\\*</span><br><span class=\"line\">(1) Through the above introduction on the definition and use of namespaces, we can easily find that different namespaces are independent of each other, although the variable names attached to them may be the same (for example, the namespaces A, B and C mentioned above all contain the variable a), but it doesn't matter: the \"namespace\" This \"barrier\" separates these identical variable names, so that they have the same name, but do not affect each other.</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">2</span>) It seems that the introduction of namespaces is very convenient, so we don<span class=\"number\">'</span>t have to worry about renaming variables. However, in the old days, there was no <span class=\"keyword\">concept</span> of namespaces, but the standard library functions were defined in the global space <span class=\"keyword\">and</span> declared in &lt;iostream.h&gt; (an early C++ header file). But since the standard library is very large, then there is a high chance that the programmer will choose a <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">name</span> <span class=\"title\">or</span> <span class=\"title\">function</span> <span class=\"title\">name</span> <span class=\"title\">that</span> <span class=\"title\">is</span> <span class=\"title\">the</span> <span class=\"title\">same</span> <span class=\"title\">as</span> <span class=\"title\">one</span> <span class=\"title\">of</span> <span class=\"title\">the</span> <span class=\"title\">names</span> <span class=\"title\">in</span> <span class=\"title\">the</span> <span class=\"title\">standard</span> <span class=\"title\">library</span>. <span class=\"title\">So</span> <span class=\"title\">to</span> <span class=\"title\">avoid</span> <span class=\"title\">name</span> <span class=\"title\">conflicts</span> <span class=\"title\">caused</span> <span class=\"title\">by</span> <span class=\"title\">this</span> <span class=\"title\">situation</span>, <span class=\"title\">everything</span> <span class=\"title\">in</span> <span class=\"title\">the</span> <span class=\"title\">standard</span> <span class=\"title\">library</span> <span class=\"title\">was</span> <span class=\"title\">put</span> <span class=\"title\">in</span> <span class=\"title\">a</span> <span class=\"title\">namespace</span> <span class=\"title\">called</span> <span class=\"title\">std</span>. <span class=\"title\">Later</span> <span class=\"title\">the</span> <span class=\"title\">C</span>++ <span class=\"title\">standard</span>, <span class=\"title\">in</span> <span class=\"title\">order</span> <span class=\"title\">to</span> <span class=\"title\">distinguish</span> <span class=\"title\">it</span> <span class=\"title\">from</span> <span class=\"title\">C</span> <span class=\"title\">and</span> <span class=\"title\">to</span> <span class=\"title\">use</span> <span class=\"title\">the</span> <span class=\"title\">namespace</span> <span class=\"title\">correctly</span>, <span class=\"title\">specified</span> <span class=\"title\">that</span> <span class=\"title\">the</span> <span class=\"title\">header</span> <span class=\"title\">files</span> <span class=\"title\">do</span> <span class=\"title\">not</span> <span class=\"title\">use</span> <span class=\"title\">the</span> <span class=\"title\">suffix</span> .<span class=\"title\">h</span>, <span class=\"title\">i</span>.<span class=\"title\">e</span>., <span class=\"title\">the</span> <span class=\"title\">current</span> <span class=\"title\">header</span> <span class=\"title\">files</span> <span class=\"title\">appeared</span>.</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">(3) <span class=\"title\">When</span> <span class=\"title\">used</span>, <span class=\"title\">the</span> <span class=\"title\">header</span> <span class=\"title\">file</span> <span class=\"title\">does</span> <span class=\"title\">not</span> <span class=\"title\">define</span> <span class=\"title\">the</span> <span class=\"title\">global</span> <span class=\"title\">namespace</span>, <span class=\"title\">and</span> <span class=\"title\">must</span> <span class=\"title\">use</span> <span class=\"title\">the</span> <span class=\"title\">standard</span> <span class=\"title\">namespace</span> <span class=\"title\">specified</span> <span class=\"title\">by</span> <span class=\"title\">C</span>++ (<span class=\"title\">i</span>.<span class=\"title\">e</span>.:</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>), so that it can correctly use <span class=\"built_in\">cout</span>, <span class=\"built_in\">endl</span>, <span class=\"keyword\">and</span> other functions.</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">4</span>) Finally: If you want to know more about <span class=\"keyword\">this</span>, please refer to: Click to open the link Thanks.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># c++ Defining Structs</span></span><br><span class=\"line\"></span><br><span class=\"line\">Define the structure type first <span class=\"keyword\">and</span> then define the variables separately</span><br><span class=\"line\"></span><br><span class=\"line\">````Cpp</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ```cpp;</span><br><span class=\"line\"><span class=\"keyword\">char</span> Name[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"keyword\">char</span> Sex;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">Stu</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">Stu</span>[10];</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> \\*<span class=\"title\">pStru</span>;</span></span><br></pre></td></tr></table></figure>\n\n<p>The structure type is struct Student, so neither struct nor Student can be omitted. But actually, when I run with ``cppblocks, the following variables are defined without the struct.</p>\n<p>The definition follows immediately after the struct type description</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ```cpp;</span><br><span class=\"line\"><span class=\"keyword\">char</span> Name[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"keyword\">char</span> Sex;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Age;</span><br><span class=\"line\">&#125;Stu,Stu[<span class=\"number\">10</span>],\\*pStu;</span><br></pre></td></tr></table></figure>\n\n<p>In this case, the structure variable can be defined again later.</p>\n<p>The definition is done directly while stating an unnamed structure variable</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ```cpp;</span><br><span class=\"line\"><span class=\"keyword\">char</span> Name[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"keyword\">char</span> Sex;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Age;</span><br><span class=\"line\">&#125;Stu,Stu[<span class=\"number\">10</span>],\\*pStu;</span><br></pre></td></tr></table></figure>\n\n<p>In this case, no other variables can be defined afterwards.</p>\n<p>Use typedef to describe a structure variable and then define the variable with the new class name</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ```cpp;</span><br><span class=\"line\"><span class=\"keyword\">char</span> Name[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"keyword\">char</span> Sex;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Age;</span><br><span class=\"line\">&#125;student;</span><br></pre></td></tr></table></figure>\n\n<p>Student Stu,Stu[10],*pStu;<br>Student is a concrete structure type, uniquely identified. There is no need to add struct</p>\n<h1 id=\"Synchronous-and-Asynchronous\"><a href=\"#Synchronous-and-Asynchronous\" class=\"headerlink\" title=\"Synchronous and Asynchronous\"></a>Synchronous and Asynchronous</h1><p>What is synchronous and asynchronous?<br>Definition: Synchronous and asynchronous are concerned with <em>message communication mechanisms</em> (synchronous communication/ asynchronous communication). Synchronous means that when something is called, the caller has to wait for the result of the call to be returned before proceeding further. Asynchronous, in contrast to synchronous, the caller does not understand the result, but after the call is made the caller can continue to perform subsequent operations, and the called party notifies the caller through the form, or by dropping back the function to handle the call <em>\\</em></p>\n<p>Let’s say: you go to the mall to buy something, you look at a cell phone, can and the shopkeeper said you a this phone, he went to the warehouse to get the goods, you have to wait in the store, can not leave, this is called synchronization. Now you buy a cell phone to catch up with the fashion directly to Jingdong order, after the completion of the order you can do other time (catching up on drama, playing king, lol) and so the goods arrived to sign for it ok. This is called asynchronous.</p>\n<p>Take a method call as an example<br>Once a synchronous method call starts, the caller must wait until the method call returns before continuing the subsequent behavior.<br>An asynchronous method call is more like a message pass, once it starts, the method call returns immediately and the caller can continue with the subsequent actions. The asynchronous method is usually executed in another thread, “for real”. The whole process, without impeding the caller’s work<br>Two more diagrams for better understanding<br>Synchronous execution of</p>\n<p>img<br>img</p>\n<p>Synchronous execution is executed when the method is called and the result is returned before the subsequent code is executed</p>\n<p>Asynchronous execution</p>\n<p>img<br>img</p>\n<p>Asynchronous calls can be referred to as ajax, where the method is called without waiting for the sum method to complete, and the subsequent code is executed directly. sum method notifies the main thread of the completion of execution, mainly through status, or through a callback that handles the results of the asynchronous method execution.</p>\n<p>Synchronous asynchronous is not to be confused with non-blocking<br>After reading the above explanation, you may say that this is not a blocking mechanism? No, no, no, synchronous asynchronous is not to be confused with blocking or non-blocking.</p>\n<p>Blocking and non-blocking emphasize the state of the program while waiting for the result of the call (message, return value). A blocking call means that the current thread is hung until the result of the call is returned. The calling thread will return only after the result is obtained. A non-blocking call is one that does not block the current thread until the result is immediately available. For synchronous calls, many times the current thread is still active, but logically the current function does not return, i.e. it does nothing while synchronously waiting, taking up resources for nothing.</p>\n<p>Synchronous and asynchronous emphasize the message communication mechanism (synchronous communication/ asynchronous communication). Synchronous means that when a “call” is made, the “call” does not return until the result is obtained. But once the call returns, the return value is obtained. In other words, the “caller” is actively waiting for the result of the “call”. Asynchronous, on the other hand, is the opposite: after the “call” is made, the call returns directly, so no result is returned. In other words, when an asynchronous procedure call is issued, the caller does not get the result immediately. Instead, after the “call” is made, the “callee” notifies the caller through status, notification, or a callback function that handles the call.</p>\n<p>Reference blog: <a href=\"https://blog.csdn.net/huangqiang1363/article/details/79508852\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/huangqiang1363/article/details/79508852</a></p>\n<p>c language partitions<br>Stack Stack (large address, used from high to low)<br>Heap (used from low to high)<br>Global or static constants area<br>Text and code area (small address)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> total = <span class=\"number\">0</span>; <span class=\"comment\">//global or static constants area</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hehe</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//function, in stack</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> he = <span class=\"number\">0</span>; <span class=\"comment\">//global or static constant area, because static will only be created once</span></span><br><span class=\"line\">he++;</span><br><span class=\"line\">total++;</span><br><span class=\"line\">total++; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> k = <span class=\"number\">3</span>; <span class=\"comment\">//internal variable of the function, in the stack, but 3 is in the code area</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *str = <span class=\"string\">\"Hello, world!\"</span>; <span class=\"comment\">// internal variable in str function, in stack, \"hello world\" is in constant area</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = (<span class=\"keyword\">int</span> *) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)); <span class=\"comment\">// p in stack, malloc dynamically allocated memory in heap</span></span><br><span class=\"line\">hehe();</span><br><span class=\"line\">hehe();</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d%s%d\"</span>, k, str, *p);</span><br><span class=\"line\"><span class=\"built_in\">free</span>(p);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">//stack memory free</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Classes-and-objects\"><a href=\"#Classes-and-objects\" class=\"headerlink\" title=\"Classes and objects\"></a>Classes and objects</h1><p>Classes: A class is a template that describes the behavior and state of a class of objects.<br>Object: An object is an instance of a class<br>How c handles classes and objects.</p>\n<p>There are no “classes”, only “types”.</p>\n<p>There are no “objects”, only “variables”</p>\n<p>Structured variables + functions</p>\n<p>The c language uses struct variables + functions to achieve similar functionality, as follows</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> id;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printID</span><span class=\"params\">(struct Student \\*in)</span></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"My id is %d.\\n\"</span>,in-&gt;id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">one</span>;</span></span><br><span class=\"line\">one.id=<span class=\"number\">999</span>;</span><br><span class=\"line\">printID(&amp;one);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>However, we found that the properties of Student and the operations added to the properties are separated, we can solve this problem by using the function pointer class</p>\n<p>function pointer</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> id;</span><br><span class=\"line\"><span class=\"keyword\">void</span> (*printID)(struct Student *in);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printID</span><span class=\"params\">(struct Student \\*in)</span></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"My id is %d.\\n\"</span>,in-&gt;id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">one</span>;</span></span><br><span class=\"line\">one.id=<span class=\"number\">999</span>;</span><br><span class=\"line\">one.printID=printID;</span><br><span class=\"line\">one.printID(&amp;one);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"A-different-experience-writing-C-programs-with-plain-text-command-line\"><a href=\"#A-different-experience-writing-C-programs-with-plain-text-command-line\" class=\"headerlink\" title=\"A different experience, writing C++ programs with plain text command line\"></a>A different experience, writing C++ programs with plain text command line</h1><p>Open vmware and run ubuntu<br>Right-click on the desktop to open a terminal<br>Enter the command ls to see where you are<br>Enter the command cd desktop to enter the desktop folder<br>Enter the command touch test.cpp to create the test.cpp file<br>Open the test.cpp file, enter the following code and save it to insert the image description here<br>Insert the image description here<br>Enter the command g++ test.cpp to compile the test.cpp file, we find that a new file a.out is created on the desktop, this is the compiled executable file, next we run it<br>Next, we run it by entering the command . /a.out to run it and find the following output: Insert image description here<br>Insert the image description here</p>\n<h1 id=\"New-features-of-c\"><a href=\"#New-features-of-c\" class=\"headerlink\" title=\"New features of c++\"></a>New features of c++</h1><p>Classes<br>As mentioned before</p>\n<p>bool type and auto type<br>bool, in c, true or false is replaced by a shape, 0 –&gt; False &amp;&amp; !0 –&gt; True &amp;&amp; True –&gt; &amp;&amp; False –&gt; 0</p>\n<p>In c++, you can true, false, and also use 0 and 1</p>\n<p>auto, let the compiler infer what type it is, but it must be assigned at initialization, otherwise the compiler reports an error</p>\n<p>cout, which prints floating point numbers with the latter part omitted</p>\n<p>References<br>C<br>int a = 3; //defines the variable a and initializes it with 3, = is not the operator = means initialize<br>int b; //defines variable b, not initialized<br>b = 3; //assigns 3 to b, = is an operator</p>\n<p>int array[10]={1,2,3}; //defines the array array and initializes it with {1,2,3}<br>array={1,2,3}; //error<br>array[10]={1,2,3}; //error<br>C<br>int _p; // _ means that p is a pointer, not a fetch operator, and p is a pointer to an int type<br>int a = 3;<br>p = &a;<br>_p = 6; // _ is the value taking operator<br>C<br>int b = 6;<br>int &amp;r = b; // &amp; means r is a reference type, not a take address operator, r is a reference of int type, = means initialize r with b, let r become a reference of b, not an assignment, can be understood as a nickname for b, from then on r is b, b is r<br>r = 123;<br>cout &lt;&lt; r &lt;&lt; endl; // 123<br>cout &lt;&lt; b &lt;&lt; endl; // 123<br>Parameter passing of functions in C++.</p>\n<p>Pass by value (pass by value)<br>Pass by address (pass by pointer)<br>Pass by reference<br>The reference must be initialized at definition time, and once created, the referenced object cannot be replaced</p>\n<p>C<br>int b = 6;<br>int &r; //error: ‘r’ declared as reference but not initialized<br>r = b; //assign the value of b to r, but at this point r does not have any reference<br>About the assignment<br>C<br>int a, b, c;<br>(a = b = c = 3) = 666;<br>cout &lt;&lt; a &lt;&lt; endl; //666<br>cout &lt;&lt; b &lt;&lt; endl; //3<br>cout &lt;&lt; c &lt;&lt; endl; //3<br>The reference returned after the assignment is the left value</p>\n<p>New syntax for initialization</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a&#123;<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[<span class=\"number\">5</span>]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"keyword\">and</span> <span class=\"keyword\">delete</span></span><br></pre></td></tr></table></figure>\n\n<p>int _p;<br>p = (int _) malloc(sizeof(int));<br>free(p);<br>p = new int;<br>delete p;<br>deleete[] p; //complex types should be written like this</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"iostream\"</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"keyword\">int</span> sid;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">Student one, two;</span><br><span class=\"line\">one.sid = <span class=\"number\">1</span>;</span><br><span class=\"line\">two.sid = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; &amp;one &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; &amp;two &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">one = two;</span><br><span class=\"line\">two.sid = <span class=\"number\">999</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; &amp;one &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; &amp;two &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"iostream\"</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"keyword\">int</span> sid;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">Student *one = <span class=\"keyword\">new</span> Student();</span><br><span class=\"line\">Student *two = <span class=\"keyword\">new</span> Student();</span><br><span class=\"line\"><span class=\"comment\">// Student *one, *two;</span></span><br><span class=\"line\"><span class=\"comment\">// one = new Student();</span></span><br><span class=\"line\"><span class=\"comment\">// two = new Student();</span></span><br><span class=\"line\">one-&gt;sid = <span class=\"number\">1</span>;</span><br><span class=\"line\">two-&gt;sid = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; &amp;one &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//0x63fde8</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; &amp;two &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//0x63fde0</span></span><br><span class=\"line\">one = two; <span class=\"comment\">//memory leak</span></span><br><span class=\"line\">two-&gt;sid = <span class=\"number\">999</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; one &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//0x1c1770</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; two &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//0x1c1770</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Further understanding of Java references, equivalent to pointers in c++, java references are not the same as c++ references</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> sid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">Student one = <span class=\"keyword\">new</span> Student(); <span class=\"comment\">// create object must need new</span></span><br><span class=\"line\">Student two = <span class=\"keyword\">new</span> Student();</span><br><span class=\"line\"> one.sid = <span class=\"number\">1</span>;</span><br><span class=\"line\">two.sid = <span class=\"number\">2</span>;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"one: \"</span> + one); <span class=\"comment\">//one: Student@7291c18f</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"two: \"</span> + two); <span class=\"comment\">//two: Student@34a245ab</span></span><br><span class=\"line\">one = two;</span><br><span class=\"line\">two.sid = <span class=\"number\">999</span>;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"one: \"</span> + one); <span class=\"comment\">//one: Student@34a245ab</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"two: \"</span> + two); <span class=\"comment\">//two: Student@34a245ab</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The new for loop<br>for-each is not repeated, you can use auto, each is the value taken out of the container, &amp;each can modify the original value of the container</p>\n<p>Insert the image description here<br>Insert image description here</p>\n<p>Insert image description here<br>Insert image description here</p>\n<p>Overloading<br>C++ allows to specify multiple definitions of a function and operator in the same scope, called function overloading and operator overloading, respectively.</p>\n<p>Several functions with the same name can be declared in the same scope, but the formal parameters (meaning the number, type or order of the arguments) of these functions with the same name must be different. It is not possible to overload a function simply by having a different return type.</p>\n<p>We can redefine or overload most of the C++ built-in operators. This way, you can use operators of custom types.</p>\n<p>Overloaded operators are functions with special names, where the function name is formed by the keyword operator followed by the operator symbol to be overloaded. Like other functions, overloaded operators have a return type and a list of arguments.</p>\n<p>Note: In a function declaration, const can modify the formal parameter to indicate that it is an input parameter whose value cannot be changed inside the function.</p>\n<p>lambda</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> f = [](<span class=\"keyword\">auto</span> a, <span class=\"keyword\">auto</span> b) -&gt; <span class=\"keyword\">auto</span> &#123; <span class=\"keyword\">return</span> a + b; &#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; f(<span class=\"number\">3.1</span>, <span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 8.1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Generics-and-templates\"><a href=\"#Generics-and-templates\" class=\"headerlink\" title=\"Generics and templates\"></a>Generics and templates</h1><p>Generics are concepts, templates are implementations of generics<br>Generic programming lets you write fully generalized and reusable algorithms that are as efficient as those designed for a particular data type. STL, a representative work of generic programming, is an efficient, generic, and interactive software component. It is large and extensible, contains many basic computer algorithms and data structures, and completely separates algorithms from data structures, where algorithms are generic and not tied to any particular data structure or object type. STL is based on Iterators and Containers, a library of Generic Algorithms, and the presence of Containers gives these algorithms something to manipulate. STL is not just a collection of useful components, it is a formal and structured architecture for describing the abstract requirements of software components.</p>\n<h1 id=\"C-language-operators-and-amp-operators\"><a href=\"#C-language-operators-and-amp-operators\" class=\"headerlink\" title=\"C language * operators and &amp; operators\"></a>C language * operators and &amp; operators</h1><p>The &amp; address operator is used to obtain the address of its operand. If the operand x is of type T, the expression &amp;x is of type T pointer (a pointer to T).</p>\n<p>The operand of the addressing operator must be an address that is addressable in memory. In other words, the operator can only be used on functions or objects (e.g., left-valued), not on bit fields, and those that have not yet been declared by the storage class modifier register.</p>\n<p>When a pointer needs to be initialized to point to certain objects or functions, the address of those objects or functions needs to be obtained.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> x, _ptr;ptr = &amp;x; <span class=\"comment\">// legal: make pointer ptr point to xptr = &amp;(x+1); // wrong: (x+1) is not a left value</span></span><br></pre></td></tr></table></figure>\n\n<p>Instead, when you already have a pointer and want to get the object it references, use the indirection operator _, which is sometimes called the dereferencing operator. Its operand must be of type pointer. If ptr is a pointer, then <em>ptr is the object or function pointed to by ptr. If ptr is a pointer to an object, then *ptr is a left value that can be treated as an operand to the left of the assignment operator (i.e. \\</em>ptr).</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> x, *ptr = &amp;x;*ptr = <span class=\"number\">1.7</span>; <span class=\"comment\">// assign 1.7 to the variable x++(\\*ptr); // and add 1 to the value of the variable x</span></span><br></pre></td></tr></table></figure>\n\n<p>In the last statement of this example, the value of ptr remains the same, but the value of x becomes 2.7.</p>\n<p>If the value of a pointer operand is not the address of some object or function, the result of the operation of the indirect operator * cannot be determined.</p>\n<p>Like other unary operands, the operators &amp; and * have a high priority. Operators are combined in a right-to-left manner. Therefore, the parentheses in the expression ++ (*ptr) are not necessary.</p>\n<p>The operators &amp; and * are complementary: if x is an expression that specifies an object or a function, then the expression &amp;x is equal to x. Conversely, in an expression shaped like &amp;ptr, these operators cancel each other out, and the type and value of the expression are equivalent to ptr. However, whether ptr is left-valued or not, &amp;*ptr must not be left-valued.</p>\n<h1 id=\"Understand-Encapsulation\"><a href=\"#Understand-Encapsulation\" class=\"headerlink\" title=\"Understand Encapsulation\"></a>Understand Encapsulation</h1><p>What’s in a class<br>Data (properties)<br>Operations (functions, methods)<br>Access control (public/private)<br>Static/non-static<br>Using classes directly: Static<br>Use of objects: static and non-static<br>Static cannot access non-static</p>\n<h1 id=\"Use-of-classes-and-objects\"><a href=\"#Use-of-classes-and-objects\" class=\"headerlink\" title=\"Use of classes and objects\"></a>Use of classes and objects</h1><p>Defining classes and objects</p>\n<h1 id=\"Code-Reuse\"><a href=\"#Code-Reuse\" class=\"headerlink\" title=\"Code Reuse\"></a>Code Reuse</h1><p>Means of code reuse<br>Function overloading<br>Class inheritance, dynamic<br>excuses</p>\n<h1 id=\"Off-topic\"><a href=\"#Off-topic\" class=\"headerlink\" title=\"Off-topic\"></a>Off-topic</h1><p>Constructors use initialization lists to initialize fields</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Line::Line( <span class=\"keyword\">double</span> len): length(len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Object is being created, length = \"</span> &lt;&lt; len &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The above syntax is equivalent to the following syntax.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Line::Line( <span class=\"keyword\">double</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">length = len;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Object is being created, length = \"</span> &lt;&lt; len &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Use commas to separate the different fields as follows.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">C::C( <span class=\"keyword\">double</span> a, <span class=\"keyword\">double</span> b, <span class=\"keyword\">double</span> c): X(a), Y(b), Z(c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Template\"><a href=\"#Template\" class=\"headerlink\" title=\"Template\"></a>Template</h1><p>Function Templates</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Zhenglin Li on 2020/9/23.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"iostream\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">sum</span><span class=\"params\">(T <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">T s = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">s += <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a1[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">double</span> a2[<span class=\"number\">3</span>] = &#123;<span class=\"number\">1.1</span>, <span class=\"number\">2.2</span>, <span class=\"number\">3.3</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; sum(a1, <span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; sum(a2, <span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; sum(a2, <span class=\"number\">1</span>, <span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Overloading of function templates</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Zhenglin Li on 2020/9/23.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"iostream\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">sum</span><span class=\"params\">(T <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">T s = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">s += <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">sum</span><span class=\"params\">(T <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> from, <span class=\"keyword\">int</span> to)</span> </span>&#123;</span><br><span class=\"line\">T s = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = from - <span class=\"number\">1</span>; i &lt;= to - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">s += <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a1[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">double</span> a2[<span class=\"number\">3</span>] = &#123;<span class=\"number\">1.1</span>, <span class=\"number\">2.2</span>, <span class=\"number\">3.3</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; sum(a1, <span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; sum(a2, <span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; sum(a2, <span class=\"number\">1</span>, <span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Class templates</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Zhenglin Li on 2020/9/23.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"iostream\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"comment\">// Template</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">T x;</span><br><span class=\"line\">T y;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">Vector(T x = <span class=\"number\">0</span>, T y = <span class=\"number\">0</span>) : x(x), y(y) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;o, <span class=\"keyword\">const</span> Vector&lt;T&gt; &amp;v) &#123;</span><br><span class=\"line\">        o &lt;&lt; <span class=\"string\">\"&lt;\"</span> &lt;&lt; v.x &lt;&lt; <span class=\"string\">\", \"</span> &lt;&lt; v.y &lt;&lt; <span class=\"string\">\"&gt;\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// the real class, to &lt;&gt;</span></span><br><span class=\"line\"><span class=\"function\">Vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">x</span><span class=\"params\">(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">Vector&lt;<span class=\"keyword\">double</span>&gt; *p = <span class=\"keyword\">new</span> Vector&lt;<span class=\"keyword\">double</span>&gt;(<span class=\"number\">1.1</span>,<span class=\"number\">2.2</span>);</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Standard Template Library (STL)<br>Standard Template Library<br>Lots of containers<br>Many algorithms</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"c-初探\"><a href=\"#c-初探\" class=\"headerlink\" title=\"c++初探\"></a>c++初探</h1><h1 id=\"C-运算符重载-简单易懂\"><a href=\"#C-运算符重载-简单易懂\" class=\"headerlink\" title=\"C++运算符重载(简单易懂)\"></a>C++运算符重载(简单易懂)</h1><p>运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。</p>\n<p>你可以重定义或重载大部分 C++ 内置的运算符。例如 + 、 - 、 * 、 / 、</p>\n<p>++、–、&gt;&gt;、&lt;&lt;等，这样，你就能使用自定义类型的运算符。</p>\n<p>运算符重载的基本格式<br>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和</p>\n<p>其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个</p>\n<p>返回类型和一个参数列表。</p>\n<p>Point operator+(const Point &amp;);</p>\n<p>运算符重载有两种方式：一种是类内重载（运算符重载函数作为类的成员函数），另一种是类外重载（运算符重载函数作为类的友元函数）</p>\n<p>类内重载</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Point()&#123;&#125;;</span><br><span class=\"line\">    Point (<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class=\"line\">    Point <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point &amp;a)&#123; <span class=\"comment\">//类内重载，运算符重载函数作为类的成员函数</span></span><br><span class=\"line\">        Point ret;</span><br><span class=\"line\">        ret.x = <span class=\"keyword\">this</span>-&gt;x + a.x;</span><br><span class=\"line\">        ret.y = <span class=\"keyword\">this</span>-&gt;y + a.y;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Point a(2,4),b(5,3);</span><br><span class=\"line\">    Point c = a + b;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt; <span class=\"string\">\"x :\"</span> &lt;&lt; c.x &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"y :\"</span> &lt;&lt; c.y &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<p>x : 7</p>\n<p>y: 7</p>\n<p>运算符重载是类内重载时，运算符重载函数作为类的成员函数，以上述代码为例 a + b 相当于 a 对象调用+方法并且传入参数时 b 对象</p>\n<p>类外重载</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Point()&#123;&#125;;</span><br><span class=\"line\">    Point (<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> Point <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point &amp;, <span class=\"keyword\">const</span> Point &amp;);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Point <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point &amp;a,<span class=\"keyword\">const</span> Point &amp;b)&#123;<span class=\"comment\">//类外重载,运算符重载函数作为类的友元函数</span></span><br><span class=\"line\">    Point ret;</span><br><span class=\"line\">    ret.x = a.x + b.x;</span><br><span class=\"line\">    ret.y = a.y + b.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     Point a(2,4),b(5,3);</span><br><span class=\"line\">    Point c = a + b;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt; <span class=\"string\">\"x :\"</span> &lt;&lt; c.x &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"y :\"</span> &lt;&lt; c.y &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生和上面一样的结果</p>\n<p>各种运算符重载实例<br>下面将进行各种运算符重载实例的代码演示，演示几种基本的运算符重载。</p>\n<p>插入运算符重载&gt;&gt; and 提取运算符重载&lt;&lt;<br>以提取运算符重载&lt;&lt;为例，cout 是 ostream 类的对象。ostream 类和 cout 都是在头文件 <iostream>中声明的。ostream 类将&lt;&lt;重载为成员函数。</p>\n<p>下面我们重载&lt;&lt;使用 cout 输出 a 对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Point()&#123;&#125;;</span><br><span class=\"line\">    Point (<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> Point <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point &amp;, <span class=\"keyword\">const</span> Point &amp;);</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;out , <span class=\"keyword\">const</span> Point &amp;a);</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Point <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point &amp;a,<span class=\"keyword\">const</span> Point &amp;b)&#123;</span><br><span class=\"line\">    Point ret;</span><br><span class=\"line\">    ret.x = a.x + b.x;</span><br><span class=\"line\">    ret.y = a.y + b.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;out , <span class=\"keyword\">const</span> Point &amp;a)&#123;</span><br><span class=\"line\">    out &lt;&lt; <span class=\"string\">\"&lt;Point&gt;( \"</span> &lt;&lt; a.x &lt;&lt; <span class=\"string\">\", \"</span> &lt;&lt; a.y &lt;&lt; <span class=\"string\">\")\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Point a(2,4),b(5,3);</span><br><span class=\"line\">    Point c = a + b;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; c&lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt; Point&gt;( <span class=\"number\">7</span>, <span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n\n<p>注意：重载<code>&lt;&lt;</code>时，是类外重载，习惯上人们是使用 <code>cin&gt;&gt;</code> 和 <code>cout&lt;&lt;</code> 的，得使用友元函数来重载运算符，如果使用成员函数来重载会出现 <code>c&lt;&lt;cout;</code> 这种不自然的代码。</p>\n<p>另外应该会有人对 <code>ostream &amp;operator&lt;&lt;(ostream &amp;out , const Point &amp;a)</code>函数感到疑惑，首先在重载&lt;&lt;时，返回值类型是 <code>ostream&amp;</code>, 第一个参数也是 <code>ostream&amp;</code>。也就是说，表达式 <code>cout&lt;&lt;c</code> 的返回值仍是 <code>cout</code>，所以 <code>cout&lt;&lt;c&lt;&lt;endl;</code>才能成立</p>\n<p>前置运算符重载++ and 后置运算符重载++</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Point()&#123;&#125;;</span><br><span class=\"line\">    Point (<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> Point <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point &amp;, <span class=\"keyword\">const</span> Point &amp;);</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;out , <span class=\"keyword\">const</span> Point &amp;a);</span><br><span class=\"line\">    Point&amp; <span class=\"keyword\">operator</span>++()&#123; <span class=\"comment\">//前置运算符，需要引用返回，不需要参数。返回自增后的值，且返回的是一个左值</span></span><br><span class=\"line\">        x++;</span><br><span class=\"line\">        y++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> Point <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>)&#123;<span class=\"comment\">//后置++，不需要引用返回，需要参数区分。返回自增前的值，且返回的是一个右值</span></span><br><span class=\"line\">        <span class=\"function\">Point <span class=\"title\">temp</span><span class=\"params\">(x,y)</span></span>;</span><br><span class=\"line\">        x++;</span><br><span class=\"line\">        y++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Point <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Point &amp;a,<span class=\"keyword\">const</span> Point &amp;b)&#123;</span><br><span class=\"line\">    Point ret;</span><br><span class=\"line\">    ret.x = a.x + b.x;</span><br><span class=\"line\">    ret.y = a.y + b.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;out , <span class=\"keyword\">const</span> Point &amp;a)&#123;</span><br><span class=\"line\">    out &lt;&lt; <span class=\"string\">\"&lt;Point&gt;(\"</span> &lt;&lt; a.x &lt;&lt; <span class=\"string\">\" , \"</span> &lt;&lt; a.y &lt;&lt; <span class=\"string\">\")\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Point a(2,4),b(5,3);</span><br><span class=\"line\">    Point c = a + b;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    c++;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    ++c;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(7 , 7)</span><br><span class=\"line\">&lt; Point&gt;(8 , 8)</span><br><span class=\"line\">&lt; Point&gt;(9 , 9)</span><br></pre></td></tr></table></figure>\n\n<p>1&gt;为区别前置和后置运算符，需要在后置运算符重载函数中加参数“int”，虽然这个类型在此除了以示区别之外并不代表任何实际含义；</p>\n<p>2&gt;前置返回的是变量的引用，后置返回的是常量。所以++++c 合法，而 c++++不合法;</p>\n<p>3&gt;为什么不让 c++++也合法呢？如果要实现 c++++合法，必须使后置返回变量或变量的引用。c++是先返回 c 值再+1，所以不可能返回 c，那就只能先建立局部变量来保存 c 的初值，然后再返回局部变量（局部变量不允许返回引用），但返回了局部变量之后，如果再连着进行下一次++运算，参与运算的就是这个局部变量的值了，所以此时 c++++其实等效与 c++，也就没有存在的意义了。</p>\n<h1 id=\"C-中-new-delete-和-malloc-free-的区别\"><a href=\"#C-中-new-delete-和-malloc-free-的区别\" class=\"headerlink\" title=\"C++中 new/delete 和 malloc/free 的区别\"></a>C++中 new/delete 和 malloc/free 的区别</h1><p>1、new、delete 是 C++中的操作符，而 malloc 和 free 是标准库函数。</p>\n<p>2、对于非内部数据对象来说，只使用 malloc 是无法完成动态对象要求的，一般在创建对象时需要调用构造函数，对象消亡时，自动的调用析构函数。而 malloc free 是库函数而不是运算符，不在编译器控制范围之内，不能够自动调用构造函数和析构函数。而 NEW 在为对象申请分配内存空间时，可以自动调用构造函数，同时也可以完成对对象的初始化。同理，delete 也可以自动调用析构函数。而 mallloc 只是做一件事，只是为变量分配了内存，同理，free 也只是释放变量的内存。</p>\n<p>3、new 返回的是指定类型的指针，并且可以自动计算所申请内存的大小。而 malloc 需要我们计算申请内存的大小，并且在返回时强行转换为实际类型的指针。</p>\n<p>new 和 delete 到底是什么？<br>如果找工作的同学看一些面试的书，我相信都会遇到这样的题：sizeof 不是函数，然后举出一堆的理由来证明 sizeof 不是函数。在这里，和 sizeof 类似，new 和 delete 也不是函数，它们都是 C++ 定义的关键字，通过特定的语法可以组成表达式。和 sizeof 不同的是，sizeof 在编译时候就可以确定其返回值，new 和 delete 背后的机制则比较复杂。<br>继续往下之前，请你想想你认为 new 应该要做些什么？也许你第一反应是，new 不就和 C 语言中的 malloc 函数一样嘛，就用来动态申请空间的。你答对了一半，看看下面语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> *ps = <span class=\"keyword\">new</span> <span class=\"built_in\">string</span>(<span class=\"string\">\"hello world\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>你就可以看出 new 和 malloc 还是有点不同的，malloc 申请完空间之后不会对内存进行必要的初始化，而 new 可以。所以 new expression 背后要做的事情不是你想象的那么简单。在我用实例来解释 new 背后的机制之前，你需要知道 operator new 和 operator delete 是什么玩意。</p>\n<p>operator new 和 operator delete<br>这两个其实是 C++ 语言标准库的库函数，原型分别如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"keyword\">operator</span> <span class=\"title\">new</span><span class=\"params\">(<span class=\"keyword\">size_t</span>)</span></span>;     <span class=\"comment\">//allocate an object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"keyword\">operator</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"keyword\">void</span> *)</span></span>;    <span class=\"comment\">//free an object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> *<span class=\"keyword\">operator</span> <span class=\"keyword\">new</span>[](<span class=\"keyword\">size_t</span>);     <span class=\"comment\">//allocate an array</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> *<span class=\"keyword\">operator</span> <span class=\"keyword\">delete</span>[](<span class=\"keyword\">void</span> *);    <span class=\"comment\">//free an array</span></span><br></pre></td></tr></table></figure>\n\n<p>后面两个你可以先不看，后面再介绍。前面两个均是 C++ 标准库函数，你可能会觉得这是函数吗？请不要怀疑，这就是函数！C++ Primer 一书上说这不是重载 new 和 delete 表达式（如 operator= 就是重载 = 操作符），因为 new 和 delete 是不允许重载的。但我还没搞清楚为什么要用 operator new 和 operator delete 来命名，比较费解。我们只要知道它们的意思就可以了，这两个函数和 C 语言中的 malloc 和 free 函数有点像了，都是用来申请和释放内存的，并且 operator new 申请内存之后不对内存进行初始化，直接返回申请内存的指针。</p>\n<p>我们可以直接在我们的程序中使用这几个函数。</p>\n<p>new 和 delete 背后机制<br>知道上面两个函数之后，我们用一个实例来解释 new 和 delete 背后的机制：</p>\n<p>我们不用简单的 C++ 内置类型来举例，使用复杂一点的类类型，定义一个类 A：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    A(<span class=\"keyword\">int</span> v) : var(v)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fopen_s(&amp;file, <span class=\"string\">\"test\"</span>, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~A()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fclose(file);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> var;</span><br><span class=\"line\">    FILE *file;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>很简单，类 A 中有两个私有成员，有一个构造函数和一个析构函数，构造函数中初始化私有变量 var 以及打开一个文件，析构函数关闭打开的文件。</p>\n<p>我们使用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> *<span class=\"title\">pA</span> = <span class=\"title\">new</span> <span class=\"title\">A</span>(10);</span></span><br></pre></td></tr></table></figure>\n\n<p>来创建一个类的对象，返回其指针 pA。如下图所示 new 背后完成的工作：</p>\n<p>简单总结一下：</p>\n<p>首先需要调用上面提到的 operator new 标准库函数，传入的参数为 class A 的大小，这里为 8 个字节，至于为什么是 8 个字节，你可以看看《深入 C++ 对象模型》一书，这里不做多解释。这样函数返回的是分配内存的起始地址，这里假设是 0x007da290。<br>上面分配的内存是未初始化的，也是未类型化的，第二步就在这一块原始的内存上对类对象进行初始化，调用的是相应的构造函数，这里是调用 A:A(10); 这个函数，从图中也可以看到对这块申请的内存进行了初始化，var=10, file 指向打开的文件。<br>最后一步就是返回新分配并构造好的对象的指针，这里 pA 就指向 0x007da290 这块内存，pA 的类型为类 A 对象的指针。<br>所有这三步，你都可以通过反汇编找到相应的汇编代码，在这里我就不列出了。</p>\n<p>好了，那么 delete 都干了什么呢？还是接着上面的例子，如果这时想释放掉申请的类的对象怎么办？当然我们可以使用下面的语句来完成：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> pA;</span><br></pre></td></tr></table></figure>\n\n<p>delete 所做的事情如下图所示：</p>\n<p>img<br>img</p>\n<p>delete 就做了两件事情：</p>\n<p>调用 pA 指向对象的析构函数，对打开的文件进行关闭。<br>通过上面提到的标准库函数 operator delete 来释放该对象的内存，传入函数的参数为 pA 的值，也就是 0x007d290。<br>好了，解释完了 new 和 delete 背后所做的事情了，是不是觉得也很简单？不就多了一个构造函数和析构函数的调用嘛。</p>\n<p>如何申请和释放一个数组？<br>我们经常要用到动态分配一个数组，也许是这样的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> *psa = <span class=\"keyword\">new</span> <span class=\"built_in\">string</span>[<span class=\"number\">10</span>]; <span class=\"comment\">//array of 10 empty strings</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *pia = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>]; <span class=\"comment\">//array of 10 uninitialized ints</span></span><br></pre></td></tr></table></figure>\n\n<p>上面在申请一个数组时都用到了 new [] 这个表达式来完成，按照我们上面讲到的 new 和 delete 知识，第一个数组是 string 类型，分配了保存对象的内存空间之后，将调用 string 类型的默认构造函数依次初始化数组中每个元素；第二个是申请具有内置类型的数组，分配了存储 10 个 int 对象的内存空间，但并没有初始化。</p>\n<p>如果我们想释放空间了，可以用下面两条语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> [] psa;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> [] pia;</span><br></pre></td></tr></table></figure>\n\n<p>都用到 delete [] 表达式，注意这地方的 [] 一般情况下不能漏掉！我们也可以想象这两个语句分别干了什么：第一个对 10 个 string 对象分别调用析构函数，然后再释放掉为对象分配的所有内存空间；第二个因为是内置类型不存在析构函数，直接释放为 10 个 int 型分配的所有内存空间。</p>\n<p>这里对于第一种情况就有一个问题了：我们如何知道 psa 指向对象的数组的大小？怎么知道调用几次析构函数？</p>\n<p>这个问题直接导致我们需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。</p>\n<p>还是用图来说明比较清楚，我们定义了一个类 A，但不具体描述类的内容，这个类中有显示的构造函数、析构函数等。那么 当我们调用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> \\*<span class=\"title\">pAa</span> = <span class=\"title\">new</span> <span class=\"title\">A</span>[3];</span></span><br></pre></td></tr></table></figure>\n\n<p>时需要做的事情如下：</p>\n<p>img<br>img</p>\n<p>从这个图中我们可以看到申请时在数组对象的上面还多分配了 4 个字节用来保存数组的大小，但是最终返回的是对象数组的指针，而不是所有分配空间的起始地址。</p>\n<p>这样的话，释放就很简单了：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> [] pAa;</span><br></pre></td></tr></table></figure>\n\n<p>img<br>img</p>\n<p>这里要注意的两点是：</p>\n<p>调用析构函数的次数是从数组对象指针前面的 4 个字节中取出；<br>传入 operator delete[] 函数的参数不是数组对象的指针 pAa，而是 pAa 的值减 4。<br>为什么 new/delete 、new []/delete[] 要配对使用？<br>其实说了这么多，还没到我写这篇文章的最原始意图。从上面解释的你应该懂了 new/delete、new[]/delete[] 的工作原理了，因为它们之间有差别，所以需要配对使用。但偏偏问题不是这么简单，这也是我遇到的问题，如下这段代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> \\*pia = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">delete</span> []pia;</span><br></pre></td></tr></table></figure>\n\n<p>这肯定是没问题的，但如果把 delete []pia; 换成 delete pia; 的话，会出问题吗？</p>\n<p>这就涉及到上面一节没提到的问题了。上面我提到了在 new [] 时多分配 4 个字节的缘由，因为析构时需要知道数组的大小，但如果不调用析构函数呢（如内置类型，这里的 int 数组）？我们在 new [] 时就没必要多分配那 4 个字节， delete [] 时直接到第二步释放为 int 数组分配的空间。如果这里使用 delete pia;那么将会调用 operator delete 函数，传入的参数是分配给数组的起始地址，所做的事情就是释放掉这块内存空间。不存在问题的。</p>\n<p>这里说的使用 new [] 用 delete 来释放对象的提前是：对象的类型是内置类型或者是无自定义的析构函数的类类型！</p>\n<p>我们看看如果是带有自定义析构函数的类类型，用 new [] 来创建类对象数组，而用 delete 来释放会发生什么？用上面的例子来说明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> \\*<span class=\"title\">pAa</span> = <span class=\"title\">new</span> <span class=\"title\">class</span> <span class=\"title\">A</span>[3];</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pAa;</span><br></pre></td></tr></table></figure>\n\n<p>那么 delete pAa; 做了两件事：</p>\n<p>调用一次 pAa 指向的对象的析构函数；<br>调用 operator delete(pAa); 释放内存。<br>显然，这里只对数组的第一个类对象调用了析构函数，后面的两个对象均没调用析构函数，如果类对象中申请了大量的内存需要在析构函数中释放，而你却在销毁数组对象时少调用了析构函数，这会造成内存泄漏。</p>\n<p>上面的问题你如果说没关系的话，那么第二点就是致命的了！直接释放 pAa 指向的内存空间，这个总是会造成严重的段错误，程序必然会奔溃！因为分配的空间的起始地址是 pAa 指向的地方减去 4 个字节的地方。你应该传入参数设为那个地址！</p>\n<p>同理，你可以分析如果使用 new 来分配，用 delete [] 来释放会出现什么问题？是不是总会导致程序错误？</p>\n<p>总的来说，记住一点即可：new/delete、new[]/delete[] 要配套使用总是没错的！</p>\n<h1 id=\"关于-iostream-与-using-namespace-std-的解析\"><a href=\"#关于-iostream-与-using-namespace-std-的解析\" class=\"headerlink\" title=\"关于 iostream 与 using namespace std 的解析\"></a>关于 iostream 与 using namespace std 的解析</h1><p>当我们在使用 C++语法进行编程练习的时候，往往在代码的前两行会这样来写</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">include&lt;iostream&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br></pre></td></tr></table></figure>\n\n<p>学过 C 语言的同学在学习 C++的时候是否会产生这样的疑惑呢：</p>\n<p>练习 C 语言编程的时候，只需要声明一个头文件：#include&lt;stdio.h&gt;.而为什么在 C++中，却需要写出 include 和 using namespace std;这两行代码呢？</p>\n<p>其中第一行 include 我们还勉强可以理解，它其实类似于 C 语言中的#include&lt;stdio.h&gt;，即：声明标准的输入输出头文件。然而 using namespace std 究竟起到了什么作用呢？</p>\n<p>针对这个问题，网络上有很多专业的说法，但是长篇大论的内容，对于初学者来说实在头疼，根本看不进去，所以接下来我希望可以用简练的语言来解释清楚 using namespace std 的作用，以下的内容虽可能有些许冗余，但我相信是通俗易懂的，您只要能够一行行的看下去，一定能够完全看懂！</p>\n<p>本人认为正确的学习顺序是：我们要做到先学会定义、使用和理解命名空间(namespace)，再回过头去研究 using namespace std;的作用，这样可以起到事半功倍的效果，那么接下来重点就来了。</p>\n<p>定义命名空间<br>（1）简单的命名空间</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、定义命名空间 A</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">0</span>;<span class=\"comment\">//在命名空间 A 中定义变量 a</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义一个命名空间就是这样简单：在这个命名空间 A 中，有一个 int 型的变量，他的名字是“a”。那么我们接下来直接上难度！定义一个复杂的命名空间。</p>\n<p>（2）复杂的命名空间</p>\n<p>要求：定义命名空间 B，并在命名空间 B 中定义命名空间 C，并在命名空间 C 中定义结构体 Teacher</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//2、复杂的命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> B <span class=\"comment\">//定义命名空间 B</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;<span class=\"comment\">//在命名空间 B 中也可以定义变量 a，因为他们不在同一个命名空间中</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> C<span class=\"comment\">//还可以在命名空间 B 中再定义一个命名空间 C</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Teacher</span>//在命名空间 <span class=\"title\">C</span> 中定义结构体 <span class=\"title\">Teacher</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> a[<span class=\"number\">32</span>];<span class=\"comment\">//结构体中还可以定义变量 a，因为这三个“a”都不在同一个命名空间中</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用命名空间<br>（1）使用命名空间的基本方法</p>\n<p>前面已经定义好了命名空间 A、B、C，且在这三个命名空间中都定义相同的变量“a”，接下来我们就来使用这三个命名空间。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//使用命名空间的基本方法 1</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> A;<span class=\"comment\">//告诉编译器我要使用命名空间 A 中的功能了</span></span><br><span class=\"line\">a=<span class=\"number\">10</span>; <span class=\"comment\">//将命名空间 A 中的变量“a”由 0 更改为 10</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>; <span class=\"comment\">//查看是否完成了更改，此时屏幕上应该输出“10</span></span><br></pre></td></tr></table></figure>\n\n<p>注：此时只使用了命名空间 A，所以只会对命名空间 A 中的变量 a 进行访问，而不会对命名空间 B、C 中的变量 a 进行访问。</p>\n<p>而实际上，针对上面这三行代码，只要第三行代码中变量“a”的指向明确，便可以省去第一行“using namespace A”，如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用命名空间的基本方法 2</span></span><br><span class=\"line\"><span class=\"comment\">//由于在代码中只要使用这两种方法中的其中一种即可，所以我在第二种方法这里加上的“//”注释符号，如下两行代码：</span></span><br><span class=\"line\"><span class=\"comment\">// a=10;</span></span><br><span class=\"line\"><span class=\"comment\">// cout&lt;&lt;A::a&lt;&lt;endl; //“A::a”明确指向了命名空间 A 中的变量 a（用双冒号::）</span></span><br></pre></td></tr></table></figure>\n\n<p>以上两种使用命名空间的方法供君随意挑选^_^</p>\n<p>（2）使用复杂的命名空间</p>\n<p>命名空间 A 的使用相对简单，但是在命名空间 B 中嵌套着命名空间 C，并且命名空间 C 中又嵌套着结构体 Teacher，那么我们又该如何去使用命名空间 B 和命名空间 C 呢？</p>\n<p>接下来，除了使用命名空间 A 以外，如果我们还使用了命名空间 B 的话，” a=10; “ 这条语句的指向就不明确了：因为命名空间 B 中也有个变量 a，于是现在有两个”a”可以被访问。故：若想访问某一个特定的变量 a 就需要指向明确！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> B;</span><br><span class=\"line\"><span class=\"comment\">//如果想访问某一个特定的变量 a，就需要指向明确！如下：</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;A::a&lt;&lt;<span class=\"built_in\">endl</span>; <span class=\"comment\">//明确指向了“命名空间 A”</span></span><br><span class=\"line\"><span class=\"comment\">//虽然现在有 A、B 两个命名空间，且两个命名空间中都有变量“a”，但只要指向明确，就能指定我们所访问的变量究竟是命名空间 A 中的“a”还是命名空间 B 中的“a”</span></span><br></pre></td></tr></table></figure>\n\n<p>（3）使用结构体 Teacher 中的变量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如何使用 Teacher</span></span><br><span class=\"line\"><span class=\"comment\">//方法 1：这种方法每定义一个结构体就需要：“B::C::Teacher 结构体名称”</span></span><br><span class=\"line\"><span class=\"comment\">//B::C::Teacher t1;//用命名空间 B 中的命名空间 C 中的结构体模板（Teacher）来定义结构体 t1</span></span><br><span class=\"line\"><span class=\"comment\">//t1.b=33;//注意：t1.a 语法错误！是因为 a 是一个指针（地址），这个指针是无法被修改的，否则以后无法释放内存</span></span><br><span class=\"line\"> <span class=\"comment\">//方法 2：先一口气直接定义好“结构体型”数据类型，然后按照根据数据类型定义变量的方法来使用结构体</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> B::C::Teacher;</span><br><span class=\"line\">Teacher t2;</span><br><span class=\"line\">t2.b=<span class=\"number\">22</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于 iostream 与 using namespace std 的解析****<br>（1）通过以上关于命名空间的定义及使用的介绍，我们不难发现：不同的命名空间之间是相互独立的个体，虽然附加在其中的变量名可能是相同的（比如上面所提到的命名空间 A、B、C 中都包含有变量 a），但是没关系：“命名空间” 这层 “屏障”将这些相同的变量名分隔开来，让他们虽然拥有相同的名字，但是互不影响。</p>\n<p>（2）看起来命名空间的引入十分方便，让我们不必再因为变量重名而烦恼。但是在以前，并没有命名空间这个概念，而是将标准库功能定义在全局空间里，并声明在&lt;iostream.h&gt;（早期的 C++头文件）中。但是由于标准库非常的庞大，那么程序员在选择的类的名称或函数名时，就很有可能和标准库中的某个名字相同。所以为了避免这种情况所造成的名字冲突，就把标准库中的一切都放在一个名为 std 的命名空间中。后来 C++标准为了和 C 区别开，也为了正确使用命名空间，规定头文件不使用后缀.h，即出现了现在的头文件。</p>\n<p>（3）当使用的时候，该头文件没有定义全局命名空间，必须使用 C++所规定的标准的命名空间（即：namespace std），这样才能正确使用 cout、endl 等功能。</p>\n<p>（4）最后：如果大家想进一步了解相关内容，请参考：点击打开链接 谢谢。</p>\n<h1 id=\"c-定义结构体\"><a href=\"#c-定义结构体\" class=\"headerlink\" title=\"c++定义结构体\"></a>c++定义结构体</h1><p>先定义结构体类型再单独进行变量定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ```cpp;</span><br><span class=\"line\"><span class=\"keyword\">char</span> Name[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"keyword\">char</span> Sex;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">Stu</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">Stu</span>[10];</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> \\*<span class=\"title\">pStru</span>;</span></span><br></pre></td></tr></table></figure>\n\n<p>结构体类型是 struct Student，因此，struct 和 Student 都不能省略。但实际上，我用 ```cppblocks 运行时，下面变量的定义，不加 struct 也是可以的。</p>\n<p>紧跟在结构体类型说明之后进行定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ```cpp;</span><br><span class=\"line\"><span class=\"keyword\">char</span> Name[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"keyword\">char</span> Sex;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Age;</span><br><span class=\"line\">&#125;Stu,Stu[<span class=\"number\">10</span>],\\*pStu;</span><br></pre></td></tr></table></figure>\n\n<p>这种情况时，后面还可以再定义结构体变量。</p>\n<p>在说明一个无名结构体变量的同时直接进行定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ```cpp;</span><br><span class=\"line\"><span class=\"keyword\">char</span> Name[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"keyword\">char</span> Sex;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Age;</span><br><span class=\"line\">&#125;Stu,Stu[<span class=\"number\">10</span>],\\*pStu;</span><br></pre></td></tr></table></figure>\n\n<p>这种情况下，之后不能再定义其他变量。</p>\n<p>使用 typedef 说明一个结构体变量之后再用新类名来定义变量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ```cpp;</span><br><span class=\"line\"><span class=\"keyword\">char</span> Name[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"keyword\">char</span> Sex;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Age;</span><br><span class=\"line\">&#125;student;</span><br></pre></td></tr></table></figure>\n\n<p>Student Stu,Stu[10],*pStu;<br>Student 是一个具体的结构体类型，唯一标识。这里不用再加 struct</p>\n<h1 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h1><p>什么是同步与异步<br>定义：同步和异步关注的是<em>消息通信机制</em> (synchronous communication/ asynchronous communication)。同步，就是调用某个东西是，调用方得等待这个调用返回结果才能继续往后执行。异步，和同步相反 调用方不会理解得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状体来通知调用者，或者通过回掉函数来处理这个调用**</p>\n<p>比方说：你去商城买东西，你看上了一款手机，能和店家说你一个这款手机，他就去仓库拿货，你得在店里等着，不能离开，这叫做同步。现在你买手机赶时髦直接去京东下单，下单完成后你就可用做其他时间（追剧、打王者、lol）等货到了去签收就 ok 了.这就叫异步。</p>\n<p>以方法调用为例<br>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。<br>异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作<br>加两张图更好理解<br>同步执行</p>\n<p>img<br>img</p>\n<p>同步执行当调用方法执行完成后并返回结果，才能执行后续代码</p>\n<p>异步执行</p>\n<p>img<br>img</p>\n<p>异步调用的话可用参考 ajax，调用方法后不会等到 sum 方法执行完成，而是直接执行后续代码。sum 方法执行完成后主要通过状态通知主线程，或者通过回调处理这次异步方法执行的结果</p>\n<p>同步异步于阻塞非阻塞不能混为一谈<br>看了上面的讲解，你可能会说这不就是阻塞机制吗？不不不，同步异步不能和阻塞非阻塞混为一谈。</p>\n<p>阻塞和非阻塞 强调的是程序在等待调用结果（消息，返回值）时的状态. 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 对于同步调用来说，很多时候当前线程还是激活的状态，只是从逻辑上当前函数没有返回而已，即同步等待时什么都不干，白白占用着资源。</p>\n<p>同步和异步强调的是消息通信机制 (synchronous communication/ asynchronous communication)。所谓同步，就是在发出一个”调用”时，在没有得到结果之前，该“调用”就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由“调用者”主动等待这个“调用”的结果。而异步则是相反，”调用”在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在”调用”发出后，”被调用者”通过状态、通知来通知调用者，或通过回调函数处理这个调用</p>\n<p>参考博客：<a href=\"https://blog.csdn.net/huangqiang1363/article/details/79508852\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/huangqiang1363/article/details/79508852</a></p>\n<p>c 语言分区<br>栈 Stack（大地址，由高向低使用）<br>堆 Heap（由低向高使用）<br>全局 or 静态常量区<br>文本 and 代码区（小地址）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> total = <span class=\"number\">0</span>; <span class=\"comment\">//全局 or 静态常量区</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hehe</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//函数,在 stack 中</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> he = <span class=\"number\">0</span>; <span class=\"comment\">//全局 or 静态常量区，因为 static 只会创建一次</span></span><br><span class=\"line\">he++;</span><br><span class=\"line\">total++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> k = <span class=\"number\">3</span>; <span class=\"comment\">//函数的内部变量，在 stack 中，但 3 在代码区</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *str = <span class=\"string\">\"Hello, world!\"</span>; <span class=\"comment\">// str 函数中内部变量，在 stack 中，“hello world”在常量区</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = (<span class=\"keyword\">int</span> *) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)); <span class=\"comment\">// p 在 stack 中，malloc 动态分配的内存在堆中</span></span><br><span class=\"line\">hehe();</span><br><span class=\"line\">hehe();</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d%s%d\"</span>, k, str, *p);</span><br><span class=\"line\"><span class=\"built_in\">free</span>(p);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">//stack 中内存释放</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a>类和对象</h1><p>类：类是一个模板，它描述一类对象的行为和状态。<br>对象：对象是类的一个实例<br>c 语言如何处理类和对象：</p>\n<p>没有“类”，只有“类型”</p>\n<p>没有“对象”，只有“变量”</p>\n<p>结构体变量+函数</p>\n<p>c 语言采用结构体变量+函数的方式来实现类似功能，如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> id;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printID</span><span class=\"params\">(struct Student \\*in)</span></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"My id is %d.\\n\"</span>,in-&gt;id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">one</span>;</span></span><br><span class=\"line\">one.id=<span class=\"number\">999</span>;</span><br><span class=\"line\">printID(&amp;one);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但我们发现，Student 的属性和加在属性上的操作是割裂开的，我们可以使用函数指针类解决此问题</p>\n<p>函数指针</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> id;</span><br><span class=\"line\"><span class=\"keyword\">void</span> (*printID)(struct Student *in);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printID</span><span class=\"params\">(struct Student \\*in)</span></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"My id is %d.\\n\"</span>,in-&gt;id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">one</span>;</span></span><br><span class=\"line\">one.id=<span class=\"number\">999</span>;</span><br><span class=\"line\">one.printID=printID;</span><br><span class=\"line\">one.printID(&amp;one);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"不一样的体验，用纯文本命令行写-C-程序\"><a href=\"#不一样的体验，用纯文本命令行写-C-程序\" class=\"headerlink\" title=\"不一样的体验，用纯文本命令行写 C++程序\"></a>不一样的体验，用纯文本命令行写 C++程序</h1><p>打开 vmware 运行 ubuntu<br>桌面右键打开终端<br>输入命令 ls 查看当前所在位置<br>输入命令 cd 桌面进入桌面这个文件夹<br>输入命令 touch test.cpp 创建 test.cpp 文件<br>打开 test.cpp 文件，输入以下代码并保存在这里插入图片描述<br>在这里插入图片描述<br>输入命令 g++ test.cpp 编译 test.cpp 文件，我们发现桌面上产生了一个新的文件 a.out，这就是编译产生的可执行文件，接下来我们运行之<br>输入命令./a.out 运行，发现如下输出：在这里插入图片描述<br>在这里插入图片描述</p>\n<h1 id=\"c-的新特性\"><a href=\"#c-的新特性\" class=\"headerlink\" title=\"c++的新特性\"></a>c++的新特性</h1><p>类（class)<br>之前说过了</p>\n<p>bool 类型和 auto 类型<br>bool，c 语言中，真假用整形来代替，0 –&gt;False &amp;&amp; !0–&gt;True &amp;&amp; True–&gt; &amp;&amp; False–&gt;0</p>\n<p>c++中，可以 true，false，也可以用 0 和 1</p>\n<p>auto，让编译器推断是什么类型，但必须在初始化时赋值，否则编译报错</p>\n<p>cout，在打印浮点数是会省略后面的部分</p>\n<p>引用<br>C<br>int a = 3; //定义了变量 a，并用 3 使其初始化，=不是运算符=含义是初始化<br>int b; //定义了变量 b，没有初始化<br>b = 3; //把 3 赋值给 b，=是运算符</p>\n<p>int array[10]={1,2,3}; //定义了数组 array，并用{1,2,3}使其初始化<br>array={1,2,3}; //错误<br>array[10]={1,2,3}; //错误<br>C<br>int *p; // *的含义是 p 是一个指针，不是取值运算符，p 是指向 int 类型的指针<br>int a = 3;<br>p = &a;<br>*p = 6; // *的是取值运算符<br>C<br>int b = 6;<br>int &amp;r = b; // &amp;的含义是 r 是一个引用类型，不是取地址运算符，r 是 int 类型的引用，=表示用 b 来初始化 r，让 r 成为 b 的引用，不是赋值，可以理解为给 b 起个外号，自此之后 r 就是 b，b 就是 r<br>r = 123;<br>cout &lt;&lt; r &lt;&lt; endl; // 123<br>cout &lt;&lt; b &lt;&lt; endl; // 123<br>在 C++中函数的参数传递：</p>\n<p>按值传递(pass by value)<br>地址传递(pass by pointer)<br>引用传递(pass by reference)<br>引用必须在定义时初始化，一旦创建就不可更换引用的对象</p>\n<p>C<br>int b = 6;<br>int &r; //error: ‘r’ declared as reference but not initialized<br>r = b; //把 b 的值赋值给 r，但此时 r 并没有任何的引用<br>关于赋值<br>C<br>int a, b, c;<br>(a = b = c = 3) = 666;<br>cout &lt;&lt; a &lt;&lt; endl; //666<br>cout &lt;&lt; b &lt;&lt; endl; //3<br>cout &lt;&lt; c &lt;&lt; endl; //3<br>赋值之后返回的是左值的引用</p>\n<p>初始化的新语法</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a&#123;<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[<span class=\"number\">5</span>]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">new</span> 和 <span class=\"keyword\">delete</span></span><br></pre></td></tr></table></figure>\n\n<p>int _p;<br>p = (int _) malloc(sizeof(int));<br>free(p);<br>p = new int;<br>delete p;<br>deleete[] p; //复杂类型应该这样写</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"iostream\"</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"keyword\">int</span> sid;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">Student one, two;</span><br><span class=\"line\">one.sid = <span class=\"number\">1</span>;</span><br><span class=\"line\">two.sid = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; &amp;one &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; &amp;two &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">one = two;</span><br><span class=\"line\">two.sid = <span class=\"number\">999</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; &amp;one &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; &amp;two &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"iostream\"</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"keyword\">int</span> sid;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">Student *one = <span class=\"keyword\">new</span> Student();</span><br><span class=\"line\">Student *two = <span class=\"keyword\">new</span> Student();</span><br><span class=\"line\"><span class=\"comment\">// Student *one, *two;</span></span><br><span class=\"line\"><span class=\"comment\">// one = new Student();</span></span><br><span class=\"line\"><span class=\"comment\">// two = new Student();</span></span><br><span class=\"line\">one-&gt;sid = <span class=\"number\">1</span>;</span><br><span class=\"line\">two-&gt;sid = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; &amp;one &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//0x63fde8</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; &amp;two &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//0x63fde0</span></span><br><span class=\"line\">one = two; <span class=\"comment\">//内存泄漏</span></span><br><span class=\"line\">two-&gt;sid = <span class=\"number\">999</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; one &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//0x1c1770</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; two &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//0x1c1770</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>进一步理解 Java 的引用，相当于 c++中的指针，java 的引用和 c++的引用是不一样的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> sid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">Student one = <span class=\"keyword\">new</span> Student(); <span class=\"comment\">//创建对象一定需要 new</span></span><br><span class=\"line\">Student two = <span class=\"keyword\">new</span> Student();</span><br><span class=\"line\"> one.sid = <span class=\"number\">1</span>;</span><br><span class=\"line\">two.sid = <span class=\"number\">2</span>;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"one: \"</span> + one); <span class=\"comment\">//one: Student@7291c18f</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"two: \"</span> + two); <span class=\"comment\">//two: Student@34a245ab</span></span><br><span class=\"line\">one = two;</span><br><span class=\"line\">two.sid = <span class=\"number\">999</span>;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"one: \"</span> + one); <span class=\"comment\">//one: Student@34a245ab</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"two: \"</span> + two); <span class=\"comment\">//two: Student@34a245ab</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新的 for 循环<br>for-each 不再赘述，可以使用 auto，each 是取出来的容器里的值，&amp;each 可以修改容器里本来的值</p>\n<p>在这里插入图片描述<br>在这里插入图片描述</p>\n<p>在这里插入图片描述<br>在这里插入图片描述</p>\n<p>重载<br>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p>\n<p>在同一个作用域内，可以声明几个同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。不能仅通过返回类型的不同来重载函数。</p>\n<p>我们可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p>\n<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>\n<p>注：在一个函数声明中，const 可以修饰形参表明他是一个输入参数，在函数内部不可以改变其值；</p>\n<p>lambda</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> f = [](<span class=\"keyword\">auto</span> a, <span class=\"keyword\">auto</span> b) -&gt; <span class=\"keyword\">auto</span> &#123; <span class=\"keyword\">return</span> a + b; &#125;;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; f(<span class=\"number\">3.1</span>, <span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 8.1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"泛型和模板\"><a href=\"#泛型和模板\" class=\"headerlink\" title=\"泛型和模板\"></a>泛型和模板</h1><p>泛型是概念, 模板是泛型的实现<br>泛型编程让你编写完全一般化并可重复使用的算法，其效率与针对某特定数据类型而设计的算法相同。泛型编程的代表作品 STL 是一种高效、泛型、可交互操作的软件组件。所谓泛型(Genericity)，是指具有在多种数据类型上皆可操作的含意，与模板有些相似。STL 巨大，而且可以扩充，它包含很多计算机基本算法和数据结构，而且将算法与数据结构完全分离，其中算法是泛型的，不与任何特定数据结构或对象类型系在一起。STL 以迭代器(Iterators)和容器(Containers)为基础，是一种泛型算法(Generic Algorithms)库，容器的存在使这些算法有东西可以操作。STL 包含各种泛型算法(algorithms)、泛型指针(iterators)、泛型容器(containers)以及函数对象(function objects)。STL 并非只是一些有用组件的集合，它是描述软件组件抽象需求条件的一个正规而有条理的架构。</p>\n<h1 id=\"C-语言-运算符和-amp-运算符\"><a href=\"#C-语言-运算符和-amp-运算符\" class=\"headerlink\" title=\"C 语言*运算符和&amp;运算符\"></a>C 语言*运算符和&amp;运算符</h1><p>取址运算符&amp;用来取得其操作数的地址。如果操作数 x 的类型为 T，则表达式 &amp;x 的类型是 T 类型指针（指向 T 的指针）。</p>\n<p>取址运算符的操作数必须是在内存中可寻址到的地址。换句话说，该运算符只能用于函数或对象（例如左值），而不可以用于位字段，以及那些还未被存储类修饰符 register 声明的内容。</p>\n<p>当需要初始化指针，以指向某些对象或函数时，需要获得这些对象或函数的地址：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> x, _ptr;ptr = &amp;x; <span class=\"comment\">// 合法：使得指针 ptr 指向 xptr = &amp;(x+1); // 错误： (x+1) 不是一个左值</span></span><br></pre></td></tr></table></figure>\n\n<p>相反地，当已具有一个指针，并且希望获取它所引用的对象时，使用间接运算符 _（indirection operator），有时候这会被称为解引用运算符（dereferencing operator）。它的操作数必须是指针类型。如果 ptr 是指针，那么 <em>ptr 就是 ptr 所指向的对象或函数。如果 ptr 是一个对象指针，那么 *ptr 就是一个左值，可以把它（即 \\</em>ptr）当作赋值运算符左边的操作数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> x, *ptr = &amp;x;*ptr = <span class=\"number\">1.7</span>; <span class=\"comment\">// 将 1.7 赋值给变量 x++(\\*ptr); // 并将变量 x 的值加 1</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个示例最后的语句中，ptr 的值保持不变，但 x 的值变成 2.7。</p>\n<p>如果指针操作数的值不是某个对象或函数的地址，则间接运算符*的操作结果无法确定。</p>\n<p>像其他一元操作数一样，运算符 &amp; 和 * 具有很高的优先级。操作数的组合方式是从右到左。因此，表达式 ++（*ptr）中的括号是没有必要的。</p>\n<p>运算符 &amp; 和 * 是互补的：如果 x 是一个表达式，用于指定一个对象或一个函数，那么表达式 &amp;x 就等于 x。相反地，在形如 &amp;ptr 的表达式中，这些运算符会互相抵消，表达式的类型与值等效于 ptr。然而，不管 ptr 是不是左值，&amp;*ptr 都一定不会是左值。</p>\n<h1 id=\"理解封装\"><a href=\"#理解封装\" class=\"headerlink\" title=\"理解封装\"></a>理解封装</h1><p>类里有什么<br>数据（属性）<br>操作（函数、方法）<br>访问控制（公有/私有）<br>静态/非静态<br>直接使用类：静态<br>使用对象：静态和非静态<br>静态不能访问非静态</p>\n<h1 id=\"使用类和对象\"><a href=\"#使用类和对象\" class=\"headerlink\" title=\"使用类和对象\"></a>使用类和对象</h1><p>定义类和对象</p>\n<h1 id=\"代码复用\"><a href=\"#代码复用\" class=\"headerlink\" title=\"代码复用\"></a>代码复用</h1><p>代码复用的手段<br>函数重载<br>类的继承，动态<br>借口</p>\n<h1 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h1><p>构造函数使用初始化列表来初始化字段</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Line::Line( <span class=\"keyword\">double</span> len): length(len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Object is being created, length = \"</span> &lt;&lt; len &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的语法等同于如下语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Line::Line( <span class=\"keyword\">double</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">length = len;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Object is being created, length = \"</span> &lt;&lt; len &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在不同的字段使用逗号进行分隔，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">C::C( <span class=\"keyword\">double</span> a, <span class=\"keyword\">double</span> b, <span class=\"keyword\">double</span> c): X(a), Y(b), Z(c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"模板（Template）\"><a href=\"#模板（Template）\" class=\"headerlink\" title=\"模板（Template）\"></a>模板（Template）</h1><p>函数模板</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Zhenglin Li on 2020/9/23.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"iostream\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">sum</span><span class=\"params\">(T <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">T s = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">s += <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a1[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">double</span> a2[<span class=\"number\">3</span>] = &#123;<span class=\"number\">1.1</span>, <span class=\"number\">2.2</span>, <span class=\"number\">3.3</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; sum(a1, <span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; sum(a2, <span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; sum(a2, <span class=\"number\">1</span>, <span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数模板的重载</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Zhenglin Li on 2020/9/23.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"iostream\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">sum</span><span class=\"params\">(T <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">T s = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">s += <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">sum</span><span class=\"params\">(T <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> from, <span class=\"keyword\">int</span> to)</span> </span>&#123;</span><br><span class=\"line\">T s = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = from - <span class=\"number\">1</span>; i &lt;= to - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">s += <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a1[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">double</span> a2[<span class=\"number\">3</span>] = &#123;<span class=\"number\">1.1</span>, <span class=\"number\">2.2</span>, <span class=\"number\">3.3</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; sum(a1, <span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; sum(a2, <span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; sum(a2, <span class=\"number\">1</span>, <span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类模板</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by Zhenglin Li on 2020/9/23.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"iostream\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"comment\">//模板</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">T x;</span><br><span class=\"line\">T y;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">Vector(T x = <span class=\"number\">0</span>, T y = <span class=\"number\">0</span>) : x(x), y(y) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;o, <span class=\"keyword\">const</span> Vector&lt;T&gt; &amp;v) &#123;</span><br><span class=\"line\">        o &lt;&lt; <span class=\"string\">\"&lt;\"</span> &lt;&lt; v.x &lt;&lt; <span class=\"string\">\", \"</span> &lt;&lt; v.y &lt;&lt; <span class=\"string\">\"&gt;\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//真正的类，要&lt;&gt;</span></span><br><span class=\"line\"><span class=\"function\">Vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">x</span><span class=\"params\">(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">Vector&lt;<span class=\"keyword\">double</span>&gt; *p = <span class=\"keyword\">new</span> Vector&lt;<span class=\"keyword\">double</span>&gt;(<span class=\"number\">1.1</span>,<span class=\"number\">2.2</span>);</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; *p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>标准模板库（STL）<br>Standard Template Library<br>很多容器<br>很多算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"A first look at C++ (2)","url":"/2023/01/18/A%20first%20look%20at%20C++%20(2)/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>C++核心编程<br>本阶段主要针对 C++==面向对象==编程技术做详细讲解，探讨 C++中的核心和精髓。</p>\n<p>1 内存分区模型<br>C++程序在执行时，将内存大方向划分为 4 个区域</p>\n<p>代码区：存放函数体的二进制代码，由操作系统进行管理的<br>全局区：存放全局变量和静态变量以及常量<br>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等<br>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收<br>内存四区意义：</p>\n<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>\n<p>1.1 程序运行前<br>​ 在程序编译后，生成了 exe 可执行程序，未执行该程序前分为两个区域</p>\n<p>​ 代码区：</p>\n<p>​ 存放 CPU 执行的机器指令</p>\n<p>​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>\n<p>​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令</p>\n<p>​ 全局区：</p>\n<p>​ 全局变量和静态变量存放在此.</p>\n<p>​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>\n<p>​ ==该区域的数据在程序结束后由操作系统释放==.</p>\n<p>示例：</p>\n<p>C++<br>//全局变量<br>int g_a = 10;<br>int g_b = 10;</p>\n<p>//全局常量<br>const int c_g_a = 10;<br>const int c_g_b = 10;</p>\n<p>int main() {</p>\n<pre><code>//局部变量\nint a = 10;\nint b = 10;\n\n//打印地址\ncout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;\ncout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;\n\ncout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt;  (int)&amp;g_a &lt;&lt; endl;\ncout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt;  (int)&amp;g_b &lt;&lt; endl;\n\n//静态变量\nstatic int s_a = 10;\nstatic int s_b = 10;\n\ncout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;\ncout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;\n\ncout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;\n\ncout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;\ncout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;\n\nconst int c_l_a = 10;\nconst int c_l_b = 10;\ncout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;\ncout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>打印结果：</p>\n<p>1545017602518<br>1545017602518</p>\n<p>总结：</p>\n<p>C++中在程序运行前分为全局区和代码区<br>代码区特点是共享和只读<br>全局区中存放全局变量、静态变量、常量<br>常量区中存放 const 修饰的全局常量 和 字符串常量<br>1.2 程序运行后<br>​ 栈区：</p>\n<p>​ 由编译器自动分配释放, 存放函数的参数值,局部变量等</p>\n<p>​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>\n<p>示例：</p>\n<p>C++<br>int * func()<br>{<br>int a = 10;<br>return &a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>​ 堆区：</p>\n<p>​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>\n<p>​ 在 C++中主要利用 new 在堆区开辟内存</p>\n<p>示例：</p>\n<p>C++<br>int* func()<br>{<br>int* a = new int(10);<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>堆区数据由程序员管理开辟和释放</p>\n<p>堆区数据利用 new 关键字进行开辟内存</p>\n<p>1.3 new 操作符<br>​ C++中利用==new==操作符在堆区开辟数据</p>\n<p>​ 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p>\n<p>​ 语法：new 数据类型</p>\n<p>​ 利用 new 创建的数据，会返回该数据对应的类型的指针</p>\n<p>示例 1： 基本语法</p>\n<p>C++<br>int* func()<br>{<br>int* a = new int(10);<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\n//利用delete释放堆区数据\ndelete p;\n\n//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：开辟数组</p>\n<p>C++<br>//堆区开辟数组<br>int main() {</p>\n<pre><code>int* arr = new int[10];\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    arr[i] = i + 100;\n}\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    cout &lt;&lt; arr[i] &lt;&lt; endl;\n}\n//释放数组 delete 后加 []\ndelete[] arr;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2 引用<br>2.1 引用的基本使用<br>*作用： *给变量起别名</p>\n<p>语法： 数据类型 &amp;别名 = 原名</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int a = 10;\nint &amp;b = a;\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n\nb = 100;\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2.2 引用注意事项<br>引用必须初始化<br>引用在初始化后，不可以改变<br>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int a = 10;\nint b = 20;\n//int &amp;c; //错误，引用必须初始化\nint &amp;c = a; //一旦初始化后，就不可以更改\nc = b; //这是赋值操作，不是更改引用\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\ncout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2.3 引用做函数参数<br>作用：函数传参时，可以利用引用的技术让形参修饰实参</p>\n<p>优点：可以简化指针修改实参</p>\n<p>示例：</p>\n<p>C++<br>//1. 值传递<br>void mySwap01(int a, int b) {<br>int temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>//2. 地址传递<br>void mySwap02(int* a, int* b) {<br>int temp = *a;<br>*a = *b;<br>*b = temp;<br>}</p>\n<p>//3. 引用传递<br>void mySwap03(int&amp; a, int&amp; b) {<br>int temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>int main() {</p>\n<pre><code>int a = 10;\nint b = 20;\n\nmySwap01(a, b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nmySwap02(&amp;a, &amp;b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nmySwap03(a, b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>\n<p>2.4 引用做函数返回值<br>作用：引用是可以作为函数的返回值存在的</p>\n<p>注意：不要返回局部变量引用</p>\n<p>用法：函数调用作为左值</p>\n<p>示例：</p>\n<p>C++<br>//返回局部变量引用<br>int&amp; test01() {<br>int a = 10; //局部变量<br>return a;<br>}</p>\n<p>//返回静态变量引用<br>int&amp; test02() {<br>static int a = 20;<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>//不能返回局部变量的引用\nint&amp; ref = test01();\ncout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\ncout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\n\n//如果函数做左值，那么必须返回引用\nint&amp; ref2 = test02();\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\ntest02() = 1000;\n\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>​</p>\n<p>2.5 引用的本质<br>本质：引用的本质在 c++内部实现是一个指针常量.</p>\n<p>讲解示例：</p>\n<p>C++<br>//发现是引用，转换为 int* const ref = &a;<br>void func(int&amp; ref){<br>ref = 100; // ref 是引用，转换为*ref = 100<br>}<br>int main(){<br>int a = 10;</p>\n<pre><code>//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改\nint&amp; ref = a;\nref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\n\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;\n\nfunc(a);\nreturn 0;</code></pre><p>}<br>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>\n<p>2.6 常量引用<br>作用：常量引用主要用来修饰形参，防止误操作</p>\n<p>在函数形参列表中，可以加==const 修饰形参==，防止形参改变实参</p>\n<p>示例：</p>\n<p>C++<br>//引用使用的场景，通常用来修饰形参<br>void showValue(const int&amp; v) {<br>//v += 10;<br>cout &lt;&lt; v &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误\n//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;\nconst int&amp; ref = 10;\n\n//ref = 100;  //加入const后不可以修改变量\ncout &lt;&lt; ref &lt;&lt; endl;\n\n//函数中利用常量引用防止误操作修改实参\nint a = 10;\nshowValue(a);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3 函数提高<br>3.1 函数默认参数<br>在 C++中，函数的形参列表中的形参是可以有默认值的。</p>\n<p>语法：返回值类型 函数名 （参数= 默认值）{}</p>\n<p>示例：</p>\n<p>C++<br>int func(int a, int b = 10, int c = 10) {<br>return a + b + c;<br>}</p>\n<p>//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值<br>//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数<br>int func2(int a = 10, int b = 10);<br>int func2(int a, int b) {<br>return a + b;<br>}</p>\n<p>int main() {</p>\n<pre><code>cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;\ncout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.2 函数占位参数<br>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>\n<p>语法： 返回值类型 函数名 (数据类型){}</p>\n<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>\n<p>示例：</p>\n<p>C++<br>//函数占位参数 ，占位参数也可以有默认参数<br>void func(int a, int) {<br>cout &lt;&lt; “this is func” &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>func(10,10); //占位参数必须填补\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.3 函数重载<br>3.3.1 函数重载概述<br>作用：函数名可以相同，提高复用性</p>\n<p>函数重载满足条件：</p>\n<p>同一个作用域下<br>函数名称相同<br>函数参数类型不同 或者 个数不同 或者 顺序不同<br>注意: 函数的返回值不可以作为函数重载的条件</p>\n<p>示例：</p>\n<p>C++<br>//函数重载需要函数都在同一个作用域下<br>void func()<br>{<br>cout &lt;&lt; “func 的调用！” &lt;&lt; endl;<br>}<br>void func(int a)<br>{<br>cout &lt;&lt; “func (int a) 的调用！” &lt;&lt; endl;<br>}<br>void func(double a)<br>{<br>cout &lt;&lt; “func (double a)的调用！” &lt;&lt; endl;<br>}<br>void func(int a ,double b)<br>{<br>cout &lt;&lt; “func (int a ,double b) 的调用！” &lt;&lt; endl;<br>}<br>void func(double a ,int b)<br>{<br>cout &lt;&lt; “func (double a ,int b)的调用！” &lt;&lt; endl;<br>}</p>\n<p>//函数返回值不可以作为函数重载条件<br>//int func(double a, int b)<br>//{<br>// cout &lt;&lt; “func (double a ,int b)的调用！” &lt;&lt; endl;<br>//}</p>\n<p>int main() {</p>\n<pre><code>func();\nfunc(10);\nfunc(3.14);\nfunc(10,3.14);\nfunc(3.14 , 10);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.3.2 函数重载注意事项<br>引用作为重载条件<br>函数重载碰到函数默认参数<br>示例：</p>\n<p>C++<br>//函数重载注意事项<br>//1、引用作为重载条件</p>\n<p>void func(int &amp;a)<br>{<br>cout &lt;&lt; “func (int &amp;a) 调用 “ &lt;&lt; endl;<br>}</p>\n<p>void func(const int &amp;a)<br>{<br>cout &lt;&lt; “func (const int &amp;a) 调用 “ &lt;&lt; endl;<br>}</p>\n<p>//2、函数重载碰到函数默认参数</p>\n<p>void func2(int a, int b = 10)<br>{<br>cout &lt;&lt; “func2(int a, int b = 10) 调用” &lt;&lt; endl;<br>}</p>\n<p>void func2(int a)<br>{<br>cout &lt;&lt; “func2(int a) 调用” &lt;&lt; endl;<br>}</p>\n<p>int main() {<br>int a = 10;<br>func(a); //调用无 const<br>func(10);//调用有 const</p>\n<pre><code>//func2(10); //碰到默认参数产生歧义，需要避免\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4 类和对象<br>C++面向对象的三大特性为：==封装、继承、多态==</p>\n<p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p>\n<p>例如：</p>\n<p>​ 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>\n<p>​ 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>\n<p>​ 具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p>\n<p>4.1 封装<br>4.1.1 封装的意义<br>封装是 C++面向对象三大特性之一</p>\n<p>封装的意义：</p>\n<p>将属性和行为作为一个整体，表现生活中的事物<br>将属性和行为加以权限控制<br>封装意义一：</p>\n<p>​ 在设计类的时候，属性和行为写在一起，表现事物</p>\n<p>语法： class 类名{ 访问权限： 属性 / 行为 };</p>\n<p>示例 1：设计一个圆类，求圆的周长</p>\n<p>示例代码：</p>\n<p>C++<br>//圆周率<br>const double PI = 3.14;</p>\n<p>//1、封装的意义<br>//将属性和行为作为一个整体，用来表现生活中的事物</p>\n<p>//封装一个圆类，求圆的周长<br>//class 代表设计一个类，后面跟着的是类名<br>class Circle<br>{<br>public: //访问权限 公共的权限</p>\n<pre><code>//属性\nint m_r;//半径\n\n//行为\n//获取到圆的周长\ndouble calculateZC()\n{\n    //2 * pi  * r\n    //获取圆的周长\n    return  2 * PI * m_r;\n}</code></pre><p>};</p>\n<p>int main() {</p>\n<pre><code>//通过圆类，创建圆的对象\n// c1就是一个具体的圆\nCircle c1;\nc1.m_r = 10; //给圆对象的半径 进行赋值操作\n\n//2 * pi * 10 = = 62.8\ncout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>\n<p>示例 2 代码：</p>\n<p>C++<br>//学生类<br>class Student {<br>public:<br>void setName(string name) {<br>m_name = name;<br>}<br>void setID(int id) {<br>m_id = id;<br>}</p>\n<pre><code>void showStudent() {\n    cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;\n}</code></pre><p>public:<br>string m_name;<br>int m_id;<br>};</p>\n<p>int main() {</p>\n<pre><code>Student stu;\nstu.setName(&quot;德玛西亚&quot;);\nstu.setID(250);\nstu.showStudent();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>封装意义二：</p>\n<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>\n<p>访问权限有三种：</p>\n<p>public 公共权限<br>protected 保护权限<br>private 私有权限<br>示例：</p>\n<p>C++<br>//三种权限<br>//公共权限 public 类内可以访问 类外可以访问<br>//保护权限 protected 类内可以访问 类外不可以访问<br>//私有权限 private 类内可以访问 类外不可以访问</p>\n<p>class Person<br>{<br>//姓名 公共权限<br>public:<br>string m_Name;</p>\n<pre><code>//汽车  保护权限</code></pre><p>protected:<br>string m_Car;</p>\n<pre><code>//银行卡密码  私有权限</code></pre><p>private:<br>int m_Password;</p>\n<p>public:<br>void func()<br>{<br>m_Name = “张三”;<br>m_Car = “拖拉机”;<br>m_Password = 123456;<br>}<br>};</p>\n<p>int main() {</p>\n<pre><code>Person p;\np.m_Name = &quot;李四&quot;;\n//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到\n//p.m_Password = 123; //私有权限类外访问不到\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.1.2 struct 和 class 区别<br>在 C++中 struct 和 class 唯一的区别就在于 默认的访问权限不同</p>\n<p>区别：</p>\n<p>struct 默认权限为公共<br>class 默认权限为私有<br>C++<br>class C1<br>{<br>int m_A; //默认是私有权限<br>};</p>\n<p>struct C2<br>{<br>int m_A; //默认是公共权限<br>};</p>\n<p>int main() {</p>\n<pre><code>C1 c1;\nc1.m_A = 10; //错误，访问权限是私有\n\nC2 c2;\nc2.m_A = 10; //正确，访问权限是公共\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.1.3 成员属性设置为私有<br>优点 1：将所有成员属性设置为私有，可以自己控制读写权限</p>\n<p>优点 2：对于写权限，我们可以检测数据的有效性</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:</p>\n<pre><code>//姓名设置可读可写\nvoid setName(string name) {\n    m_Name = name;\n}\nstring getName()\n{\n    return m_Name;\n}\n\n\n//获取年龄\nint getAge() {\n    return m_Age;\n}\n//设置年龄\nvoid setAge(int age) {\n    if (age &lt; 0 || age &gt; 150) {\n        cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;\n        return;\n    }\n    m_Age = age;\n}\n\n//情人设置为只写\nvoid setLover(string lover) {\n    m_Lover = lover;\n}</code></pre><p>private:<br>string m_Name; //可读可写 姓名<br>int m_Age; //只读 年龄</p>\n<pre><code>string m_Lover; //只写  情人</code></pre><p>};</p>\n<p>int main() {</p>\n<pre><code>Person p;\n//姓名设置\np.setName(&quot;张三&quot;);\ncout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;\n\n//年龄设置\np.setAge(50);\ncout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;\n\n//情人设置\np.setLover(&quot;苍井&quot;);\n//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>练习案例 1：设计立方体类</p>\n<p>设计立方体类(Cube)</p>\n<p>求出立方体的面积和体积</p>\n<p>分别用全局函数和成员函数判断两个立方体是否相等。</p>\n<p>1545533548532<br>1545533548532</p>\n<p>练习案例 2：点和圆的关系</p>\n<p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p>\n<p>1545533829184<br>1545533829184</p>\n<p>4.2 对象的初始化和清理<br>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全<br>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。<br>4.2.1 构造函数和析构函数<br>对象的初始化和清理也是两个非常重要的安全问题</p>\n<p>​ 一个对象或者变量没有初始状态，对其使用后果是未知</p>\n<p>​ 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>\n<p>c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>\n<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供</p>\n<p>编译器提供的构造函数和析构函数是空实现。</p>\n<p>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。<br>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。<br>构造函数语法：类名(){}</p>\n<p>构造函数，没有返回值也不写 void<br>函数名称与类名相同<br>构造函数可以有参数，因此可以发生重载<br>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次<br>析构函数语法： ~类名(){}</p>\n<p>析构函数，没有返回值也不写 void<br>函数名称与类名相同,在名称前加上符号 ~<br>析构函数不可以有参数，因此不可以发生重载<br>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次<br>C++<br>class Person<br>{<br>public:<br>//构造函数<br>Person()<br>{<br>cout &lt;&lt; “Person 的构造函数调用” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person()<br>{<br>cout &lt;&lt; “Person 的析构函数调用” &lt;&lt; endl;<br>}</p>\n<p>};</p>\n<p>void test01()<br>{<br>Person p;<br>}</p>\n<p>int main() {<br>test01();</p>\n<pre><code>system(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.2 构造函数的分类及调用<br>两种分类方式：</p>\n<p>​ 按参数分为： 有参构造和无参构造</p>\n<p>​ 按类型分为： 普通构造和拷贝构造</p>\n<p>三种调用方式：</p>\n<p>​ 括号法</p>\n<p>​ 显示法</p>\n<p>​ 隐式转换法</p>\n<p>示例：</p>\n<p>C++<br>//1、构造函数分类<br>// 按照参数分类分为 有参和无参构造 无参又称为默认构造函数<br>// 按照类型分类分为 普通构造和拷贝构造</p>\n<p>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int a) {<br>age = a;<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>}<br>//拷贝构造函数<br>Person(const Person&amp; p) {<br>age = p.age;<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int age;<br>};</p>\n<p>//2、构造函数的调用<br>//调用无参构造函数<br>void test01() {<br>Person p; //调用无参构造函数<br>}</p>\n<p>//调用有参的构造函数<br>void test02() {</p>\n<pre><code>//2.1  括号法，常用\nPerson p1(10);\n//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n//Person p2();\n\n//2.2 显式法\nPerson p2 = Person(10);\nPerson p3 = Person(p2);\n//Person(10)单独写就是匿名对象  当前行结束之后，马上析构\n\n//2.3 隐式转换法\nPerson p4 = 10; // Person p4 = Person(10);\nPerson p5 = p4; // Person p5 = Person(p4);\n\n//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\n//Person p5(p4);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n//test02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.3 拷贝构造函数调用时机<br>C++中拷贝构造函数调用时机通常有三种情况</p>\n<p>使用一个已经创建完毕的对象来初始化一个新对象<br>值传递的方式给函数参数传值<br>以值方式返回局部对象<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>mAge = 0;<br>}<br>Person(int age) {<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>mAge = age;<br>}<br>Person(const Person&amp; p) {<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>mAge = p.mAge;<br>}<br>//析构函数在释放内存之前调用<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int mAge;<br>};</p>\n<p>//1. 使用一个已经创建完毕的对象来初始化一个新对象<br>void test01() {</p>\n<pre><code>Person man(100); //p对象已经创建完毕\nPerson newman(man); //调用拷贝构造函数\nPerson newman2 = man; //拷贝构造\n\n//Person newman3;\n//newman3 = man; //不是调用拷贝构造函数，赋值操作</code></pre><p>}</p>\n<p>//2. 值传递的方式给函数参数传值<br>//相当于 Person p1 = p;<br>void doWork(Person p1) {}<br>void test02() {<br>Person p; //无参构造函数<br>doWork(p);<br>}</p>\n<p>//3. 以值方式返回局部对象<br>Person doWork2()<br>{<br>Person p1;<br>cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;<br>return p1;<br>}</p>\n<p>void test03()<br>{<br>Person p = doWork2();<br>cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n//test02();\ntest03();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.4 构造函数调用规则<br>默认情况下，c++编译器至少给一个类添加 3 个函数</p>\n<p>1．默认构造函数(无参，函数体为空)</p>\n<p>2．默认析构函数(无参，函数体为空)</p>\n<p>3．默认拷贝构造函数，对属性进行值拷贝</p>\n<p>构造函数调用规则如下：</p>\n<p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造<br>如果用户定义拷贝构造函数，c++不会再提供其他构造函数<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int a) {<br>age = a;<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>}<br>//拷贝构造函数<br>Person(const Person&amp; p) {<br>age = p.age;<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int age;<br>};</p>\n<p>void test01()<br>{<br>Person p1(18);<br>//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作<br>Person p2(p1);</p>\n<pre><code>cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;</code></pre><p>}</p>\n<p>void test02()<br>{<br>//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造<br>Person p1; //此时如果用户自己没有提供默认构造，会出错<br>Person p2(10); //用户提供的有参<br>Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供</p>\n<pre><code>//如果用户提供拷贝构造，编译器不会提供其他构造函数\nPerson p4; //此时如果用户自己没有提供默认构造，会出错\nPerson p5(10); //此时如果用户自己没有提供有参，会出错\nPerson p6(p5); //用户自己提供拷贝构造</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.5 深拷贝与浅拷贝<br>深浅拷贝是面试经典问题，也是常见的一个坑</p>\n<p>浅拷贝：简单的赋值拷贝操作</p>\n<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int age ,int height) {<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;</p>\n<pre><code>    m_age = age;\n    m_height = new int(height);\n\n}\n//拷贝构造函数\nPerson(const Person&amp; p) {\n    cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n    //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题\n    m_age = p.m_age;\n    m_height = new int(*p.m_height);\n\n}\n\n//析构函数\n~Person() {\n    cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n    if (m_height != NULL)\n    {\n        delete m_height;\n    }\n}</code></pre><p>public:<br>int m_age;<br>int* m_height;<br>};</p>\n<p>void test01()<br>{<br>Person p1(18, 180);</p>\n<pre><code>Person p2(p1);\n\ncout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>\n<p>4.2.6 初始化列表<br>作用：</p>\n<p>C++提供了初始化列表语法，用来初始化属性</p>\n<p>语法：构造函数()：属性 1(值 1),属性 2（值 2）… {}</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:</p>\n<pre><code>////传统方式初始化\n//Person(int a, int b, int c) {\n//    m_A = a;\n//    m_B = b;\n//    m_C = c;\n//}\n\n//初始化列表方式初始化\nPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}\nvoid PrintPerson() {\n    cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;\n    cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;\n    cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;\n}</code></pre><p>private:<br>int m_A;<br>int m_B;<br>int m_C;<br>};</p>\n<p>int main() {</p>\n<pre><code>Person p(1, 2, 3);\np.PrintPerson();\n\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.7 类对象作为类成员<br>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>\n<p>例如：</p>\n<p>C++<br>class A {}<br>class B<br>{<br>A a；<br>}<br>B 类中有对象 A 作为成员，A 为对象成员</p>\n<p>那么当创建 B 对象时，A 与 B 的构造和析构的顺序是谁先谁后？</p>\n<p>示例：</p>\n<p>C++<br>class Phone<br>{<br>public:<br>Phone(string name)<br>{<br>m_PhoneName = name;<br>cout &lt;&lt; “Phone 构造” &lt;&lt; endl;<br>}</p>\n<pre><code>~Phone()\n{\n    cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;\n}\n\nstring m_PhoneName;</code></pre><p>};</p>\n<p>class Person<br>{<br>public:</p>\n<pre><code>//初始化列表可以告诉编译器调用哪一个构造函数\nPerson(string name, string pName) :m_Name(name), m_Phone(pName)\n{\n    cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;\n}\n\n~Person()\n{\n    cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;\n}\n\nvoid playGame()\n{\n    cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;\n}\n\nstring m_Name;\nPhone m_Phone;</code></pre><p>};<br>void test01()<br>{<br>//当类中成员是其他类对象时，我们称该成员为 对象成员<br>//构造的顺序是 ：先调用对象成员的构造，再调用本类构造<br>//析构顺序与构造相反<br>Person p(“张三” , “苹果 X”);<br>p.playGame();</p>\n<p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.8 静态成员<br>静态成员就是在成员变量和成员函数前加上关键字 static，称为静态成员</p>\n<p>静态成员分为：</p>\n<p>静态成员变量<br>所有对象共享同一份数据<br>在编译阶段分配内存<br>类内声明，类外初始化<br>静态成员函数<br>所有对象共享同一个函数<br>静态成员函数只能访问静态成员变量<br>示例 1 ：静态成员变量</p>\n<p>C++<br>class Person<br>{<br>public:</p>\n<pre><code>static int m_A; //静态成员变量\n\n//静态成员变量特点：\n//1 在编译阶段分配内存\n//2 类内声明，类外初始化\n//3 所有对象共享同一份数据</code></pre><p>private:<br>static int m_B; //静态成员变量也是有访问权限的<br>};<br>int Person::m_A = 10;<br>int Person::m_B = 10;</p>\n<p>void test01()<br>{<br>//静态成员变量两种访问方式</p>\n<pre><code>//1、通过对象\nPerson p1;\np1.m_A = 100;\ncout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl;\n\nPerson p2;\np2.m_A = 200;\ncout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据\ncout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl;\n\n//2、通过类名\ncout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl;\n\n\n//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：静态成员函数</p>\n<p>C++<br>class Person<br>{</p>\n<p>public:</p>\n<pre><code>//静态成员函数特点：\n//1 程序共享一个函数\n//2 静态成员函数只能访问静态成员变量\n\nstatic void func()\n{\n    cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;\n    m_A = 100;\n    //m_B = 100; //错误，不可以访问非静态成员变量\n}\n\nstatic int m_A; //静态成员变量\nint m_B; //</code></pre><p>private:</p>\n<pre><code>//静态成员函数也是有访问权限的\nstatic void func2()\n{\n    cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;\n}</code></pre><p>};<br>int Person::m_A = 10;</p>\n<p>void test01()<br>{<br>//静态成员变量两种访问方式</p>\n<pre><code>//1、通过对象\nPerson p1;\np1.func();\n\n//2、通过类名\nPerson::func();\n\n\n//Person::func2(); //私有权限访问不到</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3 C++对象模型和 this 指针<br>4.3.1 成员变量和成员函数分开存储<br>在 C++中，类内的成员变量和成员函数分开存储</p>\n<p>只有非静态成员变量才属于类的对象上</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>mA = 0;<br>}<br>//非静态成员变量占对象空间<br>int mA;<br>//静态成员变量不占对象空间<br>static int mB;<br>//函数也不占对象空间，所有函数共享一个函数实例<br>void func() {<br>cout &lt;&lt; “mA:” &lt;&lt; this-&gt;mA &lt;&lt; endl;<br>}<br>//静态成员函数也不占对象空间<br>static void sfunc() {<br>}<br>};</p>\n<p>int main() {</p>\n<pre><code>cout &lt;&lt; sizeof(Person) &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.2 this 指针概念<br>通过 4.3.1 我们知道在 C++中成员变量和成员函数是分开存储的</p>\n<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>\n<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>\n<p>c++通过提供特殊的对象指针，this 指针，解决上述问题。this 指针指向被调用的成员函数所属的对象</p>\n<p>this 指针是隐含每一个非静态成员函数内的一种指针</p>\n<p>this 指针不需要定义，直接使用即可</p>\n<p>this 指针的用途：</p>\n<p>当形参和成员变量同名时，可用 this 指针来区分<br>在类的非静态成员函数中返回对象本身，可使用 return *this<br>C++<br>class Person<br>{<br>public:</p>\n<pre><code>Person(int age)\n{\n    //1、当形参和成员变量同名时，可用this指针来区分\n    this-&gt;age = age;\n}\n\nPerson&amp; PersonAddPerson(Person p)\n{\n    this-&gt;age += p.age;\n    //返回对象本身\n    return *this;\n}\n\nint age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>Person p1(10);<br>cout &lt;&lt; “p1.age = “ &lt;&lt; p1.age &lt;&lt; endl;</p>\n<pre><code>Person p2(10);\np2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\ncout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.3 空指针访问成员函数<br>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针</p>\n<p>如果用到 this 指针，需要加以判断保证代码的健壮性</p>\n<p>示例：</p>\n<p>C++<br>//空指针访问成员函数<br>class Person {<br>public:</p>\n<pre><code>void ShowClassName() {\n    cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;\n}\n\nvoid ShowPerson() {\n    if (this == NULL) {\n        return;\n    }\n    cout &lt;&lt; mAge &lt;&lt; endl;\n}</code></pre><p>public:<br>int mAge;<br>};</p>\n<p>void test01()<br>{<br>Person * p = NULL;<br>p-&gt;ShowClassName(); //空指针，可以调用成员函数<br>p-&gt;ShowPerson(); //但是如果成员函数中用到了 this 指针，就不可以了<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.4 const 修饰成员函数<br>常函数：</p>\n<p>成员函数后加 const 后我们称为这个函数为常函数<br>常函数内不可以修改成员属性<br>成员属性声明时加关键字 mutable 后，在常函数中依然可以修改<br>常对象：</p>\n<p>声明对象前加 const 称该对象为常对象<br>常对象只能调用常函数<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>m_A = 0;<br>m_B = 0;<br>}</p>\n<pre><code>//this指针的本质是一个指针常量，指针的指向不可修改\n//如果想让指针指向的值也不可以修改，需要声明常函数\nvoid ShowPerson() const {\n    //const Type* const pointer;\n    //this = NULL; //不能修改指针的指向 Person* const this;\n    //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的\n\n    //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量\n    this-&gt;m_B = 100;\n}\n\nvoid MyFunc() const {\n    //mA = 10000;\n}</code></pre><p>public:<br>int m_A;<br>mutable int m_B; //可修改 可变的<br>};</p>\n<p>//const 修饰对象 常对象<br>void test01() {</p>\n<pre><code>const Person person; //常量对象\ncout &lt;&lt; person.m_A &lt;&lt; endl;\n//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问\nperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量\n\n//常对象访问成员函数\nperson.MyFunc(); //常对象不能调用const的函数</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.4 友元<br>生活中你的家有客厅(Public)，有你的卧室(Private)</p>\n<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>\n<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>\n<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>\n<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>\n<p>友元的关键字为 ==friend==</p>\n<p>友元的三种实现</p>\n<p>全局函数做友元<br>类做友元<br>成员函数做友元<br>4.4.1 全局函数做友元<br>C++<br>class Building<br>{<br>//告诉编译器 goodGay 全局函数 是 Building 类的好朋友，可以访问类中的私有内容<br>friend void goodGay(Building * building);</p>\n<p>public:</p>\n<pre><code>Building()\n{\n    this-&gt;m_SittingRoom = &quot;客厅&quot;;\n    this-&gt;m_BedRoom = &quot;卧室&quot;;\n}</code></pre><p>public:<br>string m_SittingRoom; //客厅</p>\n<p>private:<br>string m_BedRoom; //卧室<br>};</p>\n<p>void goodGay(Building * building)<br>{<br>cout &lt;&lt; “好基友正在访问： “ &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问： “ &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>Building b;<br>goodGay(&amp;b);<br>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.4.2 类做友元<br>C++<br>class Building;<br>class goodGay<br>{<br>public:</p>\n<pre><code>goodGay();\nvoid visit();</code></pre><p>private:<br>Building *building;<br>};</p>\n<p>class Building<br>{<br>//告诉编译器 goodGay 类是 Building 类的好朋友，可以访问到 Building 类中私有内容<br>friend class goodGay;</p>\n<p>public:<br>Building();</p>\n<p>public:<br>string m_SittingRoom; //客厅<br>private:<br>string m_BedRoom;//卧室<br>};</p>\n<p>Building::Building()<br>{<br>this-&gt;m_SittingRoom = “客厅”;<br>this-&gt;m_BedRoom = “卧室”;<br>}</p>\n<p>goodGay::goodGay()<br>{<br>building = new Building;<br>}</p>\n<p>void goodGay::visit()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>goodGay gg;<br>gg.visit();</p>\n<p>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.4.3 成员函数做友元<br>C++</p>\n<p>class Building;<br>class goodGay<br>{<br>public:</p>\n<pre><code>goodGay();\nvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\nvoid visit2();</code></pre><p>private:<br>Building *building;<br>};</p>\n<p>class Building<br>{<br>//告诉编译器 goodGay 类中的 visit 成员函数 是 Building 好朋友，可以访问私有内容<br>friend void goodGay::visit();</p>\n<p>public:<br>Building();</p>\n<p>public:<br>string m_SittingRoom; //客厅<br>private:<br>string m_BedRoom;//卧室<br>};</p>\n<p>Building::Building()<br>{<br>this-&gt;m_SittingRoom = “客厅”;<br>this-&gt;m_BedRoom = “卧室”;<br>}</p>\n<p>goodGay::goodGay()<br>{<br>building = new Building;<br>}</p>\n<p>void goodGay::visit()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void goodGay::visit2()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>//cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>goodGay gg;<br>gg.visit();</p>\n<p>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.5 运算符重载<br>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>\n<p>4.5.1 加号运算符重载<br>作用：实现两个自定义数据类型相加的运算</p>\n<p>C++<br>class Person {<br>public:<br>Person() {};<br>Person(int a, int b)<br>{<br>this-&gt;m_A = a;<br>this-&gt;m_B = b;<br>}<br>//成员函数实现 + 号运算符重载<br>Person operator+(const Person&amp; p) {<br>Person temp;<br>temp.m_A = this-&gt;m_A + p.m_A;<br>temp.m_B = this-&gt;m_B + p.m_B;<br>return temp;<br>}</p>\n<p>public:<br>int m_A;<br>int m_B;<br>};</p>\n<p>//全局函数实现 + 号运算符重载<br>//Person operator+(const Person&amp; p1, const Person&amp; p2) {<br>// Person temp(0, 0);<br>// temp.m_A = p1.m_A + p2.m_A;<br>// temp.m_B = p1.m_B + p2.m_B;<br>// return temp;<br>//}</p>\n<p>//运算符重载 可以发生函数重载<br>Person operator+(const Person&amp; p2, int val)<br>{<br>Person temp;<br>temp.m_A = p2.m_A + val;<br>temp.m_B = p2.m_B + val;<br>return temp;<br>}</p>\n<p>void test() {</p>\n<pre><code>Person p1(10, 10);\nPerson p2(20, 20);\n\n//成员函数方式\nPerson p3 = p2 + p1;  //相当于 p2.operaor+(p1)\ncout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;\n\n\nPerson p4 = p3 + 10; //相当于 operator+(p3,10)\ncout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结 1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>\n<p>总结 2：不要滥用运算符重载</p>\n<p>4.5.2 左移运算符重载<br>作用：可以输出自定义数据类型</p>\n<p>C++<br>class Person {<br>friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);</p>\n<p>public:</p>\n<pre><code>Person(int a, int b)\n{\n    this-&gt;m_A = a;\n    this-&gt;m_B = b;\n}\n\n//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果\n//void operator&lt;&lt;(Person&amp; p){\n//}</code></pre><p>private:<br>int m_A;<br>int m_B;<br>};</p>\n<p>//全局函数实现左移重载<br>//ostream 对象只能有一个<br>ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) {<br>out &lt;&lt; “a:” &lt;&lt; p.m_A &lt;&lt; “ b:” &lt;&lt; p.m_B;<br>return out;<br>}</p>\n<p>void test() {</p>\n<pre><code>Person p1(10, 20);\n\ncout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>\n<p>4.5.3 递增运算符重载<br>作用： 通过重载递增运算符，实现自己的整型数据</p>\n<p>C++</p>\n<p>class MyInteger {</p>\n<pre><code>friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);</code></pre><p>public:<br>MyInteger() {<br>m_Num = 0;<br>}<br>//前置++<br>MyInteger&amp; operator++() {<br>//先++<br>m_Num++;<br>//再返回<br>return *this;<br>}</p>\n<pre><code>//后置++\nMyInteger operator++(int) {\n    //先返回\n    MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；\n    m_Num++;\n    return temp;\n}</code></pre><p>private:<br>int m_Num;<br>};</p>\n<p>ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) {<br>out &lt;&lt; myint.m_Num;<br>return out;<br>}</p>\n<p>//前置++ 先++ 再返回<br>void test01() {<br>MyInteger myInt;<br>cout &lt;&lt; ++myInt &lt;&lt; endl;<br>cout &lt;&lt; myInt &lt;&lt; endl;<br>}</p>\n<p>//后置++ 先返回 再++<br>void test02() {</p>\n<pre><code>MyInteger myInt;\ncout &lt;&lt; myInt++ &lt;&lt; endl;\ncout &lt;&lt; myInt &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n//test02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 前置递增返回引用，后置递增返回值</p>\n<p>4.5.4 赋值运算符重载<br>c++编译器至少给一个类添加 4 个函数</p>\n<p>默认构造函数(无参，函数体为空)<br>默认析构函数(无参，函数体为空)<br>默认拷贝构造函数，对属性进行值拷贝<br>赋值运算符 operator=, 对属性进行值拷贝<br>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>\n<p>示例：</p>\n<p>C++<br>class Person<br>{<br>public:</p>\n<pre><code>Person(int age)\n{\n    //将年龄数据开辟到堆区\n    m_Age = new int(age);\n}\n\n//重载赋值运算符\nPerson&amp; operator=(Person &amp;p)\n{\n    if (m_Age != NULL)\n    {\n        delete m_Age;\n        m_Age = NULL;\n    }\n    //编译器提供的代码是浅拷贝\n    //m_Age = p.m_Age;\n\n    //提供深拷贝 解决浅拷贝的问题\n    m_Age = new int(*p.m_Age);\n\n    //返回自身\n    return *this;\n}\n\n\n~Person()\n{\n    if (m_Age != NULL)\n    {\n        delete m_Age;\n        m_Age = NULL;\n    }\n}\n\n//年龄的指针\nint *m_Age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>Person p1(18);</p>\n<pre><code>Person p2(20);\n\nPerson p3(30);\n\np3 = p2 = p1; //赋值操作\n\ncout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\n//int a = 10;\n//int b = 20;\n//int c = 30;\n\n//c = b = a;\n//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\n//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.5.5 关系运算符重载<br>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p>\n<p>示例：</p>\n<p>C++<br>class Person<br>{<br>public:<br>Person(string name, int age)<br>{<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>};</p>\n<pre><code>bool operator==(Person &amp; p)\n{\n    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nbool operator!=(Person &amp; p)\n{\n    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}\n\nstring m_Name;\nint m_Age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>//int a = 0;<br>//int b = 0;</p>\n<pre><code>Person a(&quot;孙悟空&quot;, 18);\nPerson b(&quot;孙悟空&quot;, 18);\n\nif (a == b)\n{\n    cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n}\n\nif (a != b)\n{\n    cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.5.6 函数调用运算符重载<br>函数调用运算符 () 也可以重载<br>由于重载后使用的方式非常像函数的调用，因此称为仿函数<br>仿函数没有固定写法，非常灵活<br>示例：</p>\n<p>C++<br>class MyPrint<br>{<br>public:<br>void operator()(string text)<br>{<br>cout &lt;&lt; text &lt;&lt; endl;<br>}</p>\n<p>};<br>void test01()<br>{<br>//重载的（）操作符 也称为仿函数<br>MyPrint myFunc;<br>myFunc(“hello world”);<br>}</p>\n<p>class MyAdd<br>{<br>public:<br>int operator()(int v1, int v2)<br>{<br>return v1 + v2;<br>}<br>};</p>\n<p>void test02()<br>{<br>MyAdd add;<br>int ret = add(10, 10);<br>cout &lt;&lt; “ret = “ &lt;&lt; ret &lt;&lt; endl;</p>\n<pre><code>//匿名对象调用\ncout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.6 继承<br>继承是面向对象三大特性之一</p>\n<p>有些类与类之间存在特殊的关系，例如下图中：</p>\n<p>1544861202252<br>1544861202252</p>\n<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>\n<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>\n<p>4.6.1 继承的基本语法<br>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>\n<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>\n<p>普通实现：</p>\n<p>C++<br>//Java 页面<br>class Java<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “JAVA 学科视频” &lt;&lt; endl;<br>}<br>};<br>//Python 页面<br>class Python<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “Python 学科视频” &lt;&lt; endl;<br>}<br>};<br>//C++页面<br>class CPP<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “C++学科视频” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//Java 页面<br>cout &lt;&lt; “Java 下载视频页面如下： “ &lt;&lt; endl;<br>Java ja;<br>ja.header();<br>ja.footer();<br>ja.left();<br>ja.content();<br>cout &lt;&lt; “——————–” &lt;&lt; endl;</p>\n<pre><code>//Python页面\ncout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\nPython py;\npy.header();\npy.footer();\npy.left();\npy.content();\ncout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n//C++页面\ncout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\nCPP cp;\ncp.header();\ncp.footer();\ncp.left();\ncp.content();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>继承实现：</p>\n<p>C++<br>//公共页面<br>class BasePage<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}</p>\n<pre><code>void footer()\n{\n    cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\n}\nvoid left()\n{\n    cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\n}</code></pre><p>};</p>\n<p>//Java 页面<br>class Java : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “JAVA 学科视频” &lt;&lt; endl;<br>}<br>};<br>//Python 页面<br>class Python : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “Python 学科视频” &lt;&lt; endl;<br>}<br>};<br>//C++页面<br>class CPP : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “C++学科视频” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//Java 页面<br>cout &lt;&lt; “Java 下载视频页面如下： “ &lt;&lt; endl;<br>Java ja;<br>ja.header();<br>ja.footer();<br>ja.left();<br>ja.content();<br>cout &lt;&lt; “——————–” &lt;&lt; endl;</p>\n<pre><code>//Python页面\ncout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\nPython py;\npy.header();\npy.footer();\npy.left();\npy.content();\ncout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n//C++页面\ncout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\nCPP cp;\ncp.header();\ncp.footer();\ncp.left();\ncp.content();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>继承的好处：==可以减少重复的代码==</p>\n<p>class A : public B;</p>\n<p>A 类称为子类 或 派生类</p>\n<p>B 类称为父类 或 基类</p>\n<p>派生类中的成员，包含两大部分：</p>\n<p>一类是从基类继承过来的，一类是自己增加的成员。</p>\n<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>\n<p>4.6.2 继承方式<br>继承的语法：class 子类 : 继承方式 父类</p>\n<p>继承方式一共有三种：</p>\n<p>公共继承<br>保护继承<br>私有继承<br>img<br>img</p>\n<p>示例：</p>\n<p>C++<br>class Base1<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};</p>\n<p>//公共继承<br>class Son1 :public Base1<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 public 权限<br>m_B; //可访问 protected 权限<br>//m_C; //不可访问<br>}<br>};</p>\n<p>void myClass()<br>{<br>Son1 s1;<br>s1.m_A; //其他类只能访问到公共权限<br>}</p>\n<p>//保护继承<br>class Base2<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};<br>class Son2:protected Base2<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 protected 权限<br>m_B; //可访问 protected 权限<br>//m_C; //不可访问<br>}<br>};<br>void myClass2()<br>{<br>Son2 s;<br>//s.m_A; //不可访问<br>}</p>\n<p>//私有继承<br>class Base3<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};<br>class Son3:private Base3<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 private 权限<br>m_B; //可访问 private 权限<br>//m_C; //不可访问<br>}<br>};<br>class GrandSon3 :public Son3<br>{<br>public:<br>void func()<br>{<br>//Son3 是私有继承，所以继承 Son3 的属性在 GrandSon3 中都无法访问到<br>//m_A;<br>//m_B;<br>//m_C;<br>}<br>};<br>4.6.3 继承中的对象模型<br>问题：从父类继承过来的成员，哪些属于子类对象中？</p>\n<p>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C; //私有成员只是被隐藏了，但是还是会继承下去<br>};</p>\n<p>//公共继承<br>class Son :public Base<br>{<br>public:<br>int m_D;<br>};</p>\n<p>void test01()<br>{<br>cout &lt;&lt; “sizeof Son = “ &lt;&lt; sizeof(Son) &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>利用工具查看：</p>\n<p>1545881904150<br>1545881904150</p>\n<p>打开工具窗口后，定位到当前 CPP 文件的盘符</p>\n<p>然后输入： cl /d1 reportSingleClassLayout 查看的类名 所属文件名</p>\n<p>效果如下图：</p>\n<p>1545882158050<br>1545882158050</p>\n<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>\n<p>4.6.4 继承中构造和析构顺序<br>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>\n<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>\n<p>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>Base()<br>{<br>cout &lt;&lt; “Base 构造函数!” &lt;&lt; endl;<br>}<br>~Base()<br>{<br>cout &lt;&lt; “Base 析构函数!” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Son : public Base<br>{<br>public:<br>Son()<br>{<br>cout &lt;&lt; “Son 构造函数!” &lt;&lt; endl;<br>}<br>~Son()<br>{<br>cout &lt;&lt; “Son 析构函数!” &lt;&lt; endl;<br>}</p>\n<p>};</p>\n<p>void test01()<br>{<br>//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反<br>Son s;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>\n<p>4.6.5 继承同名成员处理方式<br>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>\n<p>访问子类同名成员 直接访问即可<br>访问父类同名成员 需要加作用域<br>示例：</p>\n<p>C++<br>class Base {<br>public:<br>Base()<br>{<br>m_A = 100;<br>}</p>\n<pre><code>void func()\n{\n    cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;\n}\n\nvoid func(int a)\n{\n    cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;\n}</code></pre><p>public:<br>int m_A;<br>};</p>\n<p>class Son : public Base {<br>public:<br>Son()<br>{<br>m_A = 200;<br>}</p>\n<pre><code>//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\n//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\nvoid func()\n{\n    cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;\n}</code></pre><p>public:<br>int m_A;<br>};</p>\n<p>void test01()<br>{<br>Son s;</p>\n<pre><code>cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;\ncout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\n\ns.func();\ns.Base::func();\ns.Base::func(10);</code></pre><p>}<br>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn EXIT_SUCCESS;</code></pre><p>}<br>总结：</p>\n<p>子类对象可以直接访问到子类中同名成员<br>子类对象加作用域可以访问到父类同名成员<br>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数<br>4.6.6 继承同名静态成员处理方式<br>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>\n<p>静态成员和非静态成员出现同名，处理方式一致</p>\n<p>访问子类同名成员 直接访问即可<br>访问父类同名成员 需要加作用域<br>示例：</p>\n<p>C++<br>class Base {<br>public:<br>static void func()<br>{<br>cout &lt;&lt; “Base - static void func()” &lt;&lt; endl;<br>}<br>static void func(int a)<br>{<br>cout &lt;&lt; “Base - static void func(int a)” &lt;&lt; endl;<br>}</p>\n<pre><code>static int m_A;</code></pre><p>};</p>\n<p>int Base::m_A = 100;</p>\n<p>class Son : public Base {<br>public:<br>static void func()<br>{<br>cout &lt;&lt; “Son - static void func()” &lt;&lt; endl;<br>}<br>static int m_A;<br>};</p>\n<p>int Son::m_A = 200;</p>\n<p>//同名成员属性<br>void test01()<br>{<br>//通过对象访问<br>cout &lt;&lt; “通过对象访问： “ &lt;&lt; endl;<br>Son s;<br>cout &lt;&lt; “Son 下 m_A = “ &lt;&lt; s.m_A &lt;&lt; endl;<br>cout &lt;&lt; “Base 下 m_A = “ &lt;&lt; s.Base::m_A &lt;&lt; endl;</p>\n<pre><code>//通过类名访问\ncout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;\ncout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;</code></pre><p>}</p>\n<p>//同名成员函数<br>void test02()<br>{<br>//通过对象访问<br>cout &lt;&lt; “通过对象访问： “ &lt;&lt; endl;<br>Son s;<br>s.func();<br>s.Base::func();</p>\n<pre><code>cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\nSon::func();\nSon::Base::func();\n//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\nSon::Base::func(100);</code></pre><p>}<br>int main() {</p>\n<pre><code>//test01();\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>\n<p>4.6.7 多继承语法<br>C++允许一个类继承多个类</p>\n<p>语法：class 子类 ：继承方式 父类 1 ， 继承方式 父类 2…</p>\n<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>\n<p>C++实际开发中不建议用多继承</p>\n<p>示例：</p>\n<p>C++<br>class Base1 {<br>public:<br>Base1()<br>{<br>m_A = 100;<br>}<br>public:<br>int m_A;<br>};</p>\n<p>class Base2 {<br>public:<br>Base2()<br>{<br>m_A = 200; //开始是 m_B 不会出问题，但是改为 mA 就会出现不明确<br>}<br>public:<br>int m_A;<br>};</p>\n<p>//语法：class 子类：继承方式 父类 1 ，继承方式 父类 2<br>class Son : public Base2, public Base1<br>{<br>public:<br>Son()<br>{<br>m_C = 300;<br>m_D = 400;<br>}<br>public:<br>int m_C;<br>int m_D;<br>};</p>\n<p>//多继承容易产生成员同名的情况<br>//通过使用类名作用域可以区分调用哪一个基类的成员<br>void test01()<br>{<br>Son s;<br>cout &lt;&lt; “sizeof Son = “ &lt;&lt; sizeof(s) &lt;&lt; endl;<br>cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;<br>cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>\n<p>4.6.8 菱形继承<br>菱形继承概念：</p>\n<p>​ 两个派生类继承同一个基类</p>\n<p>​ 又有某个类同时继承者两个派生类</p>\n<p>​ 这种继承被称为菱形继承，或者钻石继承</p>\n<p>典型的菱形继承案例：</p>\n<p>IMG_256<br>IMG_256</p>\n<p>菱形继承问题：</p>\n<p>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</p>\n<p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>\n<p>示例：</p>\n<p>C++<br>class Animal<br>{<br>public:<br>int m_Age;<br>};</p>\n<p>//继承前加 virtual 关键字后，变为虚继承<br>//此时公共的父类 Animal 称为虚基类<br>class Sheep : virtual public Animal {};<br>class Tuo : virtual public Animal {};<br>class SheepTuo : public Sheep, public Tuo {};</p>\n<p>void test01()<br>{<br>SheepTuo st;<br>st.Sheep::m_Age = 100;<br>st.Tuo::m_Age = 200;</p>\n<pre><code>cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;\ncout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;\ncout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义<br>利用虚继承可以解决菱形继承问题<br>4.7 多态<br>4.7.1 多态的基本概念<br>多态是 C++面向对象三大特性之一</p>\n<p>多态分为两类</p>\n<p>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名<br>动态多态: 派生类和虚函数实现运行时多态<br>静态多态和动态多态区别：</p>\n<p>静态多态的函数地址早绑定 - 编译阶段确定函数地址<br>动态多态的函数地址晚绑定 - 运行阶段确定函数地址<br>下面通过案例进行讲解多态</p>\n<p>C++<br>class Animal<br>{<br>public:<br>//Speak 函数就是虚函数<br>//函数前面加上 virtual 关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。<br>virtual void speak()<br>{<br>cout &lt;&lt; “动物在说话” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Cat :public Animal<br>{<br>public:<br>void speak()<br>{<br>cout &lt;&lt; “小猫在说话” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Dog :public Animal<br>{<br>public:</p>\n<pre><code>void speak()\n{\n    cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;\n}</code></pre><p>};<br>//我们希望传入什么对象，那么就调用什么对象的函数<br>//如果函数地址在编译阶段就能确定，那么静态联编<br>//如果函数地址在运行阶段才能确定，就是动态联编</p>\n<p>void DoSpeak(Animal &amp; animal)<br>{<br>animal.speak();<br>}<br>//<br>//多态满足条件：<br>//1、有继承关系<br>//2、子类重写父类中的虚函数<br>//多态使用：<br>//父类指针或引用指向子类对象</p>\n<p>void test01()<br>{<br>Cat cat;<br>DoSpeak(cat);</p>\n<pre><code>Dog dog;\nDoSpeak(dog);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>多态满足条件</p>\n<p>有继承关系<br>子类重写父类中的虚函数<br>多态使用条件</p>\n<p>父类指针或引用指向子类对象<br>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p>\n<p>4.7.2 多态案例一-计算器类<br>案例描述：</p>\n<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>\n<p>多态的优点：</p>\n<p>代码组织结构清晰<br>可读性强<br>利于前期和后期的扩展以及维护<br>示例：</p>\n<p>C++<br>//普通实现<br>class Calculator {<br>public:<br>int getResult(string oper)<br>{<br>if (oper == “+”) {<br>return m_Num1 + m_Num2;<br>}<br>else if (oper == “-“) {<br>return m_Num1 - m_Num2;<br>}<br>else if (oper == “_”) {<br>return m_Num1 _ m_Num2;<br>}<br>//如果要提供新的运算，需要修改源码<br>}<br>public:<br>int m_Num1;<br>int m_Num2;<br>};</p>\n<p>void test01()<br>{<br>//普通实现测试<br>Calculator c;<br>c.m_Num1 = 10;<br>c.m_Num2 = 10;<br>cout &lt;&lt; c.m_Num1 &lt;&lt; “ + “ &lt;&lt; c.m_Num2 &lt;&lt; “ = “ &lt;&lt; c.getResult(“+”) &lt;&lt; endl;</p>\n<pre><code>cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;\n\ncout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;</code></pre><p>}</p>\n<p>//多态实现<br>//抽象计算器类<br>//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护<br>class AbstractCalculator<br>{<br>public :</p>\n<pre><code>virtual int getResult()\n{\n    return 0;\n}\n\nint m_Num1;\nint m_Num2;</code></pre><p>};</p>\n<p>//加法计算器<br>class AddCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 + m_Num2;<br>}<br>};</p>\n<p>//减法计算器<br>class SubCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 - m_Num2;<br>}<br>};</p>\n<p>//乘法计算器<br>class MulCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 * m_Num2;<br>}<br>};</p>\n<p>void test02()<br>{<br>//创建加法计算器<br>AbstractCalculator *abc = new AddCalculator;<br>abc-&gt;m_Num1 = 10;<br>abc-&gt;m_Num2 = 10;<br>cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; “ + “ &lt;&lt; abc-&gt;m_Num2 &lt;&lt; “ = “ &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;<br>delete abc; //用完了记得销毁</p>\n<pre><code>//创建减法计算器\nabc = new SubCalculator;\nabc-&gt;m_Num1 = 10;\nabc-&gt;m_Num2 = 10;\ncout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\ndelete abc;\n\n//创建乘法计算器\nabc = new MulCalculator;\nabc-&gt;m_Num1 = 10;\nabc-&gt;m_Num2 = 10;\ncout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\ndelete abc;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>\n<p>4.7.3 纯虚函数和抽象类<br>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>\n<p>因此可以将虚函数改为纯虚函数</p>\n<p>纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ;</p>\n<p>当类中有了纯虚函数，这个类也称为==抽象类==</p>\n<p>抽象类特点：</p>\n<p>无法实例化对象<br>子类必须重写抽象类中的纯虚函数，否则也属于抽象类<br>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>//纯虚函数<br>//类中只要有一个纯虚函数就称为抽象类<br>//抽象类无法实例化对象<br>//子类必须重写父类中的纯虚函数，否则也属于抽象类<br>virtual void func() = 0;<br>};</p>\n<p>class Son :public Base<br>{<br>public:<br>virtual void func()<br>{<br>cout &lt;&lt; “func 调用” &lt;&lt; endl;<br>};<br>};</p>\n<p>void test01()<br>{<br>Base * base = NULL;<br>//base = new Base; // 错误，抽象类无法实例化对象<br>base = new Son;<br>base-&gt;func();<br>delete base;//记得销毁<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.7.4 多态案例二-制作饮品<br>案例描述：</p>\n<p>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</p>\n<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>\n<p>1545985945198<br>1545985945198</p>\n<p>示例：</p>\n<p>C++<br>//抽象制作饮品<br>class AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() = 0;<br>//冲泡<br>virtual void Brew() = 0;<br>//倒入杯中<br>virtual void PourInCup() = 0;<br>//加入辅料<br>virtual void PutSomething() = 0;<br>//规定流程<br>void MakeDrink() {<br>Boil();<br>Brew();<br>PourInCup();<br>PutSomething();<br>}<br>};</p>\n<p>//制作咖啡<br>class Coffee : public AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() {<br>cout &lt;&lt; “煮农夫山泉!” &lt;&lt; endl;<br>}<br>//冲泡<br>virtual void Brew() {<br>cout &lt;&lt; “冲泡咖啡!” &lt;&lt; endl;<br>}<br>//倒入杯中<br>virtual void PourInCup() {<br>cout &lt;&lt; “将咖啡倒入杯中!” &lt;&lt; endl;<br>}<br>//加入辅料<br>virtual void PutSomething() {<br>cout &lt;&lt; “加入牛奶!” &lt;&lt; endl;<br>}<br>};</p>\n<p>//制作茶水<br>class Tea : public AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() {<br>cout &lt;&lt; “煮自来水!” &lt;&lt; endl;<br>}<br>//冲泡<br>virtual void Brew() {<br>cout &lt;&lt; “冲泡茶叶!” &lt;&lt; endl;<br>}<br>//倒入杯中<br>virtual void PourInCup() {<br>cout &lt;&lt; “将茶水倒入杯中!” &lt;&lt; endl;<br>}<br>//加入辅料<br>virtual void PutSomething() {<br>cout &lt;&lt; “加入枸杞!” &lt;&lt; endl;<br>}<br>};</p>\n<p>//业务函数<br>void DoWork(AbstractDrinking* drink) {<br>drink-&gt;MakeDrink();<br>delete drink;<br>}</p>\n<p>void test01() {<br>DoWork(new Coffee);<br>cout &lt;&lt; “————–” &lt;&lt; endl;<br>DoWork(new Tea);<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.7.5 虚析构和纯虚析构<br>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>\n<p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p>\n<p>虚析构和纯虚析构共性：</p>\n<p>可以解决父类指针释放子类对象<br>都需要有具体的函数实现<br>虚析构和纯虚析构区别：</p>\n<p>如果是纯虚析构，该类属于抽象类，无法实例化对象<br>虚析构语法：</p>\n<p>virtual ~类名(){}</p>\n<p>纯虚析构语法：</p>\n<p>virtual ~类名() = 0;</p>\n<p>类名::~类名(){}</p>\n<p>示例：</p>\n<p>C++<br>class Animal {<br>public:</p>\n<pre><code>Animal()\n{\n    cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;\n}\nvirtual void Speak() = 0;\n\n//析构函数加上virtual关键字，变成虚析构函数\n//virtual ~Animal()\n//{\n//    cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;\n//}\n\n\nvirtual ~Animal() = 0;</code></pre><p>};</p>\n<p>Animal::~Animal()<br>{<br>cout &lt;&lt; “Animal 纯虚析构函数调用！” &lt;&lt; endl;<br>}</p>\n<p>//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</p>\n<p>class Cat : public Animal {<br>public:<br>Cat(string name)<br>{<br>cout &lt;&lt; “Cat 构造函数调用！” &lt;&lt; endl;<br>m_Name = new string(name);<br>}<br>virtual void Speak()<br>{<br>cout &lt;&lt; *m_Name &lt;&lt; “小猫在说话!” &lt;&lt; endl;<br>}<br>~Cat()<br>{<br>cout &lt;&lt; “Cat 析构函数调用!” &lt;&lt; endl;<br>if (this-&gt;m_Name != NULL) {<br>delete m_Name;<br>m_Name = NULL;<br>}<br>}</p>\n<p>public:<br>string *m_Name;<br>};</p>\n<p>void test01()<br>{<br>Animal *animal = new Cat(“Tom”);<br>animal-&gt;Speak();</p>\n<pre><code>//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\n//怎么解决？给基类增加一个虚析构函数\n//虚析构函数就是用来解决通过父类指针释放子类对象\ndelete animal;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>\n<p>​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>\n<p>​ 3. 拥有纯虚析构函数的类也属于抽象类</p>\n<p>4.7.6 多态案例三-电脑组装<br>案例描述：</p>\n<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>\n<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如 Intel 厂商和 Lenovo 厂商</p>\n<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>\n<p>测试时组装三台不同的电脑进行工作</p>\n<p>示例：</p>\n<p>C++<br>#include<iostream><br>using namespace std;</p>\n<p>//抽象 CPU 类<br>class CPU<br>{<br>public:<br>//抽象的计算函数<br>virtual void calculate() = 0;<br>};</p>\n<p>//抽象显卡类<br>class VideoCard<br>{<br>public:<br>//抽象的显示函数<br>virtual void display() = 0;<br>};</p>\n<p>//抽象内存条类<br>class Memory<br>{<br>public:<br>//抽象的存储函数<br>virtual void storage() = 0;<br>};</p>\n<p>//电脑类<br>class Computer<br>{<br>public:<br>Computer(CPU _ cpu, VideoCard _ vc, Memory * mem)<br>{<br>m_cpu = cpu;<br>m_vc = vc;<br>m_mem = mem;<br>}</p>\n<pre><code>//提供工作的函数\nvoid work()\n{\n    //让零件工作起来，调用接口\n    m_cpu-&gt;calculate();\n\n    m_vc-&gt;display();\n\n    m_mem-&gt;storage();\n}\n\n//提供析构函数 释放3个电脑零件\n~Computer()\n{\n\n    //释放CPU零件\n    if (m_cpu != NULL)\n    {\n        delete m_cpu;\n        m_cpu = NULL;\n    }\n\n    //释放显卡零件\n    if (m_vc != NULL)\n    {\n        delete m_vc;\n        m_vc = NULL;\n    }\n\n    //释放内存条零件\n    if (m_mem != NULL)\n    {\n        delete m_mem;\n        m_mem = NULL;\n    }\n}</code></pre><p>private:</p>\n<pre><code>CPU * m_cpu; //CPU的零件指针\nVideoCard * m_vc; //显卡零件指针\nMemory * m_mem; //内存条零件指针</code></pre><p>};</p>\n<p>//具体厂商<br>//Intel 厂商<br>class IntelCPU :public CPU<br>{<br>public:<br>virtual void calculate()<br>{<br>cout &lt;&lt; “Intel 的 CPU 开始计算了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class IntelVideoCard :public VideoCard<br>{<br>public:<br>virtual void display()<br>{<br>cout &lt;&lt; “Intel 的显卡开始显示了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class IntelMemory :public Memory<br>{<br>public:<br>virtual void storage()<br>{<br>cout &lt;&lt; “Intel 的内存条开始存储了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>//Lenovo 厂商<br>class LenovoCPU :public CPU<br>{<br>public:<br>virtual void calculate()<br>{<br>cout &lt;&lt; “Lenovo 的 CPU 开始计算了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class LenovoVideoCard :public VideoCard<br>{<br>public:<br>virtual void display()<br>{<br>cout &lt;&lt; “Lenovo 的显卡开始显示了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class LenovoMemory :public Memory<br>{<br>public:<br>virtual void storage()<br>{<br>cout &lt;&lt; “Lenovo 的内存条开始存储了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//第一台电脑零件<br>CPU _ intelCpu = new IntelCPU;<br>VideoCard _ intelCard = new IntelVideoCard;<br>Memory * intelMem = new IntelMemory;</p>\n<pre><code>cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;\n//创建第一台电脑\nComputer * computer1 = new Computer(intelCpu, intelCard, intelMem);\ncomputer1-&gt;work();\ndelete computer1;\n\ncout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;\n//第二台电脑组装\nComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\ncomputer2-&gt;work();\ndelete computer2;\n\ncout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;\n//第三台电脑组装\nComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\ncomputer3-&gt;work();\ndelete computer3;</code></pre><p>}<br>5 文件操作<br>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>\n<p>通过文件可以将数据持久化</p>\n<p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p>\n<p>文件类型分为两种：</p>\n<p>文本文件 - 文件以文本的 ASCII 码形式存储在计算机中<br>二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们<br>操作文件的三大类:</p>\n<p>ofstream：写操作<br>ifstream： 读操作<br>fstream ： 读写操作<br>5.1 文本文件<br>5.1.1 写文件<br>写文件步骤如下：</p>\n<p>包含头文件</p>\n<p>#include <fstream></p>\n<p>创建流对象</p>\n<p>ofstream ofs;</p>\n<p>打开文件</p>\n<p>ofs.open(“文件路径”,打开方式);</p>\n<p>写数据</p>\n<p>ofs &lt;&lt; “写入的数据”;</p>\n<p>关闭文件</p>\n<p>ofs.close();</p>\n<p>文件打开方式：</p>\n<p>打开方式 解释<br>ios::in 为读文件而打开文件<br>ios::out 为写文件而打开文件<br>ios::ate 初始位置：文件尾<br>ios::app 追加方式写文件<br>ios::trunc 如果文件存在先删除，再创建<br>ios::binary 二进制方式<br>注意： 文件打开方式可以配合使用，利用|操作符</p>\n<p>例如：用二进制方式写文件 ios::binary | ios:: out</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream></p>\n<p>void test01()<br>{<br>ofstream ofs;<br>ofs.open(“test.txt”, ios::out);</p>\n<pre><code>ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;\nofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;\nofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;\n\nofs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>文件操作必须包含头文件 fstream<br>读文件可以利用 ofstream ，或者 fstream 类<br>打开文件时候需要指定操作文件的路径，以及打开方式<br>利用&lt;&lt;可以向文件中写数据<br>操作完毕，要关闭文件<br>5.1.2 读文件<br>读文件与写文件步骤相似，但是读取方式相对于比较多</p>\n<p>读文件步骤如下：</p>\n<p>包含头文件</p>\n<p>#include <fstream></p>\n<p>创建流对象</p>\n<p>ifstream ifs;</p>\n<p>打开文件并判断文件是否打开成功</p>\n<p>ifs.open(“文件路径”,打开方式);</p>\n<p>读数据</p>\n<p>四种方式读取</p>\n<p>关闭文件</p>\n<p>ifs.close();</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string><br>void test01()<br>{<br>ifstream ifs;<br>ifs.open(“test.txt”, ios::in);</p>\n<pre><code>if (!ifs.is_open())\n{\n    cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;\n    return;\n}\n\n//第一种方式\n//char buf[1024] = { 0 };\n//while (ifs &gt;&gt; buf)\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\n//第二种\n//char buf[1024] = { 0 };\n//while (ifs.getline(buf,sizeof(buf)))\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\n//第三种\n//string buf;\n//while (getline(ifs, buf))\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\nchar c;\nwhile ((c = ifs.get()) != EOF)\n{\n    cout &lt;&lt; c;\n}\n\nifs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>读文件可以利用 ifstream ，或者 fstream 类<br>利用 is_open 函数可以判断文件是否打开成功<br>close 关闭文件<br>5.2 二进制文件<br>以二进制的方式对文件进行读写操作</p>\n<p>打开方式要指定为 ==ios::binary==</p>\n<p>5.2.1 写文件<br>二进制方式写文件主要利用流对象调用成员函数 write</p>\n<p>函数原型 ：ostream&amp; write(const char * buffer,int len);</p>\n<p>参数解释：字符指针 buffer 指向内存中一段存储空间。len 是读写的字节数</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string></p>\n<p>class Person<br>{<br>public:<br>char m_Name[64];<br>int m_Age;<br>};</p>\n<p>//二进制文件 写文件<br>void test01()<br>{<br>//1、包含头文件</p>\n<pre><code>//2、创建输出流对象\nofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary);\n\n//3、打开文件\n//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);\n\nPerson p = {&quot;张三&quot;  , 18};\n\n//4、写文件\nofs.write((const char *)&amp;p, sizeof(p));\n\n//5、关闭文件\nofs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>文件输出流对象 可以通过 write 函数，以二进制方式写数据<br>5.2.2 读文件<br>二进制方式读文件主要利用流对象调用成员函数 read</p>\n<p>函数原型：istream&amp; read(char *buffer,int len);</p>\n<p>参数解释：字符指针 buffer 指向内存中一段存储空间。len 是读写的字节数</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string></p>\n<p>class Person<br>{<br>public:<br>char m_Name[64];<br>int m_Age;<br>};</p>\n<p>void test01()<br>{<br>ifstream ifs(“person.txt”, ios::in | ios::binary);<br>if (!ifs.is_open())<br>{<br>cout &lt;&lt; “文件打开失败” &lt;&lt; endl;<br>}</p>\n<pre><code>Person p;\nifs.read((char *)&amp;p, sizeof(p));\n\ncout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>文件输入流对象 可以通过 read 函数，以二进制方式读数据</p>\n"},{"title":"A first look at C++ (2) copy 4","url":"/2023/01/18/A%20first%20look%20at%20C++%20(2)%20copy%204/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>C++核心编程<br>本阶段主要针对 C++==面向对象==编程技术做详细讲解，探讨 C++中的核心和精髓。</p>\n<p>1 内存分区模型<br>C++程序在执行时，将内存大方向划分为 4 个区域</p>\n<p>代码区：存放函数体的二进制代码，由操作系统进行管理的<br>全局区：存放全局变量和静态变量以及常量<br>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等<br>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收<br>内存四区意义：</p>\n<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>\n<p>1.1 程序运行前<br>​ 在程序编译后，生成了 exe 可执行程序，未执行该程序前分为两个区域</p>\n<p>​ 代码区：</p>\n<p>​ 存放 CPU 执行的机器指令</p>\n<p>​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>\n<p>​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令</p>\n<p>​ 全局区：</p>\n<p>​ 全局变量和静态变量存放在此.</p>\n<p>​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>\n<p>​ ==该区域的数据在程序结束后由操作系统释放==.</p>\n<p>示例：</p>\n<p>C++<br>//全局变量<br>int g_a = 10;<br>int g_b = 10;</p>\n<p>//全局常量<br>const int c_g_a = 10;<br>const int c_g_b = 10;</p>\n<p>int main() {</p>\n<pre><code>//局部变量\nint a = 10;\nint b = 10;\n\n//打印地址\ncout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;\ncout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;\n\ncout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt;  (int)&amp;g_a &lt;&lt; endl;\ncout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt;  (int)&amp;g_b &lt;&lt; endl;\n\n//静态变量\nstatic int s_a = 10;\nstatic int s_b = 10;\n\ncout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;\ncout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;\n\ncout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;\n\ncout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;\ncout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;\n\nconst int c_l_a = 10;\nconst int c_l_b = 10;\ncout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;\ncout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>打印结果：</p>\n<p>1545017602518<br>1545017602518</p>\n<p>总结：</p>\n<p>C++中在程序运行前分为全局区和代码区<br>代码区特点是共享和只读<br>全局区中存放全局变量、静态变量、常量<br>常量区中存放 const 修饰的全局常量 和 字符串常量<br>1.2 程序运行后<br>​ 栈区：</p>\n<p>​ 由编译器自动分配释放, 存放函数的参数值,局部变量等</p>\n<p>​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>\n<p>示例：</p>\n<p>C++<br>int * func()<br>{<br>int a = 10;<br>return &a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>​ 堆区：</p>\n<p>​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>\n<p>​ 在 C++中主要利用 new 在堆区开辟内存</p>\n<p>示例：</p>\n<p>C++<br>int* func()<br>{<br>int* a = new int(10);<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>堆区数据由程序员管理开辟和释放</p>\n<p>堆区数据利用 new 关键字进行开辟内存</p>\n<p>1.3 new 操作符<br>​ C++中利用==new==操作符在堆区开辟数据</p>\n<p>​ 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p>\n<p>​ 语法：new 数据类型</p>\n<p>​ 利用 new 创建的数据，会返回该数据对应的类型的指针</p>\n<p>示例 1： 基本语法</p>\n<p>C++<br>int* func()<br>{<br>int* a = new int(10);<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\n//利用delete释放堆区数据\ndelete p;\n\n//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：开辟数组</p>\n<p>C++<br>//堆区开辟数组<br>int main() {</p>\n<pre><code>int* arr = new int[10];\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    arr[i] = i + 100;\n}\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    cout &lt;&lt; arr[i] &lt;&lt; endl;\n}\n//释放数组 delete 后加 []\ndelete[] arr;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2 引用<br>2.1 引用的基本使用<br>*作用： *给变量起别名</p>\n<p>语法： 数据类型 &amp;别名 = 原名</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int a = 10;\nint &amp;b = a;\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n\nb = 100;\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2.2 引用注意事项<br>引用必须初始化<br>引用在初始化后，不可以改变<br>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int a = 10;\nint b = 20;\n//int &amp;c; //错误，引用必须初始化\nint &amp;c = a; //一旦初始化后，就不可以更改\nc = b; //这是赋值操作，不是更改引用\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\ncout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2.3 引用做函数参数<br>作用：函数传参时，可以利用引用的技术让形参修饰实参</p>\n<p>优点：可以简化指针修改实参</p>\n<p>示例：</p>\n<p>C++<br>//1. 值传递<br>void mySwap01(int a, int b) {<br>int temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>//2. 地址传递<br>void mySwap02(int* a, int* b) {<br>int temp = *a;<br>*a = *b;<br>*b = temp;<br>}</p>\n<p>//3. 引用传递<br>void mySwap03(int&amp; a, int&amp; b) {<br>int temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>int main() {</p>\n<pre><code>int a = 10;\nint b = 20;\n\nmySwap01(a, b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nmySwap02(&amp;a, &amp;b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nmySwap03(a, b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>\n<p>2.4 引用做函数返回值<br>作用：引用是可以作为函数的返回值存在的</p>\n<p>注意：不要返回局部变量引用</p>\n<p>用法：函数调用作为左值</p>\n<p>示例：</p>\n<p>C++<br>//返回局部变量引用<br>int&amp; test01() {<br>int a = 10; //局部变量<br>return a;<br>}</p>\n<p>//返回静态变量引用<br>int&amp; test02() {<br>static int a = 20;<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>//不能返回局部变量的引用\nint&amp; ref = test01();\ncout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\ncout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\n\n//如果函数做左值，那么必须返回引用\nint&amp; ref2 = test02();\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\ntest02() = 1000;\n\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>​</p>\n<p>2.5 引用的本质<br>本质：引用的本质在 c++内部实现是一个指针常量.</p>\n<p>讲解示例：</p>\n<p>C++<br>//发现是引用，转换为 int* const ref = &a;<br>void func(int&amp; ref){<br>ref = 100; // ref 是引用，转换为*ref = 100<br>}<br>int main(){<br>int a = 10;</p>\n<pre><code>//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改\nint&amp; ref = a;\nref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\n\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;\n\nfunc(a);\nreturn 0;</code></pre><p>}<br>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>\n<p>2.6 常量引用<br>作用：常量引用主要用来修饰形参，防止误操作</p>\n<p>在函数形参列表中，可以加==const 修饰形参==，防止形参改变实参</p>\n<p>示例：</p>\n<p>C++<br>//引用使用的场景，通常用来修饰形参<br>void showValue(const int&amp; v) {<br>//v += 10;<br>cout &lt;&lt; v &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误\n//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;\nconst int&amp; ref = 10;\n\n//ref = 100;  //加入const后不可以修改变量\ncout &lt;&lt; ref &lt;&lt; endl;\n\n//函数中利用常量引用防止误操作修改实参\nint a = 10;\nshowValue(a);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3 函数提高<br>3.1 函数默认参数<br>在 C++中，函数的形参列表中的形参是可以有默认值的。</p>\n<p>语法：返回值类型 函数名 （参数= 默认值）{}</p>\n<p>示例：</p>\n<p>C++<br>int func(int a, int b = 10, int c = 10) {<br>return a + b + c;<br>}</p>\n<p>//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值<br>//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数<br>int func2(int a = 10, int b = 10);<br>int func2(int a, int b) {<br>return a + b;<br>}</p>\n<p>int main() {</p>\n<pre><code>cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;\ncout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.2 函数占位参数<br>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>\n<p>语法： 返回值类型 函数名 (数据类型){}</p>\n<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>\n<p>示例：</p>\n<p>C++<br>//函数占位参数 ，占位参数也可以有默认参数<br>void func(int a, int) {<br>cout &lt;&lt; “this is func” &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>func(10,10); //占位参数必须填补\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.3 函数重载<br>3.3.1 函数重载概述<br>作用：函数名可以相同，提高复用性</p>\n<p>函数重载满足条件：</p>\n<p>同一个作用域下<br>函数名称相同<br>函数参数类型不同 或者 个数不同 或者 顺序不同<br>注意: 函数的返回值不可以作为函数重载的条件</p>\n<p>示例：</p>\n<p>C++<br>//函数重载需要函数都在同一个作用域下<br>void func()<br>{<br>cout &lt;&lt; “func 的调用！” &lt;&lt; endl;<br>}<br>void func(int a)<br>{<br>cout &lt;&lt; “func (int a) 的调用！” &lt;&lt; endl;<br>}<br>void func(double a)<br>{<br>cout &lt;&lt; “func (double a)的调用！” &lt;&lt; endl;<br>}<br>void func(int a ,double b)<br>{<br>cout &lt;&lt; “func (int a ,double b) 的调用！” &lt;&lt; endl;<br>}<br>void func(double a ,int b)<br>{<br>cout &lt;&lt; “func (double a ,int b)的调用！” &lt;&lt; endl;<br>}</p>\n<p>//函数返回值不可以作为函数重载条件<br>//int func(double a, int b)<br>//{<br>// cout &lt;&lt; “func (double a ,int b)的调用！” &lt;&lt; endl;<br>//}</p>\n<p>int main() {</p>\n<pre><code>func();\nfunc(10);\nfunc(3.14);\nfunc(10,3.14);\nfunc(3.14 , 10);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.3.2 函数重载注意事项<br>引用作为重载条件<br>函数重载碰到函数默认参数<br>示例：</p>\n<p>C++<br>//函数重载注意事项<br>//1、引用作为重载条件</p>\n<p>void func(int &amp;a)<br>{<br>cout &lt;&lt; “func (int &amp;a) 调用 “ &lt;&lt; endl;<br>}</p>\n<p>void func(const int &amp;a)<br>{<br>cout &lt;&lt; “func (const int &amp;a) 调用 “ &lt;&lt; endl;<br>}</p>\n<p>//2、函数重载碰到函数默认参数</p>\n<p>void func2(int a, int b = 10)<br>{<br>cout &lt;&lt; “func2(int a, int b = 10) 调用” &lt;&lt; endl;<br>}</p>\n<p>void func2(int a)<br>{<br>cout &lt;&lt; “func2(int a) 调用” &lt;&lt; endl;<br>}</p>\n<p>int main() {<br>int a = 10;<br>func(a); //调用无 const<br>func(10);//调用有 const</p>\n<pre><code>//func2(10); //碰到默认参数产生歧义，需要避免\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4 类和对象<br>C++面向对象的三大特性为：==封装、继承、多态==</p>\n<p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p>\n<p>例如：</p>\n<p>​ 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>\n<p>​ 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>\n<p>​ 具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p>\n<p>4.1 封装<br>4.1.1 封装的意义<br>封装是 C++面向对象三大特性之一</p>\n<p>封装的意义：</p>\n<p>将属性和行为作为一个整体，表现生活中的事物<br>将属性和行为加以权限控制<br>封装意义一：</p>\n<p>​ 在设计类的时候，属性和行为写在一起，表现事物</p>\n<p>语法： class 类名{ 访问权限： 属性 / 行为 };</p>\n<p>示例 1：设计一个圆类，求圆的周长</p>\n<p>示例代码：</p>\n<p>C++<br>//圆周率<br>const double PI = 3.14;</p>\n<p>//1、封装的意义<br>//将属性和行为作为一个整体，用来表现生活中的事物</p>\n<p>//封装一个圆类，求圆的周长<br>//class 代表设计一个类，后面跟着的是类名<br>class Circle<br>{<br>public: //访问权限 公共的权限</p>\n<pre><code>//属性\nint m_r;//半径\n\n//行为\n//获取到圆的周长\ndouble calculateZC()\n{\n    //2 * pi  * r\n    //获取圆的周长\n    return  2 * PI * m_r;\n}</code></pre><p>};</p>\n<p>int main() {</p>\n<pre><code>//通过圆类，创建圆的对象\n// c1就是一个具体的圆\nCircle c1;\nc1.m_r = 10; //给圆对象的半径 进行赋值操作\n\n//2 * pi * 10 = = 62.8\ncout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>\n<p>示例 2 代码：</p>\n<p>C++<br>//学生类<br>class Student {<br>public:<br>void setName(string name) {<br>m_name = name;<br>}<br>void setID(int id) {<br>m_id = id;<br>}</p>\n<pre><code>void showStudent() {\n    cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;\n}</code></pre><p>public:<br>string m_name;<br>int m_id;<br>};</p>\n<p>int main() {</p>\n<pre><code>Student stu;\nstu.setName(&quot;德玛西亚&quot;);\nstu.setID(250);\nstu.showStudent();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>封装意义二：</p>\n<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>\n<p>访问权限有三种：</p>\n<p>public 公共权限<br>protected 保护权限<br>private 私有权限<br>示例：</p>\n<p>C++<br>//三种权限<br>//公共权限 public 类内可以访问 类外可以访问<br>//保护权限 protected 类内可以访问 类外不可以访问<br>//私有权限 private 类内可以访问 类外不可以访问</p>\n<p>class Person<br>{<br>//姓名 公共权限<br>public:<br>string m_Name;</p>\n<pre><code>//汽车  保护权限</code></pre><p>protected:<br>string m_Car;</p>\n<pre><code>//银行卡密码  私有权限</code></pre><p>private:<br>int m_Password;</p>\n<p>public:<br>void func()<br>{<br>m_Name = “张三”;<br>m_Car = “拖拉机”;<br>m_Password = 123456;<br>}<br>};</p>\n<p>int main() {</p>\n<pre><code>Person p;\np.m_Name = &quot;李四&quot;;\n//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到\n//p.m_Password = 123; //私有权限类外访问不到\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.1.2 struct 和 class 区别<br>在 C++中 struct 和 class 唯一的区别就在于 默认的访问权限不同</p>\n<p>区别：</p>\n<p>struct 默认权限为公共<br>class 默认权限为私有<br>C++<br>class C1<br>{<br>int m_A; //默认是私有权限<br>};</p>\n<p>struct C2<br>{<br>int m_A; //默认是公共权限<br>};</p>\n<p>int main() {</p>\n<pre><code>C1 c1;\nc1.m_A = 10; //错误，访问权限是私有\n\nC2 c2;\nc2.m_A = 10; //正确，访问权限是公共\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.1.3 成员属性设置为私有<br>优点 1：将所有成员属性设置为私有，可以自己控制读写权限</p>\n<p>优点 2：对于写权限，我们可以检测数据的有效性</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:</p>\n<pre><code>//姓名设置可读可写\nvoid setName(string name) {\n    m_Name = name;\n}\nstring getName()\n{\n    return m_Name;\n}\n\n\n//获取年龄\nint getAge() {\n    return m_Age;\n}\n//设置年龄\nvoid setAge(int age) {\n    if (age &lt; 0 || age &gt; 150) {\n        cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;\n        return;\n    }\n    m_Age = age;\n}\n\n//情人设置为只写\nvoid setLover(string lover) {\n    m_Lover = lover;\n}</code></pre><p>private:<br>string m_Name; //可读可写 姓名<br>int m_Age; //只读 年龄</p>\n<pre><code>string m_Lover; //只写  情人</code></pre><p>};</p>\n<p>int main() {</p>\n<pre><code>Person p;\n//姓名设置\np.setName(&quot;张三&quot;);\ncout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;\n\n//年龄设置\np.setAge(50);\ncout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;\n\n//情人设置\np.setLover(&quot;苍井&quot;);\n//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>练习案例 1：设计立方体类</p>\n<p>设计立方体类(Cube)</p>\n<p>求出立方体的面积和体积</p>\n<p>分别用全局函数和成员函数判断两个立方体是否相等。</p>\n<p>1545533548532<br>1545533548532</p>\n<p>练习案例 2：点和圆的关系</p>\n<p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p>\n<p>1545533829184<br>1545533829184</p>\n<p>4.2 对象的初始化和清理<br>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全<br>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。<br>4.2.1 构造函数和析构函数<br>对象的初始化和清理也是两个非常重要的安全问题</p>\n<p>​ 一个对象或者变量没有初始状态，对其使用后果是未知</p>\n<p>​ 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>\n<p>c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>\n<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供</p>\n<p>编译器提供的构造函数和析构函数是空实现。</p>\n<p>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。<br>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。<br>构造函数语法：类名(){}</p>\n<p>构造函数，没有返回值也不写 void<br>函数名称与类名相同<br>构造函数可以有参数，因此可以发生重载<br>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次<br>析构函数语法： ~类名(){}</p>\n<p>析构函数，没有返回值也不写 void<br>函数名称与类名相同,在名称前加上符号 ~<br>析构函数不可以有参数，因此不可以发生重载<br>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次<br>C++<br>class Person<br>{<br>public:<br>//构造函数<br>Person()<br>{<br>cout &lt;&lt; “Person 的构造函数调用” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person()<br>{<br>cout &lt;&lt; “Person 的析构函数调用” &lt;&lt; endl;<br>}</p>\n<p>};</p>\n<p>void test01()<br>{<br>Person p;<br>}</p>\n<p>int main() {<br>test01();</p>\n<pre><code>system(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.2 构造函数的分类及调用<br>两种分类方式：</p>\n<p>​ 按参数分为： 有参构造和无参构造</p>\n<p>​ 按类型分为： 普通构造和拷贝构造</p>\n<p>三种调用方式：</p>\n<p>​ 括号法</p>\n<p>​ 显示法</p>\n<p>​ 隐式转换法</p>\n<p>示例：</p>\n<p>C++<br>//1、构造函数分类<br>// 按照参数分类分为 有参和无参构造 无参又称为默认构造函数<br>// 按照类型分类分为 普通构造和拷贝构造</p>\n<p>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int a) {<br>age = a;<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>}<br>//拷贝构造函数<br>Person(const Person&amp; p) {<br>age = p.age;<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int age;<br>};</p>\n<p>//2、构造函数的调用<br>//调用无参构造函数<br>void test01() {<br>Person p; //调用无参构造函数<br>}</p>\n<p>//调用有参的构造函数<br>void test02() {</p>\n<pre><code>//2.1  括号法，常用\nPerson p1(10);\n//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n//Person p2();\n\n//2.2 显式法\nPerson p2 = Person(10);\nPerson p3 = Person(p2);\n//Person(10)单独写就是匿名对象  当前行结束之后，马上析构\n\n//2.3 隐式转换法\nPerson p4 = 10; // Person p4 = Person(10);\nPerson p5 = p4; // Person p5 = Person(p4);\n\n//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\n//Person p5(p4);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n//test02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.3 拷贝构造函数调用时机<br>C++中拷贝构造函数调用时机通常有三种情况</p>\n<p>使用一个已经创建完毕的对象来初始化一个新对象<br>值传递的方式给函数参数传值<br>以值方式返回局部对象<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>mAge = 0;<br>}<br>Person(int age) {<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>mAge = age;<br>}<br>Person(const Person&amp; p) {<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>mAge = p.mAge;<br>}<br>//析构函数在释放内存之前调用<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int mAge;<br>};</p>\n<p>//1. 使用一个已经创建完毕的对象来初始化一个新对象<br>void test01() {</p>\n<pre><code>Person man(100); //p对象已经创建完毕\nPerson newman(man); //调用拷贝构造函数\nPerson newman2 = man; //拷贝构造\n\n//Person newman3;\n//newman3 = man; //不是调用拷贝构造函数，赋值操作</code></pre><p>}</p>\n<p>//2. 值传递的方式给函数参数传值<br>//相当于 Person p1 = p;<br>void doWork(Person p1) {}<br>void test02() {<br>Person p; //无参构造函数<br>doWork(p);<br>}</p>\n<p>//3. 以值方式返回局部对象<br>Person doWork2()<br>{<br>Person p1;<br>cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;<br>return p1;<br>}</p>\n<p>void test03()<br>{<br>Person p = doWork2();<br>cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n//test02();\ntest03();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.4 构造函数调用规则<br>默认情况下，c++编译器至少给一个类添加 3 个函数</p>\n<p>1．默认构造函数(无参，函数体为空)</p>\n<p>2．默认析构函数(无参，函数体为空)</p>\n<p>3．默认拷贝构造函数，对属性进行值拷贝</p>\n<p>构造函数调用规则如下：</p>\n<p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造<br>如果用户定义拷贝构造函数，c++不会再提供其他构造函数<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int a) {<br>age = a;<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>}<br>//拷贝构造函数<br>Person(const Person&amp; p) {<br>age = p.age;<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int age;<br>};</p>\n<p>void test01()<br>{<br>Person p1(18);<br>//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作<br>Person p2(p1);</p>\n<pre><code>cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;</code></pre><p>}</p>\n<p>void test02()<br>{<br>//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造<br>Person p1; //此时如果用户自己没有提供默认构造，会出错<br>Person p2(10); //用户提供的有参<br>Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供</p>\n<pre><code>//如果用户提供拷贝构造，编译器不会提供其他构造函数\nPerson p4; //此时如果用户自己没有提供默认构造，会出错\nPerson p5(10); //此时如果用户自己没有提供有参，会出错\nPerson p6(p5); //用户自己提供拷贝构造</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.5 深拷贝与浅拷贝<br>深浅拷贝是面试经典问题，也是常见的一个坑</p>\n<p>浅拷贝：简单的赋值拷贝操作</p>\n<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int age ,int height) {<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;</p>\n<pre><code>    m_age = age;\n    m_height = new int(height);\n\n}\n//拷贝构造函数\nPerson(const Person&amp; p) {\n    cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n    //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题\n    m_age = p.m_age;\n    m_height = new int(*p.m_height);\n\n}\n\n//析构函数\n~Person() {\n    cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n    if (m_height != NULL)\n    {\n        delete m_height;\n    }\n}</code></pre><p>public:<br>int m_age;<br>int* m_height;<br>};</p>\n<p>void test01()<br>{<br>Person p1(18, 180);</p>\n<pre><code>Person p2(p1);\n\ncout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>\n<p>4.2.6 初始化列表<br>作用：</p>\n<p>C++提供了初始化列表语法，用来初始化属性</p>\n<p>语法：构造函数()：属性 1(值 1),属性 2（值 2）… {}</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:</p>\n<pre><code>////传统方式初始化\n//Person(int a, int b, int c) {\n//    m_A = a;\n//    m_B = b;\n//    m_C = c;\n//}\n\n//初始化列表方式初始化\nPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}\nvoid PrintPerson() {\n    cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;\n    cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;\n    cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;\n}</code></pre><p>private:<br>int m_A;<br>int m_B;<br>int m_C;<br>};</p>\n<p>int main() {</p>\n<pre><code>Person p(1, 2, 3);\np.PrintPerson();\n\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.7 类对象作为类成员<br>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>\n<p>例如：</p>\n<p>C++<br>class A {}<br>class B<br>{<br>A a；<br>}<br>B 类中有对象 A 作为成员，A 为对象成员</p>\n<p>那么当创建 B 对象时，A 与 B 的构造和析构的顺序是谁先谁后？</p>\n<p>示例：</p>\n<p>C++<br>class Phone<br>{<br>public:<br>Phone(string name)<br>{<br>m_PhoneName = name;<br>cout &lt;&lt; “Phone 构造” &lt;&lt; endl;<br>}</p>\n<pre><code>~Phone()\n{\n    cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;\n}\n\nstring m_PhoneName;</code></pre><p>};</p>\n<p>class Person<br>{<br>public:</p>\n<pre><code>//初始化列表可以告诉编译器调用哪一个构造函数\nPerson(string name, string pName) :m_Name(name), m_Phone(pName)\n{\n    cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;\n}\n\n~Person()\n{\n    cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;\n}\n\nvoid playGame()\n{\n    cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;\n}\n\nstring m_Name;\nPhone m_Phone;</code></pre><p>};<br>void test01()<br>{<br>//当类中成员是其他类对象时，我们称该成员为 对象成员<br>//构造的顺序是 ：先调用对象成员的构造，再调用本类构造<br>//析构顺序与构造相反<br>Person p(“张三” , “苹果 X”);<br>p.playGame();</p>\n<p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.8 静态成员<br>静态成员就是在成员变量和成员函数前加上关键字 static，称为静态成员</p>\n<p>静态成员分为：</p>\n<p>静态成员变量<br>所有对象共享同一份数据<br>在编译阶段分配内存<br>类内声明，类外初始化<br>静态成员函数<br>所有对象共享同一个函数<br>静态成员函数只能访问静态成员变量<br>示例 1 ：静态成员变量</p>\n<p>C++<br>class Person<br>{<br>public:</p>\n<pre><code>static int m_A; //静态成员变量\n\n//静态成员变量特点：\n//1 在编译阶段分配内存\n//2 类内声明，类外初始化\n//3 所有对象共享同一份数据</code></pre><p>private:<br>static int m_B; //静态成员变量也是有访问权限的<br>};<br>int Person::m_A = 10;<br>int Person::m_B = 10;</p>\n<p>void test01()<br>{<br>//静态成员变量两种访问方式</p>\n<pre><code>//1、通过对象\nPerson p1;\np1.m_A = 100;\ncout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl;\n\nPerson p2;\np2.m_A = 200;\ncout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据\ncout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl;\n\n//2、通过类名\ncout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl;\n\n\n//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：静态成员函数</p>\n<p>C++<br>class Person<br>{</p>\n<p>public:</p>\n<pre><code>//静态成员函数特点：\n//1 程序共享一个函数\n//2 静态成员函数只能访问静态成员变量\n\nstatic void func()\n{\n    cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;\n    m_A = 100;\n    //m_B = 100; //错误，不可以访问非静态成员变量\n}\n\nstatic int m_A; //静态成员变量\nint m_B; //</code></pre><p>private:</p>\n<pre><code>//静态成员函数也是有访问权限的\nstatic void func2()\n{\n    cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;\n}</code></pre><p>};<br>int Person::m_A = 10;</p>\n<p>void test01()<br>{<br>//静态成员变量两种访问方式</p>\n<pre><code>//1、通过对象\nPerson p1;\np1.func();\n\n//2、通过类名\nPerson::func();\n\n\n//Person::func2(); //私有权限访问不到</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3 C++对象模型和 this 指针<br>4.3.1 成员变量和成员函数分开存储<br>在 C++中，类内的成员变量和成员函数分开存储</p>\n<p>只有非静态成员变量才属于类的对象上</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>mA = 0;<br>}<br>//非静态成员变量占对象空间<br>int mA;<br>//静态成员变量不占对象空间<br>static int mB;<br>//函数也不占对象空间，所有函数共享一个函数实例<br>void func() {<br>cout &lt;&lt; “mA:” &lt;&lt; this-&gt;mA &lt;&lt; endl;<br>}<br>//静态成员函数也不占对象空间<br>static void sfunc() {<br>}<br>};</p>\n<p>int main() {</p>\n<pre><code>cout &lt;&lt; sizeof(Person) &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.2 this 指针概念<br>通过 4.3.1 我们知道在 C++中成员变量和成员函数是分开存储的</p>\n<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>\n<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>\n<p>c++通过提供特殊的对象指针，this 指针，解决上述问题。this 指针指向被调用的成员函数所属的对象</p>\n<p>this 指针是隐含每一个非静态成员函数内的一种指针</p>\n<p>this 指针不需要定义，直接使用即可</p>\n<p>this 指针的用途：</p>\n<p>当形参和成员变量同名时，可用 this 指针来区分<br>在类的非静态成员函数中返回对象本身，可使用 return *this<br>C++<br>class Person<br>{<br>public:</p>\n<pre><code>Person(int age)\n{\n    //1、当形参和成员变量同名时，可用this指针来区分\n    this-&gt;age = age;\n}\n\nPerson&amp; PersonAddPerson(Person p)\n{\n    this-&gt;age += p.age;\n    //返回对象本身\n    return *this;\n}\n\nint age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>Person p1(10);<br>cout &lt;&lt; “p1.age = “ &lt;&lt; p1.age &lt;&lt; endl;</p>\n<pre><code>Person p2(10);\np2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\ncout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.3 空指针访问成员函数<br>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针</p>\n<p>如果用到 this 指针，需要加以判断保证代码的健壮性</p>\n<p>示例：</p>\n<p>C++<br>//空指针访问成员函数<br>class Person {<br>public:</p>\n<pre><code>void ShowClassName() {\n    cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;\n}\n\nvoid ShowPerson() {\n    if (this == NULL) {\n        return;\n    }\n    cout &lt;&lt; mAge &lt;&lt; endl;\n}</code></pre><p>public:<br>int mAge;<br>};</p>\n<p>void test01()<br>{<br>Person * p = NULL;<br>p-&gt;ShowClassName(); //空指针，可以调用成员函数<br>p-&gt;ShowPerson(); //但是如果成员函数中用到了 this 指针，就不可以了<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.4 const 修饰成员函数<br>常函数：</p>\n<p>成员函数后加 const 后我们称为这个函数为常函数<br>常函数内不可以修改成员属性<br>成员属性声明时加关键字 mutable 后，在常函数中依然可以修改<br>常对象：</p>\n<p>声明对象前加 const 称该对象为常对象<br>常对象只能调用常函数<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>m_A = 0;<br>m_B = 0;<br>}</p>\n<pre><code>//this指针的本质是一个指针常量，指针的指向不可修改\n//如果想让指针指向的值也不可以修改，需要声明常函数\nvoid ShowPerson() const {\n    //const Type* const pointer;\n    //this = NULL; //不能修改指针的指向 Person* const this;\n    //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的\n\n    //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量\n    this-&gt;m_B = 100;\n}\n\nvoid MyFunc() const {\n    //mA = 10000;\n}</code></pre><p>public:<br>int m_A;<br>mutable int m_B; //可修改 可变的<br>};</p>\n<p>//const 修饰对象 常对象<br>void test01() {</p>\n<pre><code>const Person person; //常量对象\ncout &lt;&lt; person.m_A &lt;&lt; endl;\n//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问\nperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量\n\n//常对象访问成员函数\nperson.MyFunc(); //常对象不能调用const的函数</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.4 友元<br>生活中你的家有客厅(Public)，有你的卧室(Private)</p>\n<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>\n<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>\n<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>\n<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>\n<p>友元的关键字为 ==friend==</p>\n<p>友元的三种实现</p>\n<p>全局函数做友元<br>类做友元<br>成员函数做友元<br>4.4.1 全局函数做友元<br>C++<br>class Building<br>{<br>//告诉编译器 goodGay 全局函数 是 Building 类的好朋友，可以访问类中的私有内容<br>friend void goodGay(Building * building);</p>\n<p>public:</p>\n<pre><code>Building()\n{\n    this-&gt;m_SittingRoom = &quot;客厅&quot;;\n    this-&gt;m_BedRoom = &quot;卧室&quot;;\n}</code></pre><p>public:<br>string m_SittingRoom; //客厅</p>\n<p>private:<br>string m_BedRoom; //卧室<br>};</p>\n<p>void goodGay(Building * building)<br>{<br>cout &lt;&lt; “好基友正在访问： “ &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问： “ &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>Building b;<br>goodGay(&amp;b);<br>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.4.2 类做友元<br>C++<br>class Building;<br>class goodGay<br>{<br>public:</p>\n<pre><code>goodGay();\nvoid visit();</code></pre><p>private:<br>Building *building;<br>};</p>\n<p>class Building<br>{<br>//告诉编译器 goodGay 类是 Building 类的好朋友，可以访问到 Building 类中私有内容<br>friend class goodGay;</p>\n<p>public:<br>Building();</p>\n<p>public:<br>string m_SittingRoom; //客厅<br>private:<br>string m_BedRoom;//卧室<br>};</p>\n<p>Building::Building()<br>{<br>this-&gt;m_SittingRoom = “客厅”;<br>this-&gt;m_BedRoom = “卧室”;<br>}</p>\n<p>goodGay::goodGay()<br>{<br>building = new Building;<br>}</p>\n<p>void goodGay::visit()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>goodGay gg;<br>gg.visit();</p>\n<p>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.4.3 成员函数做友元<br>C++</p>\n<p>class Building;<br>class goodGay<br>{<br>public:</p>\n<pre><code>goodGay();\nvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\nvoid visit2();</code></pre><p>private:<br>Building *building;<br>};</p>\n<p>class Building<br>{<br>//告诉编译器 goodGay 类中的 visit 成员函数 是 Building 好朋友，可以访问私有内容<br>friend void goodGay::visit();</p>\n<p>public:<br>Building();</p>\n<p>public:<br>string m_SittingRoom; //客厅<br>private:<br>string m_BedRoom;//卧室<br>};</p>\n<p>Building::Building()<br>{<br>this-&gt;m_SittingRoom = “客厅”;<br>this-&gt;m_BedRoom = “卧室”;<br>}</p>\n<p>goodGay::goodGay()<br>{<br>building = new Building;<br>}</p>\n<p>void goodGay::visit()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void goodGay::visit2()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>//cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>goodGay gg;<br>gg.visit();</p>\n<p>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.5 运算符重载<br>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>\n<p>4.5.1 加号运算符重载<br>作用：实现两个自定义数据类型相加的运算</p>\n<p>C++<br>class Person {<br>public:<br>Person() {};<br>Person(int a, int b)<br>{<br>this-&gt;m_A = a;<br>this-&gt;m_B = b;<br>}<br>//成员函数实现 + 号运算符重载<br>Person operator+(const Person&amp; p) {<br>Person temp;<br>temp.m_A = this-&gt;m_A + p.m_A;<br>temp.m_B = this-&gt;m_B + p.m_B;<br>return temp;<br>}</p>\n<p>public:<br>int m_A;<br>int m_B;<br>};</p>\n<p>//全局函数实现 + 号运算符重载<br>//Person operator+(const Person&amp; p1, const Person&amp; p2) {<br>// Person temp(0, 0);<br>// temp.m_A = p1.m_A + p2.m_A;<br>// temp.m_B = p1.m_B + p2.m_B;<br>// return temp;<br>//}</p>\n<p>//运算符重载 可以发生函数重载<br>Person operator+(const Person&amp; p2, int val)<br>{<br>Person temp;<br>temp.m_A = p2.m_A + val;<br>temp.m_B = p2.m_B + val;<br>return temp;<br>}</p>\n<p>void test() {</p>\n<pre><code>Person p1(10, 10);\nPerson p2(20, 20);\n\n//成员函数方式\nPerson p3 = p2 + p1;  //相当于 p2.operaor+(p1)\ncout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;\n\n\nPerson p4 = p3 + 10; //相当于 operator+(p3,10)\ncout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结 1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>\n<p>总结 2：不要滥用运算符重载</p>\n<p>4.5.2 左移运算符重载<br>作用：可以输出自定义数据类型</p>\n<p>C++<br>class Person {<br>friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);</p>\n<p>public:</p>\n<pre><code>Person(int a, int b)\n{\n    this-&gt;m_A = a;\n    this-&gt;m_B = b;\n}\n\n//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果\n//void operator&lt;&lt;(Person&amp; p){\n//}</code></pre><p>private:<br>int m_A;<br>int m_B;<br>};</p>\n<p>//全局函数实现左移重载<br>//ostream 对象只能有一个<br>ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) {<br>out &lt;&lt; “a:” &lt;&lt; p.m_A &lt;&lt; “ b:” &lt;&lt; p.m_B;<br>return out;<br>}</p>\n<p>void test() {</p>\n<pre><code>Person p1(10, 20);\n\ncout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>\n<p>4.5.3 递增运算符重载<br>作用： 通过重载递增运算符，实现自己的整型数据</p>\n<p>C++</p>\n<p>class MyInteger {</p>\n<pre><code>friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);</code></pre><p>public:<br>MyInteger() {<br>m_Num = 0;<br>}<br>//前置++<br>MyInteger&amp; operator++() {<br>//先++<br>m_Num++;<br>//再返回<br>return *this;<br>}</p>\n<pre><code>//后置++\nMyInteger operator++(int) {\n    //先返回\n    MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；\n    m_Num++;\n    return temp;\n}</code></pre><p>private:<br>int m_Num;<br>};</p>\n<p>ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) {<br>out &lt;&lt; myint.m_Num;<br>return out;<br>}</p>\n<p>//前置++ 先++ 再返回<br>void test01() {<br>MyInteger myInt;<br>cout &lt;&lt; ++myInt &lt;&lt; endl;<br>cout &lt;&lt; myInt &lt;&lt; endl;<br>}</p>\n<p>//后置++ 先返回 再++<br>void test02() {</p>\n<pre><code>MyInteger myInt;\ncout &lt;&lt; myInt++ &lt;&lt; endl;\ncout &lt;&lt; myInt &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n//test02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 前置递增返回引用，后置递增返回值</p>\n<p>4.5.4 赋值运算符重载<br>c++编译器至少给一个类添加 4 个函数</p>\n<p>默认构造函数(无参，函数体为空)<br>默认析构函数(无参，函数体为空)<br>默认拷贝构造函数，对属性进行值拷贝<br>赋值运算符 operator=, 对属性进行值拷贝<br>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>\n<p>示例：</p>\n<p>C++<br>class Person<br>{<br>public:</p>\n<pre><code>Person(int age)\n{\n    //将年龄数据开辟到堆区\n    m_Age = new int(age);\n}\n\n//重载赋值运算符\nPerson&amp; operator=(Person &amp;p)\n{\n    if (m_Age != NULL)\n    {\n        delete m_Age;\n        m_Age = NULL;\n    }\n    //编译器提供的代码是浅拷贝\n    //m_Age = p.m_Age;\n\n    //提供深拷贝 解决浅拷贝的问题\n    m_Age = new int(*p.m_Age);\n\n    //返回自身\n    return *this;\n}\n\n\n~Person()\n{\n    if (m_Age != NULL)\n    {\n        delete m_Age;\n        m_Age = NULL;\n    }\n}\n\n//年龄的指针\nint *m_Age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>Person p1(18);</p>\n<pre><code>Person p2(20);\n\nPerson p3(30);\n\np3 = p2 = p1; //赋值操作\n\ncout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\n//int a = 10;\n//int b = 20;\n//int c = 30;\n\n//c = b = a;\n//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\n//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.5.5 关系运算符重载<br>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p>\n<p>示例：</p>\n<p>C++<br>class Person<br>{<br>public:<br>Person(string name, int age)<br>{<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>};</p>\n<pre><code>bool operator==(Person &amp; p)\n{\n    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nbool operator!=(Person &amp; p)\n{\n    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}\n\nstring m_Name;\nint m_Age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>//int a = 0;<br>//int b = 0;</p>\n<pre><code>Person a(&quot;孙悟空&quot;, 18);\nPerson b(&quot;孙悟空&quot;, 18);\n\nif (a == b)\n{\n    cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n}\n\nif (a != b)\n{\n    cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.5.6 函数调用运算符重载<br>函数调用运算符 () 也可以重载<br>由于重载后使用的方式非常像函数的调用，因此称为仿函数<br>仿函数没有固定写法，非常灵活<br>示例：</p>\n<p>C++<br>class MyPrint<br>{<br>public:<br>void operator()(string text)<br>{<br>cout &lt;&lt; text &lt;&lt; endl;<br>}</p>\n<p>};<br>void test01()<br>{<br>//重载的（）操作符 也称为仿函数<br>MyPrint myFunc;<br>myFunc(“hello world”);<br>}</p>\n<p>class MyAdd<br>{<br>public:<br>int operator()(int v1, int v2)<br>{<br>return v1 + v2;<br>}<br>};</p>\n<p>void test02()<br>{<br>MyAdd add;<br>int ret = add(10, 10);<br>cout &lt;&lt; “ret = “ &lt;&lt; ret &lt;&lt; endl;</p>\n<pre><code>//匿名对象调用\ncout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.6 继承<br>继承是面向对象三大特性之一</p>\n<p>有些类与类之间存在特殊的关系，例如下图中：</p>\n<p>1544861202252<br>1544861202252</p>\n<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>\n<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>\n<p>4.6.1 继承的基本语法<br>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>\n<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>\n<p>普通实现：</p>\n<p>C++<br>//Java 页面<br>class Java<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “JAVA 学科视频” &lt;&lt; endl;<br>}<br>};<br>//Python 页面<br>class Python<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “Python 学科视频” &lt;&lt; endl;<br>}<br>};<br>//C++页面<br>class CPP<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “C++学科视频” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//Java 页面<br>cout &lt;&lt; “Java 下载视频页面如下： “ &lt;&lt; endl;<br>Java ja;<br>ja.header();<br>ja.footer();<br>ja.left();<br>ja.content();<br>cout &lt;&lt; “——————–” &lt;&lt; endl;</p>\n<pre><code>//Python页面\ncout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\nPython py;\npy.header();\npy.footer();\npy.left();\npy.content();\ncout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n//C++页面\ncout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\nCPP cp;\ncp.header();\ncp.footer();\ncp.left();\ncp.content();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>继承实现：</p>\n<p>C++<br>//公共页面<br>class BasePage<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}</p>\n<pre><code>void footer()\n{\n    cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\n}\nvoid left()\n{\n    cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\n}</code></pre><p>};</p>\n<p>//Java 页面<br>class Java : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “JAVA 学科视频” &lt;&lt; endl;<br>}<br>};<br>//Python 页面<br>class Python : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “Python 学科视频” &lt;&lt; endl;<br>}<br>};<br>//C++页面<br>class CPP : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “C++学科视频” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//Java 页面<br>cout &lt;&lt; “Java 下载视频页面如下： “ &lt;&lt; endl;<br>Java ja;<br>ja.header();<br>ja.footer();<br>ja.left();<br>ja.content();<br>cout &lt;&lt; “——————–” &lt;&lt; endl;</p>\n<pre><code>//Python页面\ncout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\nPython py;\npy.header();\npy.footer();\npy.left();\npy.content();\ncout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n//C++页面\ncout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\nCPP cp;\ncp.header();\ncp.footer();\ncp.left();\ncp.content();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>继承的好处：==可以减少重复的代码==</p>\n<p>class A : public B;</p>\n<p>A 类称为子类 或 派生类</p>\n<p>B 类称为父类 或 基类</p>\n<p>派生类中的成员，包含两大部分：</p>\n<p>一类是从基类继承过来的，一类是自己增加的成员。</p>\n<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>\n<p>4.6.2 继承方式<br>继承的语法：class 子类 : 继承方式 父类</p>\n<p>继承方式一共有三种：</p>\n<p>公共继承<br>保护继承<br>私有继承<br>img<br>img</p>\n<p>示例：</p>\n<p>C++<br>class Base1<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};</p>\n<p>//公共继承<br>class Son1 :public Base1<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 public 权限<br>m_B; //可访问 protected 权限<br>//m_C; //不可访问<br>}<br>};</p>\n<p>void myClass()<br>{<br>Son1 s1;<br>s1.m_A; //其他类只能访问到公共权限<br>}</p>\n<p>//保护继承<br>class Base2<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};<br>class Son2:protected Base2<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 protected 权限<br>m_B; //可访问 protected 权限<br>//m_C; //不可访问<br>}<br>};<br>void myClass2()<br>{<br>Son2 s;<br>//s.m_A; //不可访问<br>}</p>\n<p>//私有继承<br>class Base3<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};<br>class Son3:private Base3<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 private 权限<br>m_B; //可访问 private 权限<br>//m_C; //不可访问<br>}<br>};<br>class GrandSon3 :public Son3<br>{<br>public:<br>void func()<br>{<br>//Son3 是私有继承，所以继承 Son3 的属性在 GrandSon3 中都无法访问到<br>//m_A;<br>//m_B;<br>//m_C;<br>}<br>};<br>4.6.3 继承中的对象模型<br>问题：从父类继承过来的成员，哪些属于子类对象中？</p>\n<p>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C; //私有成员只是被隐藏了，但是还是会继承下去<br>};</p>\n<p>//公共继承<br>class Son :public Base<br>{<br>public:<br>int m_D;<br>};</p>\n<p>void test01()<br>{<br>cout &lt;&lt; “sizeof Son = “ &lt;&lt; sizeof(Son) &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>利用工具查看：</p>\n<p>1545881904150<br>1545881904150</p>\n<p>打开工具窗口后，定位到当前 CPP 文件的盘符</p>\n<p>然后输入： cl /d1 reportSingleClassLayout 查看的类名 所属文件名</p>\n<p>效果如下图：</p>\n<p>1545882158050<br>1545882158050</p>\n<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>\n<p>4.6.4 继承中构造和析构顺序<br>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>\n<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>\n<p>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>Base()<br>{<br>cout &lt;&lt; “Base 构造函数!” &lt;&lt; endl;<br>}<br>~Base()<br>{<br>cout &lt;&lt; “Base 析构函数!” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Son : public Base<br>{<br>public:<br>Son()<br>{<br>cout &lt;&lt; “Son 构造函数!” &lt;&lt; endl;<br>}<br>~Son()<br>{<br>cout &lt;&lt; “Son 析构函数!” &lt;&lt; endl;<br>}</p>\n<p>};</p>\n<p>void test01()<br>{<br>//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反<br>Son s;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>\n<p>4.6.5 继承同名成员处理方式<br>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>\n<p>访问子类同名成员 直接访问即可<br>访问父类同名成员 需要加作用域<br>示例：</p>\n<p>C++<br>class Base {<br>public:<br>Base()<br>{<br>m_A = 100;<br>}</p>\n<pre><code>void func()\n{\n    cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;\n}\n\nvoid func(int a)\n{\n    cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;\n}</code></pre><p>public:<br>int m_A;<br>};</p>\n<p>class Son : public Base {<br>public:<br>Son()<br>{<br>m_A = 200;<br>}</p>\n<pre><code>//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\n//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\nvoid func()\n{\n    cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;\n}</code></pre><p>public:<br>int m_A;<br>};</p>\n<p>void test01()<br>{<br>Son s;</p>\n<pre><code>cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;\ncout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\n\ns.func();\ns.Base::func();\ns.Base::func(10);</code></pre><p>}<br>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn EXIT_SUCCESS;</code></pre><p>}<br>总结：</p>\n<p>子类对象可以直接访问到子类中同名成员<br>子类对象加作用域可以访问到父类同名成员<br>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数<br>4.6.6 继承同名静态成员处理方式<br>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>\n<p>静态成员和非静态成员出现同名，处理方式一致</p>\n<p>访问子类同名成员 直接访问即可<br>访问父类同名成员 需要加作用域<br>示例：</p>\n<p>C++<br>class Base {<br>public:<br>static void func()<br>{<br>cout &lt;&lt; “Base - static void func()” &lt;&lt; endl;<br>}<br>static void func(int a)<br>{<br>cout &lt;&lt; “Base - static void func(int a)” &lt;&lt; endl;<br>}</p>\n<pre><code>static int m_A;</code></pre><p>};</p>\n<p>int Base::m_A = 100;</p>\n<p>class Son : public Base {<br>public:<br>static void func()<br>{<br>cout &lt;&lt; “Son - static void func()” &lt;&lt; endl;<br>}<br>static int m_A;<br>};</p>\n<p>int Son::m_A = 200;</p>\n<p>//同名成员属性<br>void test01()<br>{<br>//通过对象访问<br>cout &lt;&lt; “通过对象访问： “ &lt;&lt; endl;<br>Son s;<br>cout &lt;&lt; “Son 下 m_A = “ &lt;&lt; s.m_A &lt;&lt; endl;<br>cout &lt;&lt; “Base 下 m_A = “ &lt;&lt; s.Base::m_A &lt;&lt; endl;</p>\n<pre><code>//通过类名访问\ncout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;\ncout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;</code></pre><p>}</p>\n<p>//同名成员函数<br>void test02()<br>{<br>//通过对象访问<br>cout &lt;&lt; “通过对象访问： “ &lt;&lt; endl;<br>Son s;<br>s.func();<br>s.Base::func();</p>\n<pre><code>cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\nSon::func();\nSon::Base::func();\n//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\nSon::Base::func(100);</code></pre><p>}<br>int main() {</p>\n<pre><code>//test01();\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>\n<p>4.6.7 多继承语法<br>C++允许一个类继承多个类</p>\n<p>语法：class 子类 ：继承方式 父类 1 ， 继承方式 父类 2…</p>\n<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>\n<p>C++实际开发中不建议用多继承</p>\n<p>示例：</p>\n<p>C++<br>class Base1 {<br>public:<br>Base1()<br>{<br>m_A = 100;<br>}<br>public:<br>int m_A;<br>};</p>\n<p>class Base2 {<br>public:<br>Base2()<br>{<br>m_A = 200; //开始是 m_B 不会出问题，但是改为 mA 就会出现不明确<br>}<br>public:<br>int m_A;<br>};</p>\n<p>//语法：class 子类：继承方式 父类 1 ，继承方式 父类 2<br>class Son : public Base2, public Base1<br>{<br>public:<br>Son()<br>{<br>m_C = 300;<br>m_D = 400;<br>}<br>public:<br>int m_C;<br>int m_D;<br>};</p>\n<p>//多继承容易产生成员同名的情况<br>//通过使用类名作用域可以区分调用哪一个基类的成员<br>void test01()<br>{<br>Son s;<br>cout &lt;&lt; “sizeof Son = “ &lt;&lt; sizeof(s) &lt;&lt; endl;<br>cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;<br>cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>\n<p>4.6.8 菱形继承<br>菱形继承概念：</p>\n<p>​ 两个派生类继承同一个基类</p>\n<p>​ 又有某个类同时继承者两个派生类</p>\n<p>​ 这种继承被称为菱形继承，或者钻石继承</p>\n<p>典型的菱形继承案例：</p>\n<p>IMG_256<br>IMG_256</p>\n<p>菱形继承问题：</p>\n<p>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</p>\n<p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>\n<p>示例：</p>\n<p>C++<br>class Animal<br>{<br>public:<br>int m_Age;<br>};</p>\n<p>//继承前加 virtual 关键字后，变为虚继承<br>//此时公共的父类 Animal 称为虚基类<br>class Sheep : virtual public Animal {};<br>class Tuo : virtual public Animal {};<br>class SheepTuo : public Sheep, public Tuo {};</p>\n<p>void test01()<br>{<br>SheepTuo st;<br>st.Sheep::m_Age = 100;<br>st.Tuo::m_Age = 200;</p>\n<pre><code>cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;\ncout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;\ncout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义<br>利用虚继承可以解决菱形继承问题<br>4.7 多态<br>4.7.1 多态的基本概念<br>多态是 C++面向对象三大特性之一</p>\n<p>多态分为两类</p>\n<p>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名<br>动态多态: 派生类和虚函数实现运行时多态<br>静态多态和动态多态区别：</p>\n<p>静态多态的函数地址早绑定 - 编译阶段确定函数地址<br>动态多态的函数地址晚绑定 - 运行阶段确定函数地址<br>下面通过案例进行讲解多态</p>\n<p>C++<br>class Animal<br>{<br>public:<br>//Speak 函数就是虚函数<br>//函数前面加上 virtual 关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。<br>virtual void speak()<br>{<br>cout &lt;&lt; “动物在说话” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Cat :public Animal<br>{<br>public:<br>void speak()<br>{<br>cout &lt;&lt; “小猫在说话” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Dog :public Animal<br>{<br>public:</p>\n<pre><code>void speak()\n{\n    cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;\n}</code></pre><p>};<br>//我们希望传入什么对象，那么就调用什么对象的函数<br>//如果函数地址在编译阶段就能确定，那么静态联编<br>//如果函数地址在运行阶段才能确定，就是动态联编</p>\n<p>void DoSpeak(Animal &amp; animal)<br>{<br>animal.speak();<br>}<br>//<br>//多态满足条件：<br>//1、有继承关系<br>//2、子类重写父类中的虚函数<br>//多态使用：<br>//父类指针或引用指向子类对象</p>\n<p>void test01()<br>{<br>Cat cat;<br>DoSpeak(cat);</p>\n<pre><code>Dog dog;\nDoSpeak(dog);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>多态满足条件</p>\n<p>有继承关系<br>子类重写父类中的虚函数<br>多态使用条件</p>\n<p>父类指针或引用指向子类对象<br>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p>\n<p>4.7.2 多态案例一-计算器类<br>案例描述：</p>\n<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>\n<p>多态的优点：</p>\n<p>代码组织结构清晰<br>可读性强<br>利于前期和后期的扩展以及维护<br>示例：</p>\n<p>C++<br>//普通实现<br>class Calculator {<br>public:<br>int getResult(string oper)<br>{<br>if (oper == “+”) {<br>return m_Num1 + m_Num2;<br>}<br>else if (oper == “-“) {<br>return m_Num1 - m_Num2;<br>}<br>else if (oper == “_”) {<br>return m_Num1 _ m_Num2;<br>}<br>//如果要提供新的运算，需要修改源码<br>}<br>public:<br>int m_Num1;<br>int m_Num2;<br>};</p>\n<p>void test01()<br>{<br>//普通实现测试<br>Calculator c;<br>c.m_Num1 = 10;<br>c.m_Num2 = 10;<br>cout &lt;&lt; c.m_Num1 &lt;&lt; “ + “ &lt;&lt; c.m_Num2 &lt;&lt; “ = “ &lt;&lt; c.getResult(“+”) &lt;&lt; endl;</p>\n<pre><code>cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;\n\ncout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;</code></pre><p>}</p>\n<p>//多态实现<br>//抽象计算器类<br>//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护<br>class AbstractCalculator<br>{<br>public :</p>\n<pre><code>virtual int getResult()\n{\n    return 0;\n}\n\nint m_Num1;\nint m_Num2;</code></pre><p>};</p>\n<p>//加法计算器<br>class AddCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 + m_Num2;<br>}<br>};</p>\n<p>//减法计算器<br>class SubCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 - m_Num2;<br>}<br>};</p>\n<p>//乘法计算器<br>class MulCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 * m_Num2;<br>}<br>};</p>\n<p>void test02()<br>{<br>//创建加法计算器<br>AbstractCalculator *abc = new AddCalculator;<br>abc-&gt;m_Num1 = 10;<br>abc-&gt;m_Num2 = 10;<br>cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; “ + “ &lt;&lt; abc-&gt;m_Num2 &lt;&lt; “ = “ &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;<br>delete abc; //用完了记得销毁</p>\n<pre><code>//创建减法计算器\nabc = new SubCalculator;\nabc-&gt;m_Num1 = 10;\nabc-&gt;m_Num2 = 10;\ncout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\ndelete abc;\n\n//创建乘法计算器\nabc = new MulCalculator;\nabc-&gt;m_Num1 = 10;\nabc-&gt;m_Num2 = 10;\ncout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\ndelete abc;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>\n<p>4.7.3 纯虚函数和抽象类<br>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>\n<p>因此可以将虚函数改为纯虚函数</p>\n<p>纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ;</p>\n<p>当类中有了纯虚函数，这个类也称为==抽象类==</p>\n<p>抽象类特点：</p>\n<p>无法实例化对象<br>子类必须重写抽象类中的纯虚函数，否则也属于抽象类<br>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>//纯虚函数<br>//类中只要有一个纯虚函数就称为抽象类<br>//抽象类无法实例化对象<br>//子类必须重写父类中的纯虚函数，否则也属于抽象类<br>virtual void func() = 0;<br>};</p>\n<p>class Son :public Base<br>{<br>public:<br>virtual void func()<br>{<br>cout &lt;&lt; “func 调用” &lt;&lt; endl;<br>};<br>};</p>\n<p>void test01()<br>{<br>Base * base = NULL;<br>//base = new Base; // 错误，抽象类无法实例化对象<br>base = new Son;<br>base-&gt;func();<br>delete base;//记得销毁<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.7.4 多态案例二-制作饮品<br>案例描述：</p>\n<p>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</p>\n<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>\n<p>1545985945198<br>1545985945198</p>\n<p>示例：</p>\n<p>C++<br>//抽象制作饮品<br>class AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() = 0;<br>//冲泡<br>virtual void Brew() = 0;<br>//倒入杯中<br>virtual void PourInCup() = 0;<br>//加入辅料<br>virtual void PutSomething() = 0;<br>//规定流程<br>void MakeDrink() {<br>Boil();<br>Brew();<br>PourInCup();<br>PutSomething();<br>}<br>};</p>\n<p>//制作咖啡<br>class Coffee : public AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() {<br>cout &lt;&lt; “煮农夫山泉!” &lt;&lt; endl;<br>}<br>//冲泡<br>virtual void Brew() {<br>cout &lt;&lt; “冲泡咖啡!” &lt;&lt; endl;<br>}<br>//倒入杯中<br>virtual void PourInCup() {<br>cout &lt;&lt; “将咖啡倒入杯中!” &lt;&lt; endl;<br>}<br>//加入辅料<br>virtual void PutSomething() {<br>cout &lt;&lt; “加入牛奶!” &lt;&lt; endl;<br>}<br>};</p>\n<p>//制作茶水<br>class Tea : public AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() {<br>cout &lt;&lt; “煮自来水!” &lt;&lt; endl;<br>}<br>//冲泡<br>virtual void Brew() {<br>cout &lt;&lt; “冲泡茶叶!” &lt;&lt; endl;<br>}<br>//倒入杯中<br>virtual void PourInCup() {<br>cout &lt;&lt; “将茶水倒入杯中!” &lt;&lt; endl;<br>}<br>//加入辅料<br>virtual void PutSomething() {<br>cout &lt;&lt; “加入枸杞!” &lt;&lt; endl;<br>}<br>};</p>\n<p>//业务函数<br>void DoWork(AbstractDrinking* drink) {<br>drink-&gt;MakeDrink();<br>delete drink;<br>}</p>\n<p>void test01() {<br>DoWork(new Coffee);<br>cout &lt;&lt; “————–” &lt;&lt; endl;<br>DoWork(new Tea);<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.7.5 虚析构和纯虚析构<br>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>\n<p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p>\n<p>虚析构和纯虚析构共性：</p>\n<p>可以解决父类指针释放子类对象<br>都需要有具体的函数实现<br>虚析构和纯虚析构区别：</p>\n<p>如果是纯虚析构，该类属于抽象类，无法实例化对象<br>虚析构语法：</p>\n<p>virtual ~类名(){}</p>\n<p>纯虚析构语法：</p>\n<p>virtual ~类名() = 0;</p>\n<p>类名::~类名(){}</p>\n<p>示例：</p>\n<p>C++<br>class Animal {<br>public:</p>\n<pre><code>Animal()\n{\n    cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;\n}\nvirtual void Speak() = 0;\n\n//析构函数加上virtual关键字，变成虚析构函数\n//virtual ~Animal()\n//{\n//    cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;\n//}\n\n\nvirtual ~Animal() = 0;</code></pre><p>};</p>\n<p>Animal::~Animal()<br>{<br>cout &lt;&lt; “Animal 纯虚析构函数调用！” &lt;&lt; endl;<br>}</p>\n<p>//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</p>\n<p>class Cat : public Animal {<br>public:<br>Cat(string name)<br>{<br>cout &lt;&lt; “Cat 构造函数调用！” &lt;&lt; endl;<br>m_Name = new string(name);<br>}<br>virtual void Speak()<br>{<br>cout &lt;&lt; *m_Name &lt;&lt; “小猫在说话!” &lt;&lt; endl;<br>}<br>~Cat()<br>{<br>cout &lt;&lt; “Cat 析构函数调用!” &lt;&lt; endl;<br>if (this-&gt;m_Name != NULL) {<br>delete m_Name;<br>m_Name = NULL;<br>}<br>}</p>\n<p>public:<br>string *m_Name;<br>};</p>\n<p>void test01()<br>{<br>Animal *animal = new Cat(“Tom”);<br>animal-&gt;Speak();</p>\n<pre><code>//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\n//怎么解决？给基类增加一个虚析构函数\n//虚析构函数就是用来解决通过父类指针释放子类对象\ndelete animal;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>\n<p>​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>\n<p>​ 3. 拥有纯虚析构函数的类也属于抽象类</p>\n<p>4.7.6 多态案例三-电脑组装<br>案例描述：</p>\n<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>\n<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如 Intel 厂商和 Lenovo 厂商</p>\n<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>\n<p>测试时组装三台不同的电脑进行工作</p>\n<p>示例：</p>\n<p>C++<br>#include<iostream><br>using namespace std;</p>\n<p>//抽象 CPU 类<br>class CPU<br>{<br>public:<br>//抽象的计算函数<br>virtual void calculate() = 0;<br>};</p>\n<p>//抽象显卡类<br>class VideoCard<br>{<br>public:<br>//抽象的显示函数<br>virtual void display() = 0;<br>};</p>\n<p>//抽象内存条类<br>class Memory<br>{<br>public:<br>//抽象的存储函数<br>virtual void storage() = 0;<br>};</p>\n<p>//电脑类<br>class Computer<br>{<br>public:<br>Computer(CPU _ cpu, VideoCard _ vc, Memory * mem)<br>{<br>m_cpu = cpu;<br>m_vc = vc;<br>m_mem = mem;<br>}</p>\n<pre><code>//提供工作的函数\nvoid work()\n{\n    //让零件工作起来，调用接口\n    m_cpu-&gt;calculate();\n\n    m_vc-&gt;display();\n\n    m_mem-&gt;storage();\n}\n\n//提供析构函数 释放3个电脑零件\n~Computer()\n{\n\n    //释放CPU零件\n    if (m_cpu != NULL)\n    {\n        delete m_cpu;\n        m_cpu = NULL;\n    }\n\n    //释放显卡零件\n    if (m_vc != NULL)\n    {\n        delete m_vc;\n        m_vc = NULL;\n    }\n\n    //释放内存条零件\n    if (m_mem != NULL)\n    {\n        delete m_mem;\n        m_mem = NULL;\n    }\n}</code></pre><p>private:</p>\n<pre><code>CPU * m_cpu; //CPU的零件指针\nVideoCard * m_vc; //显卡零件指针\nMemory * m_mem; //内存条零件指针</code></pre><p>};</p>\n<p>//具体厂商<br>//Intel 厂商<br>class IntelCPU :public CPU<br>{<br>public:<br>virtual void calculate()<br>{<br>cout &lt;&lt; “Intel 的 CPU 开始计算了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class IntelVideoCard :public VideoCard<br>{<br>public:<br>virtual void display()<br>{<br>cout &lt;&lt; “Intel 的显卡开始显示了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class IntelMemory :public Memory<br>{<br>public:<br>virtual void storage()<br>{<br>cout &lt;&lt; “Intel 的内存条开始存储了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>//Lenovo 厂商<br>class LenovoCPU :public CPU<br>{<br>public:<br>virtual void calculate()<br>{<br>cout &lt;&lt; “Lenovo 的 CPU 开始计算了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class LenovoVideoCard :public VideoCard<br>{<br>public:<br>virtual void display()<br>{<br>cout &lt;&lt; “Lenovo 的显卡开始显示了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class LenovoMemory :public Memory<br>{<br>public:<br>virtual void storage()<br>{<br>cout &lt;&lt; “Lenovo 的内存条开始存储了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//第一台电脑零件<br>CPU _ intelCpu = new IntelCPU;<br>VideoCard _ intelCard = new IntelVideoCard;<br>Memory * intelMem = new IntelMemory;</p>\n<pre><code>cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;\n//创建第一台电脑\nComputer * computer1 = new Computer(intelCpu, intelCard, intelMem);\ncomputer1-&gt;work();\ndelete computer1;\n\ncout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;\n//第二台电脑组装\nComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\ncomputer2-&gt;work();\ndelete computer2;\n\ncout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;\n//第三台电脑组装\nComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\ncomputer3-&gt;work();\ndelete computer3;</code></pre><p>}<br>5 文件操作<br>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>\n<p>通过文件可以将数据持久化</p>\n<p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p>\n<p>文件类型分为两种：</p>\n<p>文本文件 - 文件以文本的 ASCII 码形式存储在计算机中<br>二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们<br>操作文件的三大类:</p>\n<p>ofstream：写操作<br>ifstream： 读操作<br>fstream ： 读写操作<br>5.1 文本文件<br>5.1.1 写文件<br>写文件步骤如下：</p>\n<p>包含头文件</p>\n<p>#include <fstream></p>\n<p>创建流对象</p>\n<p>ofstream ofs;</p>\n<p>打开文件</p>\n<p>ofs.open(“文件路径”,打开方式);</p>\n<p>写数据</p>\n<p>ofs &lt;&lt; “写入的数据”;</p>\n<p>关闭文件</p>\n<p>ofs.close();</p>\n<p>文件打开方式：</p>\n<p>打开方式 解释<br>ios::in 为读文件而打开文件<br>ios::out 为写文件而打开文件<br>ios::ate 初始位置：文件尾<br>ios::app 追加方式写文件<br>ios::trunc 如果文件存在先删除，再创建<br>ios::binary 二进制方式<br>注意： 文件打开方式可以配合使用，利用|操作符</p>\n<p>例如：用二进制方式写文件 ios::binary | ios:: out</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream></p>\n<p>void test01()<br>{<br>ofstream ofs;<br>ofs.open(“test.txt”, ios::out);</p>\n<pre><code>ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;\nofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;\nofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;\n\nofs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>文件操作必须包含头文件 fstream<br>读文件可以利用 ofstream ，或者 fstream 类<br>打开文件时候需要指定操作文件的路径，以及打开方式<br>利用&lt;&lt;可以向文件中写数据<br>操作完毕，要关闭文件<br>5.1.2 读文件<br>读文件与写文件步骤相似，但是读取方式相对于比较多</p>\n<p>读文件步骤如下：</p>\n<p>包含头文件</p>\n<p>#include <fstream></p>\n<p>创建流对象</p>\n<p>ifstream ifs;</p>\n<p>打开文件并判断文件是否打开成功</p>\n<p>ifs.open(“文件路径”,打开方式);</p>\n<p>读数据</p>\n<p>四种方式读取</p>\n<p>关闭文件</p>\n<p>ifs.close();</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string><br>void test01()<br>{<br>ifstream ifs;<br>ifs.open(“test.txt”, ios::in);</p>\n<pre><code>if (!ifs.is_open())\n{\n    cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;\n    return;\n}\n\n//第一种方式\n//char buf[1024] = { 0 };\n//while (ifs &gt;&gt; buf)\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\n//第二种\n//char buf[1024] = { 0 };\n//while (ifs.getline(buf,sizeof(buf)))\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\n//第三种\n//string buf;\n//while (getline(ifs, buf))\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\nchar c;\nwhile ((c = ifs.get()) != EOF)\n{\n    cout &lt;&lt; c;\n}\n\nifs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>读文件可以利用 ifstream ，或者 fstream 类<br>利用 is_open 函数可以判断文件是否打开成功<br>close 关闭文件<br>5.2 二进制文件<br>以二进制的方式对文件进行读写操作</p>\n<p>打开方式要指定为 ==ios::binary==</p>\n<p>5.2.1 写文件<br>二进制方式写文件主要利用流对象调用成员函数 write</p>\n<p>函数原型 ：ostream&amp; write(const char * buffer,int len);</p>\n<p>参数解释：字符指针 buffer 指向内存中一段存储空间。len 是读写的字节数</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string></p>\n<p>class Person<br>{<br>public:<br>char m_Name[64];<br>int m_Age;<br>};</p>\n<p>//二进制文件 写文件<br>void test01()<br>{<br>//1、包含头文件</p>\n<pre><code>//2、创建输出流对象\nofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary);\n\n//3、打开文件\n//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);\n\nPerson p = {&quot;张三&quot;  , 18};\n\n//4、写文件\nofs.write((const char *)&amp;p, sizeof(p));\n\n//5、关闭文件\nofs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>文件输出流对象 可以通过 write 函数，以二进制方式写数据<br>5.2.2 读文件<br>二进制方式读文件主要利用流对象调用成员函数 read</p>\n<p>函数原型：istream&amp; read(char *buffer,int len);</p>\n<p>参数解释：字符指针 buffer 指向内存中一段存储空间。len 是读写的字节数</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string></p>\n<p>class Person<br>{<br>public:<br>char m_Name[64];<br>int m_Age;<br>};</p>\n<p>void test01()<br>{<br>ifstream ifs(“person.txt”, ios::in | ios::binary);<br>if (!ifs.is_open())<br>{<br>cout &lt;&lt; “文件打开失败” &lt;&lt; endl;<br>}</p>\n<pre><code>Person p;\nifs.read((char *)&amp;p, sizeof(p));\n\ncout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>文件输入流对象 可以通过 read 函数，以二进制方式读数据</p>\n"},{"title":"A first look at C++ (2) copy","url":"/2023/01/18/A%20first%20look%20at%20C++%20(2)%20copy/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>C++核心编程<br>本阶段主要针对 C++==面向对象==编程技术做详细讲解，探讨 C++中的核心和精髓。</p>\n<p>1 内存分区模型<br>C++程序在执行时，将内存大方向划分为 4 个区域</p>\n<p>代码区：存放函数体的二进制代码，由操作系统进行管理的<br>全局区：存放全局变量和静态变量以及常量<br>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等<br>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收<br>内存四区意义：</p>\n<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>\n<p>1.1 程序运行前<br>​ 在程序编译后，生成了 exe 可执行程序，未执行该程序前分为两个区域</p>\n<p>​ 代码区：</p>\n<p>​ 存放 CPU 执行的机器指令</p>\n<p>​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>\n<p>​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令</p>\n<p>​ 全局区：</p>\n<p>​ 全局变量和静态变量存放在此.</p>\n<p>​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>\n<p>​ ==该区域的数据在程序结束后由操作系统释放==.</p>\n<p>示例：</p>\n<p>C++<br>//全局变量<br>int g_a = 10;<br>int g_b = 10;</p>\n<p>//全局常量<br>const int c_g_a = 10;<br>const int c_g_b = 10;</p>\n<p>int main() {</p>\n<pre><code>//局部变量\nint a = 10;\nint b = 10;\n\n//打印地址\ncout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;\ncout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;\n\ncout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt;  (int)&amp;g_a &lt;&lt; endl;\ncout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt;  (int)&amp;g_b &lt;&lt; endl;\n\n//静态变量\nstatic int s_a = 10;\nstatic int s_b = 10;\n\ncout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;\ncout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;\n\ncout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;\n\ncout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;\ncout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;\n\nconst int c_l_a = 10;\nconst int c_l_b = 10;\ncout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;\ncout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>打印结果：</p>\n<p>1545017602518<br>1545017602518</p>\n<p>总结：</p>\n<p>C++中在程序运行前分为全局区和代码区<br>代码区特点是共享和只读<br>全局区中存放全局变量、静态变量、常量<br>常量区中存放 const 修饰的全局常量 和 字符串常量<br>1.2 程序运行后<br>​ 栈区：</p>\n<p>​ 由编译器自动分配释放, 存放函数的参数值,局部变量等</p>\n<p>​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>\n<p>示例：</p>\n<p>C++<br>int * func()<br>{<br>int a = 10;<br>return &a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>​ 堆区：</p>\n<p>​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>\n<p>​ 在 C++中主要利用 new 在堆区开辟内存</p>\n<p>示例：</p>\n<p>C++<br>int* func()<br>{<br>int* a = new int(10);<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>堆区数据由程序员管理开辟和释放</p>\n<p>堆区数据利用 new 关键字进行开辟内存</p>\n<p>1.3 new 操作符<br>​ C++中利用==new==操作符在堆区开辟数据</p>\n<p>​ 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p>\n<p>​ 语法：new 数据类型</p>\n<p>​ 利用 new 创建的数据，会返回该数据对应的类型的指针</p>\n<p>示例 1： 基本语法</p>\n<p>C++<br>int* func()<br>{<br>int* a = new int(10);<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\n//利用delete释放堆区数据\ndelete p;\n\n//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：开辟数组</p>\n<p>C++<br>//堆区开辟数组<br>int main() {</p>\n<pre><code>int* arr = new int[10];\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    arr[i] = i + 100;\n}\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    cout &lt;&lt; arr[i] &lt;&lt; endl;\n}\n//释放数组 delete 后加 []\ndelete[] arr;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2 引用<br>2.1 引用的基本使用<br>*作用： *给变量起别名</p>\n<p>语法： 数据类型 &amp;别名 = 原名</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int a = 10;\nint &amp;b = a;\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n\nb = 100;\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2.2 引用注意事项<br>引用必须初始化<br>引用在初始化后，不可以改变<br>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int a = 10;\nint b = 20;\n//int &amp;c; //错误，引用必须初始化\nint &amp;c = a; //一旦初始化后，就不可以更改\nc = b; //这是赋值操作，不是更改引用\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\ncout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2.3 引用做函数参数<br>作用：函数传参时，可以利用引用的技术让形参修饰实参</p>\n<p>优点：可以简化指针修改实参</p>\n<p>示例：</p>\n<p>C++<br>//1. 值传递<br>void mySwap01(int a, int b) {<br>int temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>//2. 地址传递<br>void mySwap02(int* a, int* b) {<br>int temp = *a;<br>*a = *b;<br>*b = temp;<br>}</p>\n<p>//3. 引用传递<br>void mySwap03(int&amp; a, int&amp; b) {<br>int temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>int main() {</p>\n<pre><code>int a = 10;\nint b = 20;\n\nmySwap01(a, b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nmySwap02(&amp;a, &amp;b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nmySwap03(a, b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>\n<p>2.4 引用做函数返回值<br>作用：引用是可以作为函数的返回值存在的</p>\n<p>注意：不要返回局部变量引用</p>\n<p>用法：函数调用作为左值</p>\n<p>示例：</p>\n<p>C++<br>//返回局部变量引用<br>int&amp; test01() {<br>int a = 10; //局部变量<br>return a;<br>}</p>\n<p>//返回静态变量引用<br>int&amp; test02() {<br>static int a = 20;<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>//不能返回局部变量的引用\nint&amp; ref = test01();\ncout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\ncout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\n\n//如果函数做左值，那么必须返回引用\nint&amp; ref2 = test02();\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\ntest02() = 1000;\n\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>​</p>\n<p>2.5 引用的本质<br>本质：引用的本质在 c++内部实现是一个指针常量.</p>\n<p>讲解示例：</p>\n<p>C++<br>//发现是引用，转换为 int* const ref = &a;<br>void func(int&amp; ref){<br>ref = 100; // ref 是引用，转换为*ref = 100<br>}<br>int main(){<br>int a = 10;</p>\n<pre><code>//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改\nint&amp; ref = a;\nref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\n\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;\n\nfunc(a);\nreturn 0;</code></pre><p>}<br>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>\n<p>2.6 常量引用<br>作用：常量引用主要用来修饰形参，防止误操作</p>\n<p>在函数形参列表中，可以加==const 修饰形参==，防止形参改变实参</p>\n<p>示例：</p>\n<p>C++<br>//引用使用的场景，通常用来修饰形参<br>void showValue(const int&amp; v) {<br>//v += 10;<br>cout &lt;&lt; v &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误\n//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;\nconst int&amp; ref = 10;\n\n//ref = 100;  //加入const后不可以修改变量\ncout &lt;&lt; ref &lt;&lt; endl;\n\n//函数中利用常量引用防止误操作修改实参\nint a = 10;\nshowValue(a);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3 函数提高<br>3.1 函数默认参数<br>在 C++中，函数的形参列表中的形参是可以有默认值的。</p>\n<p>语法：返回值类型 函数名 （参数= 默认值）{}</p>\n<p>示例：</p>\n<p>C++<br>int func(int a, int b = 10, int c = 10) {<br>return a + b + c;<br>}</p>\n<p>//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值<br>//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数<br>int func2(int a = 10, int b = 10);<br>int func2(int a, int b) {<br>return a + b;<br>}</p>\n<p>int main() {</p>\n<pre><code>cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;\ncout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.2 函数占位参数<br>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>\n<p>语法： 返回值类型 函数名 (数据类型){}</p>\n<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>\n<p>示例：</p>\n<p>C++<br>//函数占位参数 ，占位参数也可以有默认参数<br>void func(int a, int) {<br>cout &lt;&lt; “this is func” &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>func(10,10); //占位参数必须填补\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.3 函数重载<br>3.3.1 函数重载概述<br>作用：函数名可以相同，提高复用性</p>\n<p>函数重载满足条件：</p>\n<p>同一个作用域下<br>函数名称相同<br>函数参数类型不同 或者 个数不同 或者 顺序不同<br>注意: 函数的返回值不可以作为函数重载的条件</p>\n<p>示例：</p>\n<p>C++<br>//函数重载需要函数都在同一个作用域下<br>void func()<br>{<br>cout &lt;&lt; “func 的调用！” &lt;&lt; endl;<br>}<br>void func(int a)<br>{<br>cout &lt;&lt; “func (int a) 的调用！” &lt;&lt; endl;<br>}<br>void func(double a)<br>{<br>cout &lt;&lt; “func (double a)的调用！” &lt;&lt; endl;<br>}<br>void func(int a ,double b)<br>{<br>cout &lt;&lt; “func (int a ,double b) 的调用！” &lt;&lt; endl;<br>}<br>void func(double a ,int b)<br>{<br>cout &lt;&lt; “func (double a ,int b)的调用！” &lt;&lt; endl;<br>}</p>\n<p>//函数返回值不可以作为函数重载条件<br>//int func(double a, int b)<br>//{<br>// cout &lt;&lt; “func (double a ,int b)的调用！” &lt;&lt; endl;<br>//}</p>\n<p>int main() {</p>\n<pre><code>func();\nfunc(10);\nfunc(3.14);\nfunc(10,3.14);\nfunc(3.14 , 10);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.3.2 函数重载注意事项<br>引用作为重载条件<br>函数重载碰到函数默认参数<br>示例：</p>\n<p>C++<br>//函数重载注意事项<br>//1、引用作为重载条件</p>\n<p>void func(int &amp;a)<br>{<br>cout &lt;&lt; “func (int &amp;a) 调用 “ &lt;&lt; endl;<br>}</p>\n<p>void func(const int &amp;a)<br>{<br>cout &lt;&lt; “func (const int &amp;a) 调用 “ &lt;&lt; endl;<br>}</p>\n<p>//2、函数重载碰到函数默认参数</p>\n<p>void func2(int a, int b = 10)<br>{<br>cout &lt;&lt; “func2(int a, int b = 10) 调用” &lt;&lt; endl;<br>}</p>\n<p>void func2(int a)<br>{<br>cout &lt;&lt; “func2(int a) 调用” &lt;&lt; endl;<br>}</p>\n<p>int main() {<br>int a = 10;<br>func(a); //调用无 const<br>func(10);//调用有 const</p>\n<pre><code>//func2(10); //碰到默认参数产生歧义，需要避免\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4 类和对象<br>C++面向对象的三大特性为：==封装、继承、多态==</p>\n<p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p>\n<p>例如：</p>\n<p>​ 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>\n<p>​ 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>\n<p>​ 具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p>\n<p>4.1 封装<br>4.1.1 封装的意义<br>封装是 C++面向对象三大特性之一</p>\n<p>封装的意义：</p>\n<p>将属性和行为作为一个整体，表现生活中的事物<br>将属性和行为加以权限控制<br>封装意义一：</p>\n<p>​ 在设计类的时候，属性和行为写在一起，表现事物</p>\n<p>语法： class 类名{ 访问权限： 属性 / 行为 };</p>\n<p>示例 1：设计一个圆类，求圆的周长</p>\n<p>示例代码：</p>\n<p>C++<br>//圆周率<br>const double PI = 3.14;</p>\n<p>//1、封装的意义<br>//将属性和行为作为一个整体，用来表现生活中的事物</p>\n<p>//封装一个圆类，求圆的周长<br>//class 代表设计一个类，后面跟着的是类名<br>class Circle<br>{<br>public: //访问权限 公共的权限</p>\n<pre><code>//属性\nint m_r;//半径\n\n//行为\n//获取到圆的周长\ndouble calculateZC()\n{\n    //2 * pi  * r\n    //获取圆的周长\n    return  2 * PI * m_r;\n}</code></pre><p>};</p>\n<p>int main() {</p>\n<pre><code>//通过圆类，创建圆的对象\n// c1就是一个具体的圆\nCircle c1;\nc1.m_r = 10; //给圆对象的半径 进行赋值操作\n\n//2 * pi * 10 = = 62.8\ncout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>\n<p>示例 2 代码：</p>\n<p>C++<br>//学生类<br>class Student {<br>public:<br>void setName(string name) {<br>m_name = name;<br>}<br>void setID(int id) {<br>m_id = id;<br>}</p>\n<pre><code>void showStudent() {\n    cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;\n}</code></pre><p>public:<br>string m_name;<br>int m_id;<br>};</p>\n<p>int main() {</p>\n<pre><code>Student stu;\nstu.setName(&quot;德玛西亚&quot;);\nstu.setID(250);\nstu.showStudent();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>封装意义二：</p>\n<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>\n<p>访问权限有三种：</p>\n<p>public 公共权限<br>protected 保护权限<br>private 私有权限<br>示例：</p>\n<p>C++<br>//三种权限<br>//公共权限 public 类内可以访问 类外可以访问<br>//保护权限 protected 类内可以访问 类外不可以访问<br>//私有权限 private 类内可以访问 类外不可以访问</p>\n<p>class Person<br>{<br>//姓名 公共权限<br>public:<br>string m_Name;</p>\n<pre><code>//汽车  保护权限</code></pre><p>protected:<br>string m_Car;</p>\n<pre><code>//银行卡密码  私有权限</code></pre><p>private:<br>int m_Password;</p>\n<p>public:<br>void func()<br>{<br>m_Name = “张三”;<br>m_Car = “拖拉机”;<br>m_Password = 123456;<br>}<br>};</p>\n<p>int main() {</p>\n<pre><code>Person p;\np.m_Name = &quot;李四&quot;;\n//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到\n//p.m_Password = 123; //私有权限类外访问不到\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.1.2 struct 和 class 区别<br>在 C++中 struct 和 class 唯一的区别就在于 默认的访问权限不同</p>\n<p>区别：</p>\n<p>struct 默认权限为公共<br>class 默认权限为私有<br>C++<br>class C1<br>{<br>int m_A; //默认是私有权限<br>};</p>\n<p>struct C2<br>{<br>int m_A; //默认是公共权限<br>};</p>\n<p>int main() {</p>\n<pre><code>C1 c1;\nc1.m_A = 10; //错误，访问权限是私有\n\nC2 c2;\nc2.m_A = 10; //正确，访问权限是公共\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.1.3 成员属性设置为私有<br>优点 1：将所有成员属性设置为私有，可以自己控制读写权限</p>\n<p>优点 2：对于写权限，我们可以检测数据的有效性</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:</p>\n<pre><code>//姓名设置可读可写\nvoid setName(string name) {\n    m_Name = name;\n}\nstring getName()\n{\n    return m_Name;\n}\n\n\n//获取年龄\nint getAge() {\n    return m_Age;\n}\n//设置年龄\nvoid setAge(int age) {\n    if (age &lt; 0 || age &gt; 150) {\n        cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;\n        return;\n    }\n    m_Age = age;\n}\n\n//情人设置为只写\nvoid setLover(string lover) {\n    m_Lover = lover;\n}</code></pre><p>private:<br>string m_Name; //可读可写 姓名<br>int m_Age; //只读 年龄</p>\n<pre><code>string m_Lover; //只写  情人</code></pre><p>};</p>\n<p>int main() {</p>\n<pre><code>Person p;\n//姓名设置\np.setName(&quot;张三&quot;);\ncout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;\n\n//年龄设置\np.setAge(50);\ncout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;\n\n//情人设置\np.setLover(&quot;苍井&quot;);\n//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>练习案例 1：设计立方体类</p>\n<p>设计立方体类(Cube)</p>\n<p>求出立方体的面积和体积</p>\n<p>分别用全局函数和成员函数判断两个立方体是否相等。</p>\n<p>1545533548532<br>1545533548532</p>\n<p>练习案例 2：点和圆的关系</p>\n<p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p>\n<p>1545533829184<br>1545533829184</p>\n<p>4.2 对象的初始化和清理<br>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全<br>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。<br>4.2.1 构造函数和析构函数<br>对象的初始化和清理也是两个非常重要的安全问题</p>\n<p>​ 一个对象或者变量没有初始状态，对其使用后果是未知</p>\n<p>​ 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>\n<p>c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>\n<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供</p>\n<p>编译器提供的构造函数和析构函数是空实现。</p>\n<p>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。<br>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。<br>构造函数语法：类名(){}</p>\n<p>构造函数，没有返回值也不写 void<br>函数名称与类名相同<br>构造函数可以有参数，因此可以发生重载<br>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次<br>析构函数语法： ~类名(){}</p>\n<p>析构函数，没有返回值也不写 void<br>函数名称与类名相同,在名称前加上符号 ~<br>析构函数不可以有参数，因此不可以发生重载<br>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次<br>C++<br>class Person<br>{<br>public:<br>//构造函数<br>Person()<br>{<br>cout &lt;&lt; “Person 的构造函数调用” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person()<br>{<br>cout &lt;&lt; “Person 的析构函数调用” &lt;&lt; endl;<br>}</p>\n<p>};</p>\n<p>void test01()<br>{<br>Person p;<br>}</p>\n<p>int main() {<br>test01();</p>\n<pre><code>system(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.2 构造函数的分类及调用<br>两种分类方式：</p>\n<p>​ 按参数分为： 有参构造和无参构造</p>\n<p>​ 按类型分为： 普通构造和拷贝构造</p>\n<p>三种调用方式：</p>\n<p>​ 括号法</p>\n<p>​ 显示法</p>\n<p>​ 隐式转换法</p>\n<p>示例：</p>\n<p>C++<br>//1、构造函数分类<br>// 按照参数分类分为 有参和无参构造 无参又称为默认构造函数<br>// 按照类型分类分为 普通构造和拷贝构造</p>\n<p>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int a) {<br>age = a;<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>}<br>//拷贝构造函数<br>Person(const Person&amp; p) {<br>age = p.age;<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int age;<br>};</p>\n<p>//2、构造函数的调用<br>//调用无参构造函数<br>void test01() {<br>Person p; //调用无参构造函数<br>}</p>\n<p>//调用有参的构造函数<br>void test02() {</p>\n<pre><code>//2.1  括号法，常用\nPerson p1(10);\n//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n//Person p2();\n\n//2.2 显式法\nPerson p2 = Person(10);\nPerson p3 = Person(p2);\n//Person(10)单独写就是匿名对象  当前行结束之后，马上析构\n\n//2.3 隐式转换法\nPerson p4 = 10; // Person p4 = Person(10);\nPerson p5 = p4; // Person p5 = Person(p4);\n\n//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\n//Person p5(p4);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n//test02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.3 拷贝构造函数调用时机<br>C++中拷贝构造函数调用时机通常有三种情况</p>\n<p>使用一个已经创建完毕的对象来初始化一个新对象<br>值传递的方式给函数参数传值<br>以值方式返回局部对象<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>mAge = 0;<br>}<br>Person(int age) {<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>mAge = age;<br>}<br>Person(const Person&amp; p) {<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>mAge = p.mAge;<br>}<br>//析构函数在释放内存之前调用<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int mAge;<br>};</p>\n<p>//1. 使用一个已经创建完毕的对象来初始化一个新对象<br>void test01() {</p>\n<pre><code>Person man(100); //p对象已经创建完毕\nPerson newman(man); //调用拷贝构造函数\nPerson newman2 = man; //拷贝构造\n\n//Person newman3;\n//newman3 = man; //不是调用拷贝构造函数，赋值操作</code></pre><p>}</p>\n<p>//2. 值传递的方式给函数参数传值<br>//相当于 Person p1 = p;<br>void doWork(Person p1) {}<br>void test02() {<br>Person p; //无参构造函数<br>doWork(p);<br>}</p>\n<p>//3. 以值方式返回局部对象<br>Person doWork2()<br>{<br>Person p1;<br>cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;<br>return p1;<br>}</p>\n<p>void test03()<br>{<br>Person p = doWork2();<br>cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n//test02();\ntest03();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.4 构造函数调用规则<br>默认情况下，c++编译器至少给一个类添加 3 个函数</p>\n<p>1．默认构造函数(无参，函数体为空)</p>\n<p>2．默认析构函数(无参，函数体为空)</p>\n<p>3．默认拷贝构造函数，对属性进行值拷贝</p>\n<p>构造函数调用规则如下：</p>\n<p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造<br>如果用户定义拷贝构造函数，c++不会再提供其他构造函数<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int a) {<br>age = a;<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>}<br>//拷贝构造函数<br>Person(const Person&amp; p) {<br>age = p.age;<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int age;<br>};</p>\n<p>void test01()<br>{<br>Person p1(18);<br>//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作<br>Person p2(p1);</p>\n<pre><code>cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;</code></pre><p>}</p>\n<p>void test02()<br>{<br>//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造<br>Person p1; //此时如果用户自己没有提供默认构造，会出错<br>Person p2(10); //用户提供的有参<br>Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供</p>\n<pre><code>//如果用户提供拷贝构造，编译器不会提供其他构造函数\nPerson p4; //此时如果用户自己没有提供默认构造，会出错\nPerson p5(10); //此时如果用户自己没有提供有参，会出错\nPerson p6(p5); //用户自己提供拷贝构造</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.5 深拷贝与浅拷贝<br>深浅拷贝是面试经典问题，也是常见的一个坑</p>\n<p>浅拷贝：简单的赋值拷贝操作</p>\n<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int age ,int height) {<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;</p>\n<pre><code>    m_age = age;\n    m_height = new int(height);\n\n}\n//拷贝构造函数\nPerson(const Person&amp; p) {\n    cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n    //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题\n    m_age = p.m_age;\n    m_height = new int(*p.m_height);\n\n}\n\n//析构函数\n~Person() {\n    cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n    if (m_height != NULL)\n    {\n        delete m_height;\n    }\n}</code></pre><p>public:<br>int m_age;<br>int* m_height;<br>};</p>\n<p>void test01()<br>{<br>Person p1(18, 180);</p>\n<pre><code>Person p2(p1);\n\ncout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>\n<p>4.2.6 初始化列表<br>作用：</p>\n<p>C++提供了初始化列表语法，用来初始化属性</p>\n<p>语法：构造函数()：属性 1(值 1),属性 2（值 2）… {}</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:</p>\n<pre><code>////传统方式初始化\n//Person(int a, int b, int c) {\n//    m_A = a;\n//    m_B = b;\n//    m_C = c;\n//}\n\n//初始化列表方式初始化\nPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}\nvoid PrintPerson() {\n    cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;\n    cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;\n    cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;\n}</code></pre><p>private:<br>int m_A;<br>int m_B;<br>int m_C;<br>};</p>\n<p>int main() {</p>\n<pre><code>Person p(1, 2, 3);\np.PrintPerson();\n\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.7 类对象作为类成员<br>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>\n<p>例如：</p>\n<p>C++<br>class A {}<br>class B<br>{<br>A a；<br>}<br>B 类中有对象 A 作为成员，A 为对象成员</p>\n<p>那么当创建 B 对象时，A 与 B 的构造和析构的顺序是谁先谁后？</p>\n<p>示例：</p>\n<p>C++<br>class Phone<br>{<br>public:<br>Phone(string name)<br>{<br>m_PhoneName = name;<br>cout &lt;&lt; “Phone 构造” &lt;&lt; endl;<br>}</p>\n<pre><code>~Phone()\n{\n    cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;\n}\n\nstring m_PhoneName;</code></pre><p>};</p>\n<p>class Person<br>{<br>public:</p>\n<pre><code>//初始化列表可以告诉编译器调用哪一个构造函数\nPerson(string name, string pName) :m_Name(name), m_Phone(pName)\n{\n    cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;\n}\n\n~Person()\n{\n    cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;\n}\n\nvoid playGame()\n{\n    cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;\n}\n\nstring m_Name;\nPhone m_Phone;</code></pre><p>};<br>void test01()<br>{<br>//当类中成员是其他类对象时，我们称该成员为 对象成员<br>//构造的顺序是 ：先调用对象成员的构造，再调用本类构造<br>//析构顺序与构造相反<br>Person p(“张三” , “苹果 X”);<br>p.playGame();</p>\n<p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.8 静态成员<br>静态成员就是在成员变量和成员函数前加上关键字 static，称为静态成员</p>\n<p>静态成员分为：</p>\n<p>静态成员变量<br>所有对象共享同一份数据<br>在编译阶段分配内存<br>类内声明，类外初始化<br>静态成员函数<br>所有对象共享同一个函数<br>静态成员函数只能访问静态成员变量<br>示例 1 ：静态成员变量</p>\n<p>C++<br>class Person<br>{<br>public:</p>\n<pre><code>static int m_A; //静态成员变量\n\n//静态成员变量特点：\n//1 在编译阶段分配内存\n//2 类内声明，类外初始化\n//3 所有对象共享同一份数据</code></pre><p>private:<br>static int m_B; //静态成员变量也是有访问权限的<br>};<br>int Person::m_A = 10;<br>int Person::m_B = 10;</p>\n<p>void test01()<br>{<br>//静态成员变量两种访问方式</p>\n<pre><code>//1、通过对象\nPerson p1;\np1.m_A = 100;\ncout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl;\n\nPerson p2;\np2.m_A = 200;\ncout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据\ncout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl;\n\n//2、通过类名\ncout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl;\n\n\n//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：静态成员函数</p>\n<p>C++<br>class Person<br>{</p>\n<p>public:</p>\n<pre><code>//静态成员函数特点：\n//1 程序共享一个函数\n//2 静态成员函数只能访问静态成员变量\n\nstatic void func()\n{\n    cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;\n    m_A = 100;\n    //m_B = 100; //错误，不可以访问非静态成员变量\n}\n\nstatic int m_A; //静态成员变量\nint m_B; //</code></pre><p>private:</p>\n<pre><code>//静态成员函数也是有访问权限的\nstatic void func2()\n{\n    cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;\n}</code></pre><p>};<br>int Person::m_A = 10;</p>\n<p>void test01()<br>{<br>//静态成员变量两种访问方式</p>\n<pre><code>//1、通过对象\nPerson p1;\np1.func();\n\n//2、通过类名\nPerson::func();\n\n\n//Person::func2(); //私有权限访问不到</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3 C++对象模型和 this 指针<br>4.3.1 成员变量和成员函数分开存储<br>在 C++中，类内的成员变量和成员函数分开存储</p>\n<p>只有非静态成员变量才属于类的对象上</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>mA = 0;<br>}<br>//非静态成员变量占对象空间<br>int mA;<br>//静态成员变量不占对象空间<br>static int mB;<br>//函数也不占对象空间，所有函数共享一个函数实例<br>void func() {<br>cout &lt;&lt; “mA:” &lt;&lt; this-&gt;mA &lt;&lt; endl;<br>}<br>//静态成员函数也不占对象空间<br>static void sfunc() {<br>}<br>};</p>\n<p>int main() {</p>\n<pre><code>cout &lt;&lt; sizeof(Person) &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.2 this 指针概念<br>通过 4.3.1 我们知道在 C++中成员变量和成员函数是分开存储的</p>\n<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>\n<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>\n<p>c++通过提供特殊的对象指针，this 指针，解决上述问题。this 指针指向被调用的成员函数所属的对象</p>\n<p>this 指针是隐含每一个非静态成员函数内的一种指针</p>\n<p>this 指针不需要定义，直接使用即可</p>\n<p>this 指针的用途：</p>\n<p>当形参和成员变量同名时，可用 this 指针来区分<br>在类的非静态成员函数中返回对象本身，可使用 return *this<br>C++<br>class Person<br>{<br>public:</p>\n<pre><code>Person(int age)\n{\n    //1、当形参和成员变量同名时，可用this指针来区分\n    this-&gt;age = age;\n}\n\nPerson&amp; PersonAddPerson(Person p)\n{\n    this-&gt;age += p.age;\n    //返回对象本身\n    return *this;\n}\n\nint age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>Person p1(10);<br>cout &lt;&lt; “p1.age = “ &lt;&lt; p1.age &lt;&lt; endl;</p>\n<pre><code>Person p2(10);\np2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\ncout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.3 空指针访问成员函数<br>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针</p>\n<p>如果用到 this 指针，需要加以判断保证代码的健壮性</p>\n<p>示例：</p>\n<p>C++<br>//空指针访问成员函数<br>class Person {<br>public:</p>\n<pre><code>void ShowClassName() {\n    cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;\n}\n\nvoid ShowPerson() {\n    if (this == NULL) {\n        return;\n    }\n    cout &lt;&lt; mAge &lt;&lt; endl;\n}</code></pre><p>public:<br>int mAge;<br>};</p>\n<p>void test01()<br>{<br>Person * p = NULL;<br>p-&gt;ShowClassName(); //空指针，可以调用成员函数<br>p-&gt;ShowPerson(); //但是如果成员函数中用到了 this 指针，就不可以了<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.4 const 修饰成员函数<br>常函数：</p>\n<p>成员函数后加 const 后我们称为这个函数为常函数<br>常函数内不可以修改成员属性<br>成员属性声明时加关键字 mutable 后，在常函数中依然可以修改<br>常对象：</p>\n<p>声明对象前加 const 称该对象为常对象<br>常对象只能调用常函数<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>m_A = 0;<br>m_B = 0;<br>}</p>\n<pre><code>//this指针的本质是一个指针常量，指针的指向不可修改\n//如果想让指针指向的值也不可以修改，需要声明常函数\nvoid ShowPerson() const {\n    //const Type* const pointer;\n    //this = NULL; //不能修改指针的指向 Person* const this;\n    //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的\n\n    //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量\n    this-&gt;m_B = 100;\n}\n\nvoid MyFunc() const {\n    //mA = 10000;\n}</code></pre><p>public:<br>int m_A;<br>mutable int m_B; //可修改 可变的<br>};</p>\n<p>//const 修饰对象 常对象<br>void test01() {</p>\n<pre><code>const Person person; //常量对象\ncout &lt;&lt; person.m_A &lt;&lt; endl;\n//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问\nperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量\n\n//常对象访问成员函数\nperson.MyFunc(); //常对象不能调用const的函数</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.4 友元<br>生活中你的家有客厅(Public)，有你的卧室(Private)</p>\n<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>\n<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>\n<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>\n<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>\n<p>友元的关键字为 ==friend==</p>\n<p>友元的三种实现</p>\n<p>全局函数做友元<br>类做友元<br>成员函数做友元<br>4.4.1 全局函数做友元<br>C++<br>class Building<br>{<br>//告诉编译器 goodGay 全局函数 是 Building 类的好朋友，可以访问类中的私有内容<br>friend void goodGay(Building * building);</p>\n<p>public:</p>\n<pre><code>Building()\n{\n    this-&gt;m_SittingRoom = &quot;客厅&quot;;\n    this-&gt;m_BedRoom = &quot;卧室&quot;;\n}</code></pre><p>public:<br>string m_SittingRoom; //客厅</p>\n<p>private:<br>string m_BedRoom; //卧室<br>};</p>\n<p>void goodGay(Building * building)<br>{<br>cout &lt;&lt; “好基友正在访问： “ &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问： “ &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>Building b;<br>goodGay(&amp;b);<br>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.4.2 类做友元<br>C++<br>class Building;<br>class goodGay<br>{<br>public:</p>\n<pre><code>goodGay();\nvoid visit();</code></pre><p>private:<br>Building *building;<br>};</p>\n<p>class Building<br>{<br>//告诉编译器 goodGay 类是 Building 类的好朋友，可以访问到 Building 类中私有内容<br>friend class goodGay;</p>\n<p>public:<br>Building();</p>\n<p>public:<br>string m_SittingRoom; //客厅<br>private:<br>string m_BedRoom;//卧室<br>};</p>\n<p>Building::Building()<br>{<br>this-&gt;m_SittingRoom = “客厅”;<br>this-&gt;m_BedRoom = “卧室”;<br>}</p>\n<p>goodGay::goodGay()<br>{<br>building = new Building;<br>}</p>\n<p>void goodGay::visit()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>goodGay gg;<br>gg.visit();</p>\n<p>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.4.3 成员函数做友元<br>C++</p>\n<p>class Building;<br>class goodGay<br>{<br>public:</p>\n<pre><code>goodGay();\nvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\nvoid visit2();</code></pre><p>private:<br>Building *building;<br>};</p>\n<p>class Building<br>{<br>//告诉编译器 goodGay 类中的 visit 成员函数 是 Building 好朋友，可以访问私有内容<br>friend void goodGay::visit();</p>\n<p>public:<br>Building();</p>\n<p>public:<br>string m_SittingRoom; //客厅<br>private:<br>string m_BedRoom;//卧室<br>};</p>\n<p>Building::Building()<br>{<br>this-&gt;m_SittingRoom = “客厅”;<br>this-&gt;m_BedRoom = “卧室”;<br>}</p>\n<p>goodGay::goodGay()<br>{<br>building = new Building;<br>}</p>\n<p>void goodGay::visit()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void goodGay::visit2()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>//cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>goodGay gg;<br>gg.visit();</p>\n<p>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.5 运算符重载<br>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>\n<p>4.5.1 加号运算符重载<br>作用：实现两个自定义数据类型相加的运算</p>\n<p>C++<br>class Person {<br>public:<br>Person() {};<br>Person(int a, int b)<br>{<br>this-&gt;m_A = a;<br>this-&gt;m_B = b;<br>}<br>//成员函数实现 + 号运算符重载<br>Person operator+(const Person&amp; p) {<br>Person temp;<br>temp.m_A = this-&gt;m_A + p.m_A;<br>temp.m_B = this-&gt;m_B + p.m_B;<br>return temp;<br>}</p>\n<p>public:<br>int m_A;<br>int m_B;<br>};</p>\n<p>//全局函数实现 + 号运算符重载<br>//Person operator+(const Person&amp; p1, const Person&amp; p2) {<br>// Person temp(0, 0);<br>// temp.m_A = p1.m_A + p2.m_A;<br>// temp.m_B = p1.m_B + p2.m_B;<br>// return temp;<br>//}</p>\n<p>//运算符重载 可以发生函数重载<br>Person operator+(const Person&amp; p2, int val)<br>{<br>Person temp;<br>temp.m_A = p2.m_A + val;<br>temp.m_B = p2.m_B + val;<br>return temp;<br>}</p>\n<p>void test() {</p>\n<pre><code>Person p1(10, 10);\nPerson p2(20, 20);\n\n//成员函数方式\nPerson p3 = p2 + p1;  //相当于 p2.operaor+(p1)\ncout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;\n\n\nPerson p4 = p3 + 10; //相当于 operator+(p3,10)\ncout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结 1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>\n<p>总结 2：不要滥用运算符重载</p>\n<p>4.5.2 左移运算符重载<br>作用：可以输出自定义数据类型</p>\n<p>C++<br>class Person {<br>friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);</p>\n<p>public:</p>\n<pre><code>Person(int a, int b)\n{\n    this-&gt;m_A = a;\n    this-&gt;m_B = b;\n}\n\n//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果\n//void operator&lt;&lt;(Person&amp; p){\n//}</code></pre><p>private:<br>int m_A;<br>int m_B;<br>};</p>\n<p>//全局函数实现左移重载<br>//ostream 对象只能有一个<br>ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) {<br>out &lt;&lt; “a:” &lt;&lt; p.m_A &lt;&lt; “ b:” &lt;&lt; p.m_B;<br>return out;<br>}</p>\n<p>void test() {</p>\n<pre><code>Person p1(10, 20);\n\ncout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>\n<p>4.5.3 递增运算符重载<br>作用： 通过重载递增运算符，实现自己的整型数据</p>\n<p>C++</p>\n<p>class MyInteger {</p>\n<pre><code>friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);</code></pre><p>public:<br>MyInteger() {<br>m_Num = 0;<br>}<br>//前置++<br>MyInteger&amp; operator++() {<br>//先++<br>m_Num++;<br>//再返回<br>return *this;<br>}</p>\n<pre><code>//后置++\nMyInteger operator++(int) {\n    //先返回\n    MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；\n    m_Num++;\n    return temp;\n}</code></pre><p>private:<br>int m_Num;<br>};</p>\n<p>ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) {<br>out &lt;&lt; myint.m_Num;<br>return out;<br>}</p>\n<p>//前置++ 先++ 再返回<br>void test01() {<br>MyInteger myInt;<br>cout &lt;&lt; ++myInt &lt;&lt; endl;<br>cout &lt;&lt; myInt &lt;&lt; endl;<br>}</p>\n<p>//后置++ 先返回 再++<br>void test02() {</p>\n<pre><code>MyInteger myInt;\ncout &lt;&lt; myInt++ &lt;&lt; endl;\ncout &lt;&lt; myInt &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n//test02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 前置递增返回引用，后置递增返回值</p>\n<p>4.5.4 赋值运算符重载<br>c++编译器至少给一个类添加 4 个函数</p>\n<p>默认构造函数(无参，函数体为空)<br>默认析构函数(无参，函数体为空)<br>默认拷贝构造函数，对属性进行值拷贝<br>赋值运算符 operator=, 对属性进行值拷贝<br>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>\n<p>示例：</p>\n<p>C++<br>class Person<br>{<br>public:</p>\n<pre><code>Person(int age)\n{\n    //将年龄数据开辟到堆区\n    m_Age = new int(age);\n}\n\n//重载赋值运算符\nPerson&amp; operator=(Person &amp;p)\n{\n    if (m_Age != NULL)\n    {\n        delete m_Age;\n        m_Age = NULL;\n    }\n    //编译器提供的代码是浅拷贝\n    //m_Age = p.m_Age;\n\n    //提供深拷贝 解决浅拷贝的问题\n    m_Age = new int(*p.m_Age);\n\n    //返回自身\n    return *this;\n}\n\n\n~Person()\n{\n    if (m_Age != NULL)\n    {\n        delete m_Age;\n        m_Age = NULL;\n    }\n}\n\n//年龄的指针\nint *m_Age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>Person p1(18);</p>\n<pre><code>Person p2(20);\n\nPerson p3(30);\n\np3 = p2 = p1; //赋值操作\n\ncout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\n//int a = 10;\n//int b = 20;\n//int c = 30;\n\n//c = b = a;\n//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\n//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.5.5 关系运算符重载<br>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p>\n<p>示例：</p>\n<p>C++<br>class Person<br>{<br>public:<br>Person(string name, int age)<br>{<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>};</p>\n<pre><code>bool operator==(Person &amp; p)\n{\n    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nbool operator!=(Person &amp; p)\n{\n    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}\n\nstring m_Name;\nint m_Age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>//int a = 0;<br>//int b = 0;</p>\n<pre><code>Person a(&quot;孙悟空&quot;, 18);\nPerson b(&quot;孙悟空&quot;, 18);\n\nif (a == b)\n{\n    cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n}\n\nif (a != b)\n{\n    cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.5.6 函数调用运算符重载<br>函数调用运算符 () 也可以重载<br>由于重载后使用的方式非常像函数的调用，因此称为仿函数<br>仿函数没有固定写法，非常灵活<br>示例：</p>\n<p>C++<br>class MyPrint<br>{<br>public:<br>void operator()(string text)<br>{<br>cout &lt;&lt; text &lt;&lt; endl;<br>}</p>\n<p>};<br>void test01()<br>{<br>//重载的（）操作符 也称为仿函数<br>MyPrint myFunc;<br>myFunc(“hello world”);<br>}</p>\n<p>class MyAdd<br>{<br>public:<br>int operator()(int v1, int v2)<br>{<br>return v1 + v2;<br>}<br>};</p>\n<p>void test02()<br>{<br>MyAdd add;<br>int ret = add(10, 10);<br>cout &lt;&lt; “ret = “ &lt;&lt; ret &lt;&lt; endl;</p>\n<pre><code>//匿名对象调用\ncout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.6 继承<br>继承是面向对象三大特性之一</p>\n<p>有些类与类之间存在特殊的关系，例如下图中：</p>\n<p>1544861202252<br>1544861202252</p>\n<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>\n<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>\n<p>4.6.1 继承的基本语法<br>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>\n<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>\n<p>普通实现：</p>\n<p>C++<br>//Java 页面<br>class Java<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “JAVA 学科视频” &lt;&lt; endl;<br>}<br>};<br>//Python 页面<br>class Python<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “Python 学科视频” &lt;&lt; endl;<br>}<br>};<br>//C++页面<br>class CPP<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “C++学科视频” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//Java 页面<br>cout &lt;&lt; “Java 下载视频页面如下： “ &lt;&lt; endl;<br>Java ja;<br>ja.header();<br>ja.footer();<br>ja.left();<br>ja.content();<br>cout &lt;&lt; “——————–” &lt;&lt; endl;</p>\n<pre><code>//Python页面\ncout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\nPython py;\npy.header();\npy.footer();\npy.left();\npy.content();\ncout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n//C++页面\ncout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\nCPP cp;\ncp.header();\ncp.footer();\ncp.left();\ncp.content();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>继承实现：</p>\n<p>C++<br>//公共页面<br>class BasePage<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}</p>\n<pre><code>void footer()\n{\n    cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\n}\nvoid left()\n{\n    cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\n}</code></pre><p>};</p>\n<p>//Java 页面<br>class Java : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “JAVA 学科视频” &lt;&lt; endl;<br>}<br>};<br>//Python 页面<br>class Python : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “Python 学科视频” &lt;&lt; endl;<br>}<br>};<br>//C++页面<br>class CPP : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “C++学科视频” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//Java 页面<br>cout &lt;&lt; “Java 下载视频页面如下： “ &lt;&lt; endl;<br>Java ja;<br>ja.header();<br>ja.footer();<br>ja.left();<br>ja.content();<br>cout &lt;&lt; “——————–” &lt;&lt; endl;</p>\n<pre><code>//Python页面\ncout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\nPython py;\npy.header();\npy.footer();\npy.left();\npy.content();\ncout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n//C++页面\ncout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\nCPP cp;\ncp.header();\ncp.footer();\ncp.left();\ncp.content();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>继承的好处：==可以减少重复的代码==</p>\n<p>class A : public B;</p>\n<p>A 类称为子类 或 派生类</p>\n<p>B 类称为父类 或 基类</p>\n<p>派生类中的成员，包含两大部分：</p>\n<p>一类是从基类继承过来的，一类是自己增加的成员。</p>\n<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>\n<p>4.6.2 继承方式<br>继承的语法：class 子类 : 继承方式 父类</p>\n<p>继承方式一共有三种：</p>\n<p>公共继承<br>保护继承<br>私有继承<br>img<br>img</p>\n<p>示例：</p>\n<p>C++<br>class Base1<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};</p>\n<p>//公共继承<br>class Son1 :public Base1<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 public 权限<br>m_B; //可访问 protected 权限<br>//m_C; //不可访问<br>}<br>};</p>\n<p>void myClass()<br>{<br>Son1 s1;<br>s1.m_A; //其他类只能访问到公共权限<br>}</p>\n<p>//保护继承<br>class Base2<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};<br>class Son2:protected Base2<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 protected 权限<br>m_B; //可访问 protected 权限<br>//m_C; //不可访问<br>}<br>};<br>void myClass2()<br>{<br>Son2 s;<br>//s.m_A; //不可访问<br>}</p>\n<p>//私有继承<br>class Base3<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};<br>class Son3:private Base3<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 private 权限<br>m_B; //可访问 private 权限<br>//m_C; //不可访问<br>}<br>};<br>class GrandSon3 :public Son3<br>{<br>public:<br>void func()<br>{<br>//Son3 是私有继承，所以继承 Son3 的属性在 GrandSon3 中都无法访问到<br>//m_A;<br>//m_B;<br>//m_C;<br>}<br>};<br>4.6.3 继承中的对象模型<br>问题：从父类继承过来的成员，哪些属于子类对象中？</p>\n<p>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C; //私有成员只是被隐藏了，但是还是会继承下去<br>};</p>\n<p>//公共继承<br>class Son :public Base<br>{<br>public:<br>int m_D;<br>};</p>\n<p>void test01()<br>{<br>cout &lt;&lt; “sizeof Son = “ &lt;&lt; sizeof(Son) &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>利用工具查看：</p>\n<p>1545881904150<br>1545881904150</p>\n<p>打开工具窗口后，定位到当前 CPP 文件的盘符</p>\n<p>然后输入： cl /d1 reportSingleClassLayout 查看的类名 所属文件名</p>\n<p>效果如下图：</p>\n<p>1545882158050<br>1545882158050</p>\n<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>\n<p>4.6.4 继承中构造和析构顺序<br>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>\n<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>\n<p>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>Base()<br>{<br>cout &lt;&lt; “Base 构造函数!” &lt;&lt; endl;<br>}<br>~Base()<br>{<br>cout &lt;&lt; “Base 析构函数!” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Son : public Base<br>{<br>public:<br>Son()<br>{<br>cout &lt;&lt; “Son 构造函数!” &lt;&lt; endl;<br>}<br>~Son()<br>{<br>cout &lt;&lt; “Son 析构函数!” &lt;&lt; endl;<br>}</p>\n<p>};</p>\n<p>void test01()<br>{<br>//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反<br>Son s;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>\n<p>4.6.5 继承同名成员处理方式<br>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>\n<p>访问子类同名成员 直接访问即可<br>访问父类同名成员 需要加作用域<br>示例：</p>\n<p>C++<br>class Base {<br>public:<br>Base()<br>{<br>m_A = 100;<br>}</p>\n<pre><code>void func()\n{\n    cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;\n}\n\nvoid func(int a)\n{\n    cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;\n}</code></pre><p>public:<br>int m_A;<br>};</p>\n<p>class Son : public Base {<br>public:<br>Son()<br>{<br>m_A = 200;<br>}</p>\n<pre><code>//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\n//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\nvoid func()\n{\n    cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;\n}</code></pre><p>public:<br>int m_A;<br>};</p>\n<p>void test01()<br>{<br>Son s;</p>\n<pre><code>cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;\ncout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\n\ns.func();\ns.Base::func();\ns.Base::func(10);</code></pre><p>}<br>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn EXIT_SUCCESS;</code></pre><p>}<br>总结：</p>\n<p>子类对象可以直接访问到子类中同名成员<br>子类对象加作用域可以访问到父类同名成员<br>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数<br>4.6.6 继承同名静态成员处理方式<br>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>\n<p>静态成员和非静态成员出现同名，处理方式一致</p>\n<p>访问子类同名成员 直接访问即可<br>访问父类同名成员 需要加作用域<br>示例：</p>\n<p>C++<br>class Base {<br>public:<br>static void func()<br>{<br>cout &lt;&lt; “Base - static void func()” &lt;&lt; endl;<br>}<br>static void func(int a)<br>{<br>cout &lt;&lt; “Base - static void func(int a)” &lt;&lt; endl;<br>}</p>\n<pre><code>static int m_A;</code></pre><p>};</p>\n<p>int Base::m_A = 100;</p>\n<p>class Son : public Base {<br>public:<br>static void func()<br>{<br>cout &lt;&lt; “Son - static void func()” &lt;&lt; endl;<br>}<br>static int m_A;<br>};</p>\n<p>int Son::m_A = 200;</p>\n<p>//同名成员属性<br>void test01()<br>{<br>//通过对象访问<br>cout &lt;&lt; “通过对象访问： “ &lt;&lt; endl;<br>Son s;<br>cout &lt;&lt; “Son 下 m_A = “ &lt;&lt; s.m_A &lt;&lt; endl;<br>cout &lt;&lt; “Base 下 m_A = “ &lt;&lt; s.Base::m_A &lt;&lt; endl;</p>\n<pre><code>//通过类名访问\ncout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;\ncout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;</code></pre><p>}</p>\n<p>//同名成员函数<br>void test02()<br>{<br>//通过对象访问<br>cout &lt;&lt; “通过对象访问： “ &lt;&lt; endl;<br>Son s;<br>s.func();<br>s.Base::func();</p>\n<pre><code>cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\nSon::func();\nSon::Base::func();\n//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\nSon::Base::func(100);</code></pre><p>}<br>int main() {</p>\n<pre><code>//test01();\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>\n<p>4.6.7 多继承语法<br>C++允许一个类继承多个类</p>\n<p>语法：class 子类 ：继承方式 父类 1 ， 继承方式 父类 2…</p>\n<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>\n<p>C++实际开发中不建议用多继承</p>\n<p>示例：</p>\n<p>C++<br>class Base1 {<br>public:<br>Base1()<br>{<br>m_A = 100;<br>}<br>public:<br>int m_A;<br>};</p>\n<p>class Base2 {<br>public:<br>Base2()<br>{<br>m_A = 200; //开始是 m_B 不会出问题，但是改为 mA 就会出现不明确<br>}<br>public:<br>int m_A;<br>};</p>\n<p>//语法：class 子类：继承方式 父类 1 ，继承方式 父类 2<br>class Son : public Base2, public Base1<br>{<br>public:<br>Son()<br>{<br>m_C = 300;<br>m_D = 400;<br>}<br>public:<br>int m_C;<br>int m_D;<br>};</p>\n<p>//多继承容易产生成员同名的情况<br>//通过使用类名作用域可以区分调用哪一个基类的成员<br>void test01()<br>{<br>Son s;<br>cout &lt;&lt; “sizeof Son = “ &lt;&lt; sizeof(s) &lt;&lt; endl;<br>cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;<br>cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>\n<p>4.6.8 菱形继承<br>菱形继承概念：</p>\n<p>​ 两个派生类继承同一个基类</p>\n<p>​ 又有某个类同时继承者两个派生类</p>\n<p>​ 这种继承被称为菱形继承，或者钻石继承</p>\n<p>典型的菱形继承案例：</p>\n<p>IMG_256<br>IMG_256</p>\n<p>菱形继承问题：</p>\n<p>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</p>\n<p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>\n<p>示例：</p>\n<p>C++<br>class Animal<br>{<br>public:<br>int m_Age;<br>};</p>\n<p>//继承前加 virtual 关键字后，变为虚继承<br>//此时公共的父类 Animal 称为虚基类<br>class Sheep : virtual public Animal {};<br>class Tuo : virtual public Animal {};<br>class SheepTuo : public Sheep, public Tuo {};</p>\n<p>void test01()<br>{<br>SheepTuo st;<br>st.Sheep::m_Age = 100;<br>st.Tuo::m_Age = 200;</p>\n<pre><code>cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;\ncout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;\ncout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义<br>利用虚继承可以解决菱形继承问题<br>4.7 多态<br>4.7.1 多态的基本概念<br>多态是 C++面向对象三大特性之一</p>\n<p>多态分为两类</p>\n<p>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名<br>动态多态: 派生类和虚函数实现运行时多态<br>静态多态和动态多态区别：</p>\n<p>静态多态的函数地址早绑定 - 编译阶段确定函数地址<br>动态多态的函数地址晚绑定 - 运行阶段确定函数地址<br>下面通过案例进行讲解多态</p>\n<p>C++<br>class Animal<br>{<br>public:<br>//Speak 函数就是虚函数<br>//函数前面加上 virtual 关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。<br>virtual void speak()<br>{<br>cout &lt;&lt; “动物在说话” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Cat :public Animal<br>{<br>public:<br>void speak()<br>{<br>cout &lt;&lt; “小猫在说话” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Dog :public Animal<br>{<br>public:</p>\n<pre><code>void speak()\n{\n    cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;\n}</code></pre><p>};<br>//我们希望传入什么对象，那么就调用什么对象的函数<br>//如果函数地址在编译阶段就能确定，那么静态联编<br>//如果函数地址在运行阶段才能确定，就是动态联编</p>\n<p>void DoSpeak(Animal &amp; animal)<br>{<br>animal.speak();<br>}<br>//<br>//多态满足条件：<br>//1、有继承关系<br>//2、子类重写父类中的虚函数<br>//多态使用：<br>//父类指针或引用指向子类对象</p>\n<p>void test01()<br>{<br>Cat cat;<br>DoSpeak(cat);</p>\n<pre><code>Dog dog;\nDoSpeak(dog);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>多态满足条件</p>\n<p>有继承关系<br>子类重写父类中的虚函数<br>多态使用条件</p>\n<p>父类指针或引用指向子类对象<br>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p>\n<p>4.7.2 多态案例一-计算器类<br>案例描述：</p>\n<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>\n<p>多态的优点：</p>\n<p>代码组织结构清晰<br>可读性强<br>利于前期和后期的扩展以及维护<br>示例：</p>\n<p>C++<br>//普通实现<br>class Calculator {<br>public:<br>int getResult(string oper)<br>{<br>if (oper == “+”) {<br>return m_Num1 + m_Num2;<br>}<br>else if (oper == “-“) {<br>return m_Num1 - m_Num2;<br>}<br>else if (oper == “_”) {<br>return m_Num1 _ m_Num2;<br>}<br>//如果要提供新的运算，需要修改源码<br>}<br>public:<br>int m_Num1;<br>int m_Num2;<br>};</p>\n<p>void test01()<br>{<br>//普通实现测试<br>Calculator c;<br>c.m_Num1 = 10;<br>c.m_Num2 = 10;<br>cout &lt;&lt; c.m_Num1 &lt;&lt; “ + “ &lt;&lt; c.m_Num2 &lt;&lt; “ = “ &lt;&lt; c.getResult(“+”) &lt;&lt; endl;</p>\n<pre><code>cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;\n\ncout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;</code></pre><p>}</p>\n<p>//多态实现<br>//抽象计算器类<br>//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护<br>class AbstractCalculator<br>{<br>public :</p>\n<pre><code>virtual int getResult()\n{\n    return 0;\n}\n\nint m_Num1;\nint m_Num2;</code></pre><p>};</p>\n<p>//加法计算器<br>class AddCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 + m_Num2;<br>}<br>};</p>\n<p>//减法计算器<br>class SubCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 - m_Num2;<br>}<br>};</p>\n<p>//乘法计算器<br>class MulCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 * m_Num2;<br>}<br>};</p>\n<p>void test02()<br>{<br>//创建加法计算器<br>AbstractCalculator *abc = new AddCalculator;<br>abc-&gt;m_Num1 = 10;<br>abc-&gt;m_Num2 = 10;<br>cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; “ + “ &lt;&lt; abc-&gt;m_Num2 &lt;&lt; “ = “ &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;<br>delete abc; //用完了记得销毁</p>\n<pre><code>//创建减法计算器\nabc = new SubCalculator;\nabc-&gt;m_Num1 = 10;\nabc-&gt;m_Num2 = 10;\ncout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\ndelete abc;\n\n//创建乘法计算器\nabc = new MulCalculator;\nabc-&gt;m_Num1 = 10;\nabc-&gt;m_Num2 = 10;\ncout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\ndelete abc;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>\n<p>4.7.3 纯虚函数和抽象类<br>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>\n<p>因此可以将虚函数改为纯虚函数</p>\n<p>纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ;</p>\n<p>当类中有了纯虚函数，这个类也称为==抽象类==</p>\n<p>抽象类特点：</p>\n<p>无法实例化对象<br>子类必须重写抽象类中的纯虚函数，否则也属于抽象类<br>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>//纯虚函数<br>//类中只要有一个纯虚函数就称为抽象类<br>//抽象类无法实例化对象<br>//子类必须重写父类中的纯虚函数，否则也属于抽象类<br>virtual void func() = 0;<br>};</p>\n<p>class Son :public Base<br>{<br>public:<br>virtual void func()<br>{<br>cout &lt;&lt; “func 调用” &lt;&lt; endl;<br>};<br>};</p>\n<p>void test01()<br>{<br>Base * base = NULL;<br>//base = new Base; // 错误，抽象类无法实例化对象<br>base = new Son;<br>base-&gt;func();<br>delete base;//记得销毁<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.7.4 多态案例二-制作饮品<br>案例描述：</p>\n<p>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</p>\n<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>\n<p>1545985945198<br>1545985945198</p>\n<p>示例：</p>\n<p>C++<br>//抽象制作饮品<br>class AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() = 0;<br>//冲泡<br>virtual void Brew() = 0;<br>//倒入杯中<br>virtual void PourInCup() = 0;<br>//加入辅料<br>virtual void PutSomething() = 0;<br>//规定流程<br>void MakeDrink() {<br>Boil();<br>Brew();<br>PourInCup();<br>PutSomething();<br>}<br>};</p>\n<p>//制作咖啡<br>class Coffee : public AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() {<br>cout &lt;&lt; “煮农夫山泉!” &lt;&lt; endl;<br>}<br>//冲泡<br>virtual void Brew() {<br>cout &lt;&lt; “冲泡咖啡!” &lt;&lt; endl;<br>}<br>//倒入杯中<br>virtual void PourInCup() {<br>cout &lt;&lt; “将咖啡倒入杯中!” &lt;&lt; endl;<br>}<br>//加入辅料<br>virtual void PutSomething() {<br>cout &lt;&lt; “加入牛奶!” &lt;&lt; endl;<br>}<br>};</p>\n<p>//制作茶水<br>class Tea : public AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() {<br>cout &lt;&lt; “煮自来水!” &lt;&lt; endl;<br>}<br>//冲泡<br>virtual void Brew() {<br>cout &lt;&lt; “冲泡茶叶!” &lt;&lt; endl;<br>}<br>//倒入杯中<br>virtual void PourInCup() {<br>cout &lt;&lt; “将茶水倒入杯中!” &lt;&lt; endl;<br>}<br>//加入辅料<br>virtual void PutSomething() {<br>cout &lt;&lt; “加入枸杞!” &lt;&lt; endl;<br>}<br>};</p>\n<p>//业务函数<br>void DoWork(AbstractDrinking* drink) {<br>drink-&gt;MakeDrink();<br>delete drink;<br>}</p>\n<p>void test01() {<br>DoWork(new Coffee);<br>cout &lt;&lt; “————–” &lt;&lt; endl;<br>DoWork(new Tea);<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.7.5 虚析构和纯虚析构<br>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>\n<p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p>\n<p>虚析构和纯虚析构共性：</p>\n<p>可以解决父类指针释放子类对象<br>都需要有具体的函数实现<br>虚析构和纯虚析构区别：</p>\n<p>如果是纯虚析构，该类属于抽象类，无法实例化对象<br>虚析构语法：</p>\n<p>virtual ~类名(){}</p>\n<p>纯虚析构语法：</p>\n<p>virtual ~类名() = 0;</p>\n<p>类名::~类名(){}</p>\n<p>示例：</p>\n<p>C++<br>class Animal {<br>public:</p>\n<pre><code>Animal()\n{\n    cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;\n}\nvirtual void Speak() = 0;\n\n//析构函数加上virtual关键字，变成虚析构函数\n//virtual ~Animal()\n//{\n//    cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;\n//}\n\n\nvirtual ~Animal() = 0;</code></pre><p>};</p>\n<p>Animal::~Animal()<br>{<br>cout &lt;&lt; “Animal 纯虚析构函数调用！” &lt;&lt; endl;<br>}</p>\n<p>//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</p>\n<p>class Cat : public Animal {<br>public:<br>Cat(string name)<br>{<br>cout &lt;&lt; “Cat 构造函数调用！” &lt;&lt; endl;<br>m_Name = new string(name);<br>}<br>virtual void Speak()<br>{<br>cout &lt;&lt; *m_Name &lt;&lt; “小猫在说话!” &lt;&lt; endl;<br>}<br>~Cat()<br>{<br>cout &lt;&lt; “Cat 析构函数调用!” &lt;&lt; endl;<br>if (this-&gt;m_Name != NULL) {<br>delete m_Name;<br>m_Name = NULL;<br>}<br>}</p>\n<p>public:<br>string *m_Name;<br>};</p>\n<p>void test01()<br>{<br>Animal *animal = new Cat(“Tom”);<br>animal-&gt;Speak();</p>\n<pre><code>//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\n//怎么解决？给基类增加一个虚析构函数\n//虚析构函数就是用来解决通过父类指针释放子类对象\ndelete animal;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>\n<p>​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>\n<p>​ 3. 拥有纯虚析构函数的类也属于抽象类</p>\n<p>4.7.6 多态案例三-电脑组装<br>案例描述：</p>\n<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>\n<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如 Intel 厂商和 Lenovo 厂商</p>\n<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>\n<p>测试时组装三台不同的电脑进行工作</p>\n<p>示例：</p>\n<p>C++<br>#include<iostream><br>using namespace std;</p>\n<p>//抽象 CPU 类<br>class CPU<br>{<br>public:<br>//抽象的计算函数<br>virtual void calculate() = 0;<br>};</p>\n<p>//抽象显卡类<br>class VideoCard<br>{<br>public:<br>//抽象的显示函数<br>virtual void display() = 0;<br>};</p>\n<p>//抽象内存条类<br>class Memory<br>{<br>public:<br>//抽象的存储函数<br>virtual void storage() = 0;<br>};</p>\n<p>//电脑类<br>class Computer<br>{<br>public:<br>Computer(CPU _ cpu, VideoCard _ vc, Memory * mem)<br>{<br>m_cpu = cpu;<br>m_vc = vc;<br>m_mem = mem;<br>}</p>\n<pre><code>//提供工作的函数\nvoid work()\n{\n    //让零件工作起来，调用接口\n    m_cpu-&gt;calculate();\n\n    m_vc-&gt;display();\n\n    m_mem-&gt;storage();\n}\n\n//提供析构函数 释放3个电脑零件\n~Computer()\n{\n\n    //释放CPU零件\n    if (m_cpu != NULL)\n    {\n        delete m_cpu;\n        m_cpu = NULL;\n    }\n\n    //释放显卡零件\n    if (m_vc != NULL)\n    {\n        delete m_vc;\n        m_vc = NULL;\n    }\n\n    //释放内存条零件\n    if (m_mem != NULL)\n    {\n        delete m_mem;\n        m_mem = NULL;\n    }\n}</code></pre><p>private:</p>\n<pre><code>CPU * m_cpu; //CPU的零件指针\nVideoCard * m_vc; //显卡零件指针\nMemory * m_mem; //内存条零件指针</code></pre><p>};</p>\n<p>//具体厂商<br>//Intel 厂商<br>class IntelCPU :public CPU<br>{<br>public:<br>virtual void calculate()<br>{<br>cout &lt;&lt; “Intel 的 CPU 开始计算了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class IntelVideoCard :public VideoCard<br>{<br>public:<br>virtual void display()<br>{<br>cout &lt;&lt; “Intel 的显卡开始显示了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class IntelMemory :public Memory<br>{<br>public:<br>virtual void storage()<br>{<br>cout &lt;&lt; “Intel 的内存条开始存储了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>//Lenovo 厂商<br>class LenovoCPU :public CPU<br>{<br>public:<br>virtual void calculate()<br>{<br>cout &lt;&lt; “Lenovo 的 CPU 开始计算了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class LenovoVideoCard :public VideoCard<br>{<br>public:<br>virtual void display()<br>{<br>cout &lt;&lt; “Lenovo 的显卡开始显示了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class LenovoMemory :public Memory<br>{<br>public:<br>virtual void storage()<br>{<br>cout &lt;&lt; “Lenovo 的内存条开始存储了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//第一台电脑零件<br>CPU _ intelCpu = new IntelCPU;<br>VideoCard _ intelCard = new IntelVideoCard;<br>Memory * intelMem = new IntelMemory;</p>\n<pre><code>cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;\n//创建第一台电脑\nComputer * computer1 = new Computer(intelCpu, intelCard, intelMem);\ncomputer1-&gt;work();\ndelete computer1;\n\ncout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;\n//第二台电脑组装\nComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\ncomputer2-&gt;work();\ndelete computer2;\n\ncout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;\n//第三台电脑组装\nComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\ncomputer3-&gt;work();\ndelete computer3;</code></pre><p>}<br>5 文件操作<br>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>\n<p>通过文件可以将数据持久化</p>\n<p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p>\n<p>文件类型分为两种：</p>\n<p>文本文件 - 文件以文本的 ASCII 码形式存储在计算机中<br>二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们<br>操作文件的三大类:</p>\n<p>ofstream：写操作<br>ifstream： 读操作<br>fstream ： 读写操作<br>5.1 文本文件<br>5.1.1 写文件<br>写文件步骤如下：</p>\n<p>包含头文件</p>\n<p>#include <fstream></p>\n<p>创建流对象</p>\n<p>ofstream ofs;</p>\n<p>打开文件</p>\n<p>ofs.open(“文件路径”,打开方式);</p>\n<p>写数据</p>\n<p>ofs &lt;&lt; “写入的数据”;</p>\n<p>关闭文件</p>\n<p>ofs.close();</p>\n<p>文件打开方式：</p>\n<p>打开方式 解释<br>ios::in 为读文件而打开文件<br>ios::out 为写文件而打开文件<br>ios::ate 初始位置：文件尾<br>ios::app 追加方式写文件<br>ios::trunc 如果文件存在先删除，再创建<br>ios::binary 二进制方式<br>注意： 文件打开方式可以配合使用，利用|操作符</p>\n<p>例如：用二进制方式写文件 ios::binary | ios:: out</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream></p>\n<p>void test01()<br>{<br>ofstream ofs;<br>ofs.open(“test.txt”, ios::out);</p>\n<pre><code>ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;\nofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;\nofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;\n\nofs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>文件操作必须包含头文件 fstream<br>读文件可以利用 ofstream ，或者 fstream 类<br>打开文件时候需要指定操作文件的路径，以及打开方式<br>利用&lt;&lt;可以向文件中写数据<br>操作完毕，要关闭文件<br>5.1.2 读文件<br>读文件与写文件步骤相似，但是读取方式相对于比较多</p>\n<p>读文件步骤如下：</p>\n<p>包含头文件</p>\n<p>#include <fstream></p>\n<p>创建流对象</p>\n<p>ifstream ifs;</p>\n<p>打开文件并判断文件是否打开成功</p>\n<p>ifs.open(“文件路径”,打开方式);</p>\n<p>读数据</p>\n<p>四种方式读取</p>\n<p>关闭文件</p>\n<p>ifs.close();</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string><br>void test01()<br>{<br>ifstream ifs;<br>ifs.open(“test.txt”, ios::in);</p>\n<pre><code>if (!ifs.is_open())\n{\n    cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;\n    return;\n}\n\n//第一种方式\n//char buf[1024] = { 0 };\n//while (ifs &gt;&gt; buf)\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\n//第二种\n//char buf[1024] = { 0 };\n//while (ifs.getline(buf,sizeof(buf)))\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\n//第三种\n//string buf;\n//while (getline(ifs, buf))\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\nchar c;\nwhile ((c = ifs.get()) != EOF)\n{\n    cout &lt;&lt; c;\n}\n\nifs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>读文件可以利用 ifstream ，或者 fstream 类<br>利用 is_open 函数可以判断文件是否打开成功<br>close 关闭文件<br>5.2 二进制文件<br>以二进制的方式对文件进行读写操作</p>\n<p>打开方式要指定为 ==ios::binary==</p>\n<p>5.2.1 写文件<br>二进制方式写文件主要利用流对象调用成员函数 write</p>\n<p>函数原型 ：ostream&amp; write(const char * buffer,int len);</p>\n<p>参数解释：字符指针 buffer 指向内存中一段存储空间。len 是读写的字节数</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string></p>\n<p>class Person<br>{<br>public:<br>char m_Name[64];<br>int m_Age;<br>};</p>\n<p>//二进制文件 写文件<br>void test01()<br>{<br>//1、包含头文件</p>\n<pre><code>//2、创建输出流对象\nofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary);\n\n//3、打开文件\n//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);\n\nPerson p = {&quot;张三&quot;  , 18};\n\n//4、写文件\nofs.write((const char *)&amp;p, sizeof(p));\n\n//5、关闭文件\nofs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>文件输出流对象 可以通过 write 函数，以二进制方式写数据<br>5.2.2 读文件<br>二进制方式读文件主要利用流对象调用成员函数 read</p>\n<p>函数原型：istream&amp; read(char *buffer,int len);</p>\n<p>参数解释：字符指针 buffer 指向内存中一段存储空间。len 是读写的字节数</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string></p>\n<p>class Person<br>{<br>public:<br>char m_Name[64];<br>int m_Age;<br>};</p>\n<p>void test01()<br>{<br>ifstream ifs(“person.txt”, ios::in | ios::binary);<br>if (!ifs.is_open())<br>{<br>cout &lt;&lt; “文件打开失败” &lt;&lt; endl;<br>}</p>\n<pre><code>Person p;\nifs.read((char *)&amp;p, sizeof(p));\n\ncout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>文件输入流对象 可以通过 read 函数，以二进制方式读数据</p>\n"},{"title":"A first look at C++ (2) copy 5","url":"/2023/01/18/A%20first%20look%20at%20C++%20(2)%20copy%205/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><p>C++核心编程<br>本阶段主要针对 C++==面向对象==编程技术做详细讲解，探讨 C++中的核心和精髓。</p>\n<p>1 内存分区模型<br>C++程序在执行时，将内存大方向划分为 4 个区域</p>\n<p>代码区：存放函数体的二进制代码，由操作系统进行管理的<br>全局区：存放全局变量和静态变量以及常量<br>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等<br>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收<br>内存四区意义：</p>\n<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>\n<p>1.1 程序运行前<br>​ 在程序编译后，生成了 exe 可执行程序，未执行该程序前分为两个区域</p>\n<p>​ 代码区：</p>\n<p>​ 存放 CPU 执行的机器指令</p>\n<p>​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>\n<p>​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令</p>\n<p>​ 全局区：</p>\n<p>​ 全局变量和静态变量存放在此.</p>\n<p>​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>\n<p>​ ==该区域的数据在程序结束后由操作系统释放==.</p>\n<p>示例：</p>\n<p>C++<br>//全局变量<br>int g_a = 10;<br>int g_b = 10;</p>\n<p>//全局常量<br>const int c_g_a = 10;<br>const int c_g_b = 10;</p>\n<p>int main() {</p>\n<pre><code>//局部变量\nint a = 10;\nint b = 10;\n\n//打印地址\ncout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;\ncout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;\n\ncout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt;  (int)&amp;g_a &lt;&lt; endl;\ncout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt;  (int)&amp;g_b &lt;&lt; endl;\n\n//静态变量\nstatic int s_a = 10;\nstatic int s_b = 10;\n\ncout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;\ncout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;\n\ncout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;\n\ncout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;\ncout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;\n\nconst int c_l_a = 10;\nconst int c_l_b = 10;\ncout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;\ncout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>打印结果：</p>\n<p>1545017602518<br>1545017602518</p>\n<p>总结：</p>\n<p>C++中在程序运行前分为全局区和代码区<br>代码区特点是共享和只读<br>全局区中存放全局变量、静态变量、常量<br>常量区中存放 const 修饰的全局常量 和 字符串常量<br>1.2 程序运行后<br>​ 栈区：</p>\n<p>​ 由编译器自动分配释放, 存放函数的参数值,局部变量等</p>\n<p>​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>\n<p>示例：</p>\n<p>C++<br>int * func()<br>{<br>int a = 10;<br>return &a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>​ 堆区：</p>\n<p>​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>\n<p>​ 在 C++中主要利用 new 在堆区开辟内存</p>\n<p>示例：</p>\n<p>C++<br>int* func()<br>{<br>int* a = new int(10);<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>堆区数据由程序员管理开辟和释放</p>\n<p>堆区数据利用 new 关键字进行开辟内存</p>\n<p>1.3 new 操作符<br>​ C++中利用==new==操作符在堆区开辟数据</p>\n<p>​ 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p>\n<p>​ 语法：new 数据类型</p>\n<p>​ 利用 new 创建的数据，会返回该数据对应的类型的指针</p>\n<p>示例 1： 基本语法</p>\n<p>C++<br>int* func()<br>{<br>int* a = new int(10);<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>int *p = func();\n\ncout &lt;&lt; *p &lt;&lt; endl;\ncout &lt;&lt; *p &lt;&lt; endl;\n\n//利用delete释放堆区数据\ndelete p;\n\n//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：开辟数组</p>\n<p>C++<br>//堆区开辟数组<br>int main() {</p>\n<pre><code>int* arr = new int[10];\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    arr[i] = i + 100;\n}\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    cout &lt;&lt; arr[i] &lt;&lt; endl;\n}\n//释放数组 delete 后加 []\ndelete[] arr;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2 引用<br>2.1 引用的基本使用<br>*作用： *给变量起别名</p>\n<p>语法： 数据类型 &amp;别名 = 原名</p>\n<p>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int a = 10;\nint &amp;b = a;\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n\nb = 100;\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2.2 引用注意事项<br>引用必须初始化<br>引用在初始化后，不可以改变<br>示例：</p>\n<p>C++<br>int main() {</p>\n<pre><code>int a = 10;\nint b = 20;\n//int &amp;c; //错误，引用必须初始化\nint &amp;c = a; //一旦初始化后，就不可以更改\nc = b; //这是赋值操作，不是更改引用\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\ncout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2.3 引用做函数参数<br>作用：函数传参时，可以利用引用的技术让形参修饰实参</p>\n<p>优点：可以简化指针修改实参</p>\n<p>示例：</p>\n<p>C++<br>//1. 值传递<br>void mySwap01(int a, int b) {<br>int temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>//2. 地址传递<br>void mySwap02(int* a, int* b) {<br>int temp = *a;<br>*a = *b;<br>*b = temp;<br>}</p>\n<p>//3. 引用传递<br>void mySwap03(int&amp; a, int&amp; b) {<br>int temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>int main() {</p>\n<pre><code>int a = 10;\nint b = 20;\n\nmySwap01(a, b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nmySwap02(&amp;a, &amp;b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nmySwap03(a, b);\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>\n<p>2.4 引用做函数返回值<br>作用：引用是可以作为函数的返回值存在的</p>\n<p>注意：不要返回局部变量引用</p>\n<p>用法：函数调用作为左值</p>\n<p>示例：</p>\n<p>C++<br>//返回局部变量引用<br>int&amp; test01() {<br>int a = 10; //局部变量<br>return a;<br>}</p>\n<p>//返回静态变量引用<br>int&amp; test02() {<br>static int a = 20;<br>return a;<br>}</p>\n<p>int main() {</p>\n<pre><code>//不能返回局部变量的引用\nint&amp; ref = test01();\ncout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\ncout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\n\n//如果函数做左值，那么必须返回引用\nint&amp; ref2 = test02();\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\ntest02() = 1000;\n\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\ncout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>​</p>\n<p>2.5 引用的本质<br>本质：引用的本质在 c++内部实现是一个指针常量.</p>\n<p>讲解示例：</p>\n<p>C++<br>//发现是引用，转换为 int* const ref = &a;<br>void func(int&amp; ref){<br>ref = 100; // ref 是引用，转换为*ref = 100<br>}<br>int main(){<br>int a = 10;</p>\n<pre><code>//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改\nint&amp; ref = a;\nref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\n\ncout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;\n\nfunc(a);\nreturn 0;</code></pre><p>}<br>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>\n<p>2.6 常量引用<br>作用：常量引用主要用来修饰形参，防止误操作</p>\n<p>在函数形参列表中，可以加==const 修饰形参==，防止形参改变实参</p>\n<p>示例：</p>\n<p>C++<br>//引用使用的场景，通常用来修饰形参<br>void showValue(const int&amp; v) {<br>//v += 10;<br>cout &lt;&lt; v &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误\n//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;\nconst int&amp; ref = 10;\n\n//ref = 100;  //加入const后不可以修改变量\ncout &lt;&lt; ref &lt;&lt; endl;\n\n//函数中利用常量引用防止误操作修改实参\nint a = 10;\nshowValue(a);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3 函数提高<br>3.1 函数默认参数<br>在 C++中，函数的形参列表中的形参是可以有默认值的。</p>\n<p>语法：返回值类型 函数名 （参数= 默认值）{}</p>\n<p>示例：</p>\n<p>C++<br>int func(int a, int b = 10, int c = 10) {<br>return a + b + c;<br>}</p>\n<p>//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值<br>//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数<br>int func2(int a = 10, int b = 10);<br>int func2(int a, int b) {<br>return a + b;<br>}</p>\n<p>int main() {</p>\n<pre><code>cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;\ncout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.2 函数占位参数<br>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>\n<p>语法： 返回值类型 函数名 (数据类型){}</p>\n<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>\n<p>示例：</p>\n<p>C++<br>//函数占位参数 ，占位参数也可以有默认参数<br>void func(int a, int) {<br>cout &lt;&lt; “this is func” &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>func(10,10); //占位参数必须填补\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.3 函数重载<br>3.3.1 函数重载概述<br>作用：函数名可以相同，提高复用性</p>\n<p>函数重载满足条件：</p>\n<p>同一个作用域下<br>函数名称相同<br>函数参数类型不同 或者 个数不同 或者 顺序不同<br>注意: 函数的返回值不可以作为函数重载的条件</p>\n<p>示例：</p>\n<p>C++<br>//函数重载需要函数都在同一个作用域下<br>void func()<br>{<br>cout &lt;&lt; “func 的调用！” &lt;&lt; endl;<br>}<br>void func(int a)<br>{<br>cout &lt;&lt; “func (int a) 的调用！” &lt;&lt; endl;<br>}<br>void func(double a)<br>{<br>cout &lt;&lt; “func (double a)的调用！” &lt;&lt; endl;<br>}<br>void func(int a ,double b)<br>{<br>cout &lt;&lt; “func (int a ,double b) 的调用！” &lt;&lt; endl;<br>}<br>void func(double a ,int b)<br>{<br>cout &lt;&lt; “func (double a ,int b)的调用！” &lt;&lt; endl;<br>}</p>\n<p>//函数返回值不可以作为函数重载条件<br>//int func(double a, int b)<br>//{<br>// cout &lt;&lt; “func (double a ,int b)的调用！” &lt;&lt; endl;<br>//}</p>\n<p>int main() {</p>\n<pre><code>func();\nfunc(10);\nfunc(3.14);\nfunc(10,3.14);\nfunc(3.14 , 10);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3.3.2 函数重载注意事项<br>引用作为重载条件<br>函数重载碰到函数默认参数<br>示例：</p>\n<p>C++<br>//函数重载注意事项<br>//1、引用作为重载条件</p>\n<p>void func(int &amp;a)<br>{<br>cout &lt;&lt; “func (int &amp;a) 调用 “ &lt;&lt; endl;<br>}</p>\n<p>void func(const int &amp;a)<br>{<br>cout &lt;&lt; “func (const int &amp;a) 调用 “ &lt;&lt; endl;<br>}</p>\n<p>//2、函数重载碰到函数默认参数</p>\n<p>void func2(int a, int b = 10)<br>{<br>cout &lt;&lt; “func2(int a, int b = 10) 调用” &lt;&lt; endl;<br>}</p>\n<p>void func2(int a)<br>{<br>cout &lt;&lt; “func2(int a) 调用” &lt;&lt; endl;<br>}</p>\n<p>int main() {<br>int a = 10;<br>func(a); //调用无 const<br>func(10);//调用有 const</p>\n<pre><code>//func2(10); //碰到默认参数产生歧义，需要避免\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4 类和对象<br>C++面向对象的三大特性为：==封装、继承、多态==</p>\n<p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p>\n<p>例如：</p>\n<p>​ 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>\n<p>​ 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>\n<p>​ 具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p>\n<p>4.1 封装<br>4.1.1 封装的意义<br>封装是 C++面向对象三大特性之一</p>\n<p>封装的意义：</p>\n<p>将属性和行为作为一个整体，表现生活中的事物<br>将属性和行为加以权限控制<br>封装意义一：</p>\n<p>​ 在设计类的时候，属性和行为写在一起，表现事物</p>\n<p>语法： class 类名{ 访问权限： 属性 / 行为 };</p>\n<p>示例 1：设计一个圆类，求圆的周长</p>\n<p>示例代码：</p>\n<p>C++<br>//圆周率<br>const double PI = 3.14;</p>\n<p>//1、封装的意义<br>//将属性和行为作为一个整体，用来表现生活中的事物</p>\n<p>//封装一个圆类，求圆的周长<br>//class 代表设计一个类，后面跟着的是类名<br>class Circle<br>{<br>public: //访问权限 公共的权限</p>\n<pre><code>//属性\nint m_r;//半径\n\n//行为\n//获取到圆的周长\ndouble calculateZC()\n{\n    //2 * pi  * r\n    //获取圆的周长\n    return  2 * PI * m_r;\n}</code></pre><p>};</p>\n<p>int main() {</p>\n<pre><code>//通过圆类，创建圆的对象\n// c1就是一个具体的圆\nCircle c1;\nc1.m_r = 10; //给圆对象的半径 进行赋值操作\n\n//2 * pi * 10 = = 62.8\ncout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>\n<p>示例 2 代码：</p>\n<p>C++<br>//学生类<br>class Student {<br>public:<br>void setName(string name) {<br>m_name = name;<br>}<br>void setID(int id) {<br>m_id = id;<br>}</p>\n<pre><code>void showStudent() {\n    cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;\n}</code></pre><p>public:<br>string m_name;<br>int m_id;<br>};</p>\n<p>int main() {</p>\n<pre><code>Student stu;\nstu.setName(&quot;德玛西亚&quot;);\nstu.setID(250);\nstu.showStudent();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>封装意义二：</p>\n<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>\n<p>访问权限有三种：</p>\n<p>public 公共权限<br>protected 保护权限<br>private 私有权限<br>示例：</p>\n<p>C++<br>//三种权限<br>//公共权限 public 类内可以访问 类外可以访问<br>//保护权限 protected 类内可以访问 类外不可以访问<br>//私有权限 private 类内可以访问 类外不可以访问</p>\n<p>class Person<br>{<br>//姓名 公共权限<br>public:<br>string m_Name;</p>\n<pre><code>//汽车  保护权限</code></pre><p>protected:<br>string m_Car;</p>\n<pre><code>//银行卡密码  私有权限</code></pre><p>private:<br>int m_Password;</p>\n<p>public:<br>void func()<br>{<br>m_Name = “张三”;<br>m_Car = “拖拉机”;<br>m_Password = 123456;<br>}<br>};</p>\n<p>int main() {</p>\n<pre><code>Person p;\np.m_Name = &quot;李四&quot;;\n//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到\n//p.m_Password = 123; //私有权限类外访问不到\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.1.2 struct 和 class 区别<br>在 C++中 struct 和 class 唯一的区别就在于 默认的访问权限不同</p>\n<p>区别：</p>\n<p>struct 默认权限为公共<br>class 默认权限为私有<br>C++<br>class C1<br>{<br>int m_A; //默认是私有权限<br>};</p>\n<p>struct C2<br>{<br>int m_A; //默认是公共权限<br>};</p>\n<p>int main() {</p>\n<pre><code>C1 c1;\nc1.m_A = 10; //错误，访问权限是私有\n\nC2 c2;\nc2.m_A = 10; //正确，访问权限是公共\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.1.3 成员属性设置为私有<br>优点 1：将所有成员属性设置为私有，可以自己控制读写权限</p>\n<p>优点 2：对于写权限，我们可以检测数据的有效性</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:</p>\n<pre><code>//姓名设置可读可写\nvoid setName(string name) {\n    m_Name = name;\n}\nstring getName()\n{\n    return m_Name;\n}\n\n\n//获取年龄\nint getAge() {\n    return m_Age;\n}\n//设置年龄\nvoid setAge(int age) {\n    if (age &lt; 0 || age &gt; 150) {\n        cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;\n        return;\n    }\n    m_Age = age;\n}\n\n//情人设置为只写\nvoid setLover(string lover) {\n    m_Lover = lover;\n}</code></pre><p>private:<br>string m_Name; //可读可写 姓名<br>int m_Age; //只读 年龄</p>\n<pre><code>string m_Lover; //只写  情人</code></pre><p>};</p>\n<p>int main() {</p>\n<pre><code>Person p;\n//姓名设置\np.setName(&quot;张三&quot;);\ncout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;\n\n//年龄设置\np.setAge(50);\ncout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;\n\n//情人设置\np.setLover(&quot;苍井&quot;);\n//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>练习案例 1：设计立方体类</p>\n<p>设计立方体类(Cube)</p>\n<p>求出立方体的面积和体积</p>\n<p>分别用全局函数和成员函数判断两个立方体是否相等。</p>\n<p>1545533548532<br>1545533548532</p>\n<p>练习案例 2：点和圆的关系</p>\n<p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p>\n<p>1545533829184<br>1545533829184</p>\n<p>4.2 对象的初始化和清理<br>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全<br>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。<br>4.2.1 构造函数和析构函数<br>对象的初始化和清理也是两个非常重要的安全问题</p>\n<p>​ 一个对象或者变量没有初始状态，对其使用后果是未知</p>\n<p>​ 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>\n<p>c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>\n<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供</p>\n<p>编译器提供的构造函数和析构函数是空实现。</p>\n<p>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。<br>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。<br>构造函数语法：类名(){}</p>\n<p>构造函数，没有返回值也不写 void<br>函数名称与类名相同<br>构造函数可以有参数，因此可以发生重载<br>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次<br>析构函数语法： ~类名(){}</p>\n<p>析构函数，没有返回值也不写 void<br>函数名称与类名相同,在名称前加上符号 ~<br>析构函数不可以有参数，因此不可以发生重载<br>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次<br>C++<br>class Person<br>{<br>public:<br>//构造函数<br>Person()<br>{<br>cout &lt;&lt; “Person 的构造函数调用” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person()<br>{<br>cout &lt;&lt; “Person 的析构函数调用” &lt;&lt; endl;<br>}</p>\n<p>};</p>\n<p>void test01()<br>{<br>Person p;<br>}</p>\n<p>int main() {<br>test01();</p>\n<pre><code>system(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.2 构造函数的分类及调用<br>两种分类方式：</p>\n<p>​ 按参数分为： 有参构造和无参构造</p>\n<p>​ 按类型分为： 普通构造和拷贝构造</p>\n<p>三种调用方式：</p>\n<p>​ 括号法</p>\n<p>​ 显示法</p>\n<p>​ 隐式转换法</p>\n<p>示例：</p>\n<p>C++<br>//1、构造函数分类<br>// 按照参数分类分为 有参和无参构造 无参又称为默认构造函数<br>// 按照类型分类分为 普通构造和拷贝构造</p>\n<p>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int a) {<br>age = a;<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>}<br>//拷贝构造函数<br>Person(const Person&amp; p) {<br>age = p.age;<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int age;<br>};</p>\n<p>//2、构造函数的调用<br>//调用无参构造函数<br>void test01() {<br>Person p; //调用无参构造函数<br>}</p>\n<p>//调用有参的构造函数<br>void test02() {</p>\n<pre><code>//2.1  括号法，常用\nPerson p1(10);\n//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n//Person p2();\n\n//2.2 显式法\nPerson p2 = Person(10);\nPerson p3 = Person(p2);\n//Person(10)单独写就是匿名对象  当前行结束之后，马上析构\n\n//2.3 隐式转换法\nPerson p4 = 10; // Person p4 = Person(10);\nPerson p5 = p4; // Person p5 = Person(p4);\n\n//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\n//Person p5(p4);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n//test02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.3 拷贝构造函数调用时机<br>C++中拷贝构造函数调用时机通常有三种情况</p>\n<p>使用一个已经创建完毕的对象来初始化一个新对象<br>值传递的方式给函数参数传值<br>以值方式返回局部对象<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>mAge = 0;<br>}<br>Person(int age) {<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>mAge = age;<br>}<br>Person(const Person&amp; p) {<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>mAge = p.mAge;<br>}<br>//析构函数在释放内存之前调用<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int mAge;<br>};</p>\n<p>//1. 使用一个已经创建完毕的对象来初始化一个新对象<br>void test01() {</p>\n<pre><code>Person man(100); //p对象已经创建完毕\nPerson newman(man); //调用拷贝构造函数\nPerson newman2 = man; //拷贝构造\n\n//Person newman3;\n//newman3 = man; //不是调用拷贝构造函数，赋值操作</code></pre><p>}</p>\n<p>//2. 值传递的方式给函数参数传值<br>//相当于 Person p1 = p;<br>void doWork(Person p1) {}<br>void test02() {<br>Person p; //无参构造函数<br>doWork(p);<br>}</p>\n<p>//3. 以值方式返回局部对象<br>Person doWork2()<br>{<br>Person p1;<br>cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;<br>return p1;<br>}</p>\n<p>void test03()<br>{<br>Person p = doWork2();<br>cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n//test02();\ntest03();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.4 构造函数调用规则<br>默认情况下，c++编译器至少给一个类添加 3 个函数</p>\n<p>1．默认构造函数(无参，函数体为空)</p>\n<p>2．默认析构函数(无参，函数体为空)</p>\n<p>3．默认拷贝构造函数，对属性进行值拷贝</p>\n<p>构造函数调用规则如下：</p>\n<p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造<br>如果用户定义拷贝构造函数，c++不会再提供其他构造函数<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int a) {<br>age = a;<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;<br>}<br>//拷贝构造函数<br>Person(const Person&amp; p) {<br>age = p.age;<br>cout &lt;&lt; “拷贝构造函数!” &lt;&lt; endl;<br>}<br>//析构函数<br>~Person() {<br>cout &lt;&lt; “析构函数!” &lt;&lt; endl;<br>}<br>public:<br>int age;<br>};</p>\n<p>void test01()<br>{<br>Person p1(18);<br>//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作<br>Person p2(p1);</p>\n<pre><code>cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;</code></pre><p>}</p>\n<p>void test02()<br>{<br>//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造<br>Person p1; //此时如果用户自己没有提供默认构造，会出错<br>Person p2(10); //用户提供的有参<br>Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供</p>\n<pre><code>//如果用户提供拷贝构造，编译器不会提供其他构造函数\nPerson p4; //此时如果用户自己没有提供默认构造，会出错\nPerson p5(10); //此时如果用户自己没有提供有参，会出错\nPerson p6(p5); //用户自己提供拷贝构造</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.5 深拷贝与浅拷贝<br>深浅拷贝是面试经典问题，也是常见的一个坑</p>\n<p>浅拷贝：简单的赋值拷贝操作</p>\n<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:<br>//无参（默认）构造函数<br>Person() {<br>cout &lt;&lt; “无参构造函数!” &lt;&lt; endl;<br>}<br>//有参构造函数<br>Person(int age ,int height) {<br>cout &lt;&lt; “有参构造函数!” &lt;&lt; endl;</p>\n<pre><code>    m_age = age;\n    m_height = new int(height);\n\n}\n//拷贝构造函数\nPerson(const Person&amp; p) {\n    cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n    //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题\n    m_age = p.m_age;\n    m_height = new int(*p.m_height);\n\n}\n\n//析构函数\n~Person() {\n    cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n    if (m_height != NULL)\n    {\n        delete m_height;\n    }\n}</code></pre><p>public:<br>int m_age;<br>int* m_height;<br>};</p>\n<p>void test01()<br>{<br>Person p1(18, 180);</p>\n<pre><code>Person p2(p1);\n\ncout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>\n<p>4.2.6 初始化列表<br>作用：</p>\n<p>C++提供了初始化列表语法，用来初始化属性</p>\n<p>语法：构造函数()：属性 1(值 1),属性 2（值 2）… {}</p>\n<p>示例：</p>\n<p>C++<br>class Person {<br>public:</p>\n<pre><code>////传统方式初始化\n//Person(int a, int b, int c) {\n//    m_A = a;\n//    m_B = b;\n//    m_C = c;\n//}\n\n//初始化列表方式初始化\nPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}\nvoid PrintPerson() {\n    cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;\n    cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;\n    cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;\n}</code></pre><p>private:<br>int m_A;<br>int m_B;<br>int m_C;<br>};</p>\n<p>int main() {</p>\n<pre><code>Person p(1, 2, 3);\np.PrintPerson();\n\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.7 类对象作为类成员<br>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>\n<p>例如：</p>\n<p>C++<br>class A {}<br>class B<br>{<br>A a；<br>}<br>B 类中有对象 A 作为成员，A 为对象成员</p>\n<p>那么当创建 B 对象时，A 与 B 的构造和析构的顺序是谁先谁后？</p>\n<p>示例：</p>\n<p>C++<br>class Phone<br>{<br>public:<br>Phone(string name)<br>{<br>m_PhoneName = name;<br>cout &lt;&lt; “Phone 构造” &lt;&lt; endl;<br>}</p>\n<pre><code>~Phone()\n{\n    cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;\n}\n\nstring m_PhoneName;</code></pre><p>};</p>\n<p>class Person<br>{<br>public:</p>\n<pre><code>//初始化列表可以告诉编译器调用哪一个构造函数\nPerson(string name, string pName) :m_Name(name), m_Phone(pName)\n{\n    cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;\n}\n\n~Person()\n{\n    cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;\n}\n\nvoid playGame()\n{\n    cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;\n}\n\nstring m_Name;\nPhone m_Phone;</code></pre><p>};<br>void test01()<br>{<br>//当类中成员是其他类对象时，我们称该成员为 对象成员<br>//构造的顺序是 ：先调用对象成员的构造，再调用本类构造<br>//析构顺序与构造相反<br>Person p(“张三” , “苹果 X”);<br>p.playGame();</p>\n<p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.2.8 静态成员<br>静态成员就是在成员变量和成员函数前加上关键字 static，称为静态成员</p>\n<p>静态成员分为：</p>\n<p>静态成员变量<br>所有对象共享同一份数据<br>在编译阶段分配内存<br>类内声明，类外初始化<br>静态成员函数<br>所有对象共享同一个函数<br>静态成员函数只能访问静态成员变量<br>示例 1 ：静态成员变量</p>\n<p>C++<br>class Person<br>{<br>public:</p>\n<pre><code>static int m_A; //静态成员变量\n\n//静态成员变量特点：\n//1 在编译阶段分配内存\n//2 类内声明，类外初始化\n//3 所有对象共享同一份数据</code></pre><p>private:<br>static int m_B; //静态成员变量也是有访问权限的<br>};<br>int Person::m_A = 10;<br>int Person::m_B = 10;</p>\n<p>void test01()<br>{<br>//静态成员变量两种访问方式</p>\n<pre><code>//1、通过对象\nPerson p1;\np1.m_A = 100;\ncout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl;\n\nPerson p2;\np2.m_A = 200;\ncout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据\ncout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl;\n\n//2、通过类名\ncout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl;\n\n\n//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>示例 2：静态成员函数</p>\n<p>C++<br>class Person<br>{</p>\n<p>public:</p>\n<pre><code>//静态成员函数特点：\n//1 程序共享一个函数\n//2 静态成员函数只能访问静态成员变量\n\nstatic void func()\n{\n    cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;\n    m_A = 100;\n    //m_B = 100; //错误，不可以访问非静态成员变量\n}\n\nstatic int m_A; //静态成员变量\nint m_B; //</code></pre><p>private:</p>\n<pre><code>//静态成员函数也是有访问权限的\nstatic void func2()\n{\n    cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;\n}</code></pre><p>};<br>int Person::m_A = 10;</p>\n<p>void test01()<br>{<br>//静态成员变量两种访问方式</p>\n<pre><code>//1、通过对象\nPerson p1;\np1.func();\n\n//2、通过类名\nPerson::func();\n\n\n//Person::func2(); //私有权限访问不到</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3 C++对象模型和 this 指针<br>4.3.1 成员变量和成员函数分开存储<br>在 C++中，类内的成员变量和成员函数分开存储</p>\n<p>只有非静态成员变量才属于类的对象上</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>mA = 0;<br>}<br>//非静态成员变量占对象空间<br>int mA;<br>//静态成员变量不占对象空间<br>static int mB;<br>//函数也不占对象空间，所有函数共享一个函数实例<br>void func() {<br>cout &lt;&lt; “mA:” &lt;&lt; this-&gt;mA &lt;&lt; endl;<br>}<br>//静态成员函数也不占对象空间<br>static void sfunc() {<br>}<br>};</p>\n<p>int main() {</p>\n<pre><code>cout &lt;&lt; sizeof(Person) &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.2 this 指针概念<br>通过 4.3.1 我们知道在 C++中成员变量和成员函数是分开存储的</p>\n<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>\n<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>\n<p>c++通过提供特殊的对象指针，this 指针，解决上述问题。this 指针指向被调用的成员函数所属的对象</p>\n<p>this 指针是隐含每一个非静态成员函数内的一种指针</p>\n<p>this 指针不需要定义，直接使用即可</p>\n<p>this 指针的用途：</p>\n<p>当形参和成员变量同名时，可用 this 指针来区分<br>在类的非静态成员函数中返回对象本身，可使用 return *this<br>C++<br>class Person<br>{<br>public:</p>\n<pre><code>Person(int age)\n{\n    //1、当形参和成员变量同名时，可用this指针来区分\n    this-&gt;age = age;\n}\n\nPerson&amp; PersonAddPerson(Person p)\n{\n    this-&gt;age += p.age;\n    //返回对象本身\n    return *this;\n}\n\nint age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>Person p1(10);<br>cout &lt;&lt; “p1.age = “ &lt;&lt; p1.age &lt;&lt; endl;</p>\n<pre><code>Person p2(10);\np2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\ncout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.3 空指针访问成员函数<br>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针</p>\n<p>如果用到 this 指针，需要加以判断保证代码的健壮性</p>\n<p>示例：</p>\n<p>C++<br>//空指针访问成员函数<br>class Person {<br>public:</p>\n<pre><code>void ShowClassName() {\n    cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;\n}\n\nvoid ShowPerson() {\n    if (this == NULL) {\n        return;\n    }\n    cout &lt;&lt; mAge &lt;&lt; endl;\n}</code></pre><p>public:<br>int mAge;<br>};</p>\n<p>void test01()<br>{<br>Person * p = NULL;<br>p-&gt;ShowClassName(); //空指针，可以调用成员函数<br>p-&gt;ShowPerson(); //但是如果成员函数中用到了 this 指针，就不可以了<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.3.4 const 修饰成员函数<br>常函数：</p>\n<p>成员函数后加 const 后我们称为这个函数为常函数<br>常函数内不可以修改成员属性<br>成员属性声明时加关键字 mutable 后，在常函数中依然可以修改<br>常对象：</p>\n<p>声明对象前加 const 称该对象为常对象<br>常对象只能调用常函数<br>示例：</p>\n<p>C++<br>class Person {<br>public:<br>Person() {<br>m_A = 0;<br>m_B = 0;<br>}</p>\n<pre><code>//this指针的本质是一个指针常量，指针的指向不可修改\n//如果想让指针指向的值也不可以修改，需要声明常函数\nvoid ShowPerson() const {\n    //const Type* const pointer;\n    //this = NULL; //不能修改指针的指向 Person* const this;\n    //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的\n\n    //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量\n    this-&gt;m_B = 100;\n}\n\nvoid MyFunc() const {\n    //mA = 10000;\n}</code></pre><p>public:<br>int m_A;<br>mutable int m_B; //可修改 可变的<br>};</p>\n<p>//const 修饰对象 常对象<br>void test01() {</p>\n<pre><code>const Person person; //常量对象\ncout &lt;&lt; person.m_A &lt;&lt; endl;\n//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问\nperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量\n\n//常对象访问成员函数\nperson.MyFunc(); //常对象不能调用const的函数</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.4 友元<br>生活中你的家有客厅(Public)，有你的卧室(Private)</p>\n<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>\n<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>\n<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>\n<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>\n<p>友元的关键字为 ==friend==</p>\n<p>友元的三种实现</p>\n<p>全局函数做友元<br>类做友元<br>成员函数做友元<br>4.4.1 全局函数做友元<br>C++<br>class Building<br>{<br>//告诉编译器 goodGay 全局函数 是 Building 类的好朋友，可以访问类中的私有内容<br>friend void goodGay(Building * building);</p>\n<p>public:</p>\n<pre><code>Building()\n{\n    this-&gt;m_SittingRoom = &quot;客厅&quot;;\n    this-&gt;m_BedRoom = &quot;卧室&quot;;\n}</code></pre><p>public:<br>string m_SittingRoom; //客厅</p>\n<p>private:<br>string m_BedRoom; //卧室<br>};</p>\n<p>void goodGay(Building * building)<br>{<br>cout &lt;&lt; “好基友正在访问： “ &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问： “ &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>Building b;<br>goodGay(&amp;b);<br>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.4.2 类做友元<br>C++<br>class Building;<br>class goodGay<br>{<br>public:</p>\n<pre><code>goodGay();\nvoid visit();</code></pre><p>private:<br>Building *building;<br>};</p>\n<p>class Building<br>{<br>//告诉编译器 goodGay 类是 Building 类的好朋友，可以访问到 Building 类中私有内容<br>friend class goodGay;</p>\n<p>public:<br>Building();</p>\n<p>public:<br>string m_SittingRoom; //客厅<br>private:<br>string m_BedRoom;//卧室<br>};</p>\n<p>Building::Building()<br>{<br>this-&gt;m_SittingRoom = “客厅”;<br>this-&gt;m_BedRoom = “卧室”;<br>}</p>\n<p>goodGay::goodGay()<br>{<br>building = new Building;<br>}</p>\n<p>void goodGay::visit()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>goodGay gg;<br>gg.visit();</p>\n<p>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.4.3 成员函数做友元<br>C++</p>\n<p>class Building;<br>class goodGay<br>{<br>public:</p>\n<pre><code>goodGay();\nvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\nvoid visit2();</code></pre><p>private:<br>Building *building;<br>};</p>\n<p>class Building<br>{<br>//告诉编译器 goodGay 类中的 visit 成员函数 是 Building 好朋友，可以访问私有内容<br>friend void goodGay::visit();</p>\n<p>public:<br>Building();</p>\n<p>public:<br>string m_SittingRoom; //客厅<br>private:<br>string m_BedRoom;//卧室<br>};</p>\n<p>Building::Building()<br>{<br>this-&gt;m_SittingRoom = “客厅”;<br>this-&gt;m_BedRoom = “卧室”;<br>}</p>\n<p>goodGay::goodGay()<br>{<br>building = new Building;<br>}</p>\n<p>void goodGay::visit()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void goodGay::visit2()<br>{<br>cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>//cout &lt;&lt; “好基友正在访问” &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>goodGay gg;<br>gg.visit();</p>\n<p>}</p>\n<p>int main(){</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn 0;</code></pre><p>}<br>4.5 运算符重载<br>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>\n<p>4.5.1 加号运算符重载<br>作用：实现两个自定义数据类型相加的运算</p>\n<p>C++<br>class Person {<br>public:<br>Person() {};<br>Person(int a, int b)<br>{<br>this-&gt;m_A = a;<br>this-&gt;m_B = b;<br>}<br>//成员函数实现 + 号运算符重载<br>Person operator+(const Person&amp; p) {<br>Person temp;<br>temp.m_A = this-&gt;m_A + p.m_A;<br>temp.m_B = this-&gt;m_B + p.m_B;<br>return temp;<br>}</p>\n<p>public:<br>int m_A;<br>int m_B;<br>};</p>\n<p>//全局函数实现 + 号运算符重载<br>//Person operator+(const Person&amp; p1, const Person&amp; p2) {<br>// Person temp(0, 0);<br>// temp.m_A = p1.m_A + p2.m_A;<br>// temp.m_B = p1.m_B + p2.m_B;<br>// return temp;<br>//}</p>\n<p>//运算符重载 可以发生函数重载<br>Person operator+(const Person&amp; p2, int val)<br>{<br>Person temp;<br>temp.m_A = p2.m_A + val;<br>temp.m_B = p2.m_B + val;<br>return temp;<br>}</p>\n<p>void test() {</p>\n<pre><code>Person p1(10, 10);\nPerson p2(20, 20);\n\n//成员函数方式\nPerson p3 = p2 + p1;  //相当于 p2.operaor+(p1)\ncout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;\n\n\nPerson p4 = p3 + 10; //相当于 operator+(p3,10)\ncout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结 1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>\n<p>总结 2：不要滥用运算符重载</p>\n<p>4.5.2 左移运算符重载<br>作用：可以输出自定义数据类型</p>\n<p>C++<br>class Person {<br>friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);</p>\n<p>public:</p>\n<pre><code>Person(int a, int b)\n{\n    this-&gt;m_A = a;\n    this-&gt;m_B = b;\n}\n\n//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果\n//void operator&lt;&lt;(Person&amp; p){\n//}</code></pre><p>private:<br>int m_A;<br>int m_B;<br>};</p>\n<p>//全局函数实现左移重载<br>//ostream 对象只能有一个<br>ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) {<br>out &lt;&lt; “a:” &lt;&lt; p.m_A &lt;&lt; “ b:” &lt;&lt; p.m_B;<br>return out;<br>}</p>\n<p>void test() {</p>\n<pre><code>Person p1(10, 20);\n\ncout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>\n<p>4.5.3 递增运算符重载<br>作用： 通过重载递增运算符，实现自己的整型数据</p>\n<p>C++</p>\n<p>class MyInteger {</p>\n<pre><code>friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);</code></pre><p>public:<br>MyInteger() {<br>m_Num = 0;<br>}<br>//前置++<br>MyInteger&amp; operator++() {<br>//先++<br>m_Num++;<br>//再返回<br>return *this;<br>}</p>\n<pre><code>//后置++\nMyInteger operator++(int) {\n    //先返回\n    MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；\n    m_Num++;\n    return temp;\n}</code></pre><p>private:<br>int m_Num;<br>};</p>\n<p>ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) {<br>out &lt;&lt; myint.m_Num;<br>return out;<br>}</p>\n<p>//前置++ 先++ 再返回<br>void test01() {<br>MyInteger myInt;<br>cout &lt;&lt; ++myInt &lt;&lt; endl;<br>cout &lt;&lt; myInt &lt;&lt; endl;<br>}</p>\n<p>//后置++ 先返回 再++<br>void test02() {</p>\n<pre><code>MyInteger myInt;\ncout &lt;&lt; myInt++ &lt;&lt; endl;\ncout &lt;&lt; myInt &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n//test02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 前置递增返回引用，后置递增返回值</p>\n<p>4.5.4 赋值运算符重载<br>c++编译器至少给一个类添加 4 个函数</p>\n<p>默认构造函数(无参，函数体为空)<br>默认析构函数(无参，函数体为空)<br>默认拷贝构造函数，对属性进行值拷贝<br>赋值运算符 operator=, 对属性进行值拷贝<br>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>\n<p>示例：</p>\n<p>C++<br>class Person<br>{<br>public:</p>\n<pre><code>Person(int age)\n{\n    //将年龄数据开辟到堆区\n    m_Age = new int(age);\n}\n\n//重载赋值运算符\nPerson&amp; operator=(Person &amp;p)\n{\n    if (m_Age != NULL)\n    {\n        delete m_Age;\n        m_Age = NULL;\n    }\n    //编译器提供的代码是浅拷贝\n    //m_Age = p.m_Age;\n\n    //提供深拷贝 解决浅拷贝的问题\n    m_Age = new int(*p.m_Age);\n\n    //返回自身\n    return *this;\n}\n\n\n~Person()\n{\n    if (m_Age != NULL)\n    {\n        delete m_Age;\n        m_Age = NULL;\n    }\n}\n\n//年龄的指针\nint *m_Age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>Person p1(18);</p>\n<pre><code>Person p2(20);\n\nPerson p3(30);\n\np3 = p2 = p1; //赋值操作\n\ncout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;\n\ncout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\n//int a = 10;\n//int b = 20;\n//int c = 30;\n\n//c = b = a;\n//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\n//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.5.5 关系运算符重载<br>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p>\n<p>示例：</p>\n<p>C++<br>class Person<br>{<br>public:<br>Person(string name, int age)<br>{<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>};</p>\n<pre><code>bool operator==(Person &amp; p)\n{\n    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nbool operator!=(Person &amp; p)\n{\n    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}\n\nstring m_Name;\nint m_Age;</code></pre><p>};</p>\n<p>void test01()<br>{<br>//int a = 0;<br>//int b = 0;</p>\n<pre><code>Person a(&quot;孙悟空&quot;, 18);\nPerson b(&quot;孙悟空&quot;, 18);\n\nif (a == b)\n{\n    cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n}\n\nif (a != b)\n{\n    cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.5.6 函数调用运算符重载<br>函数调用运算符 () 也可以重载<br>由于重载后使用的方式非常像函数的调用，因此称为仿函数<br>仿函数没有固定写法，非常灵活<br>示例：</p>\n<p>C++<br>class MyPrint<br>{<br>public:<br>void operator()(string text)<br>{<br>cout &lt;&lt; text &lt;&lt; endl;<br>}</p>\n<p>};<br>void test01()<br>{<br>//重载的（）操作符 也称为仿函数<br>MyPrint myFunc;<br>myFunc(“hello world”);<br>}</p>\n<p>class MyAdd<br>{<br>public:<br>int operator()(int v1, int v2)<br>{<br>return v1 + v2;<br>}<br>};</p>\n<p>void test02()<br>{<br>MyAdd add;<br>int ret = add(10, 10);<br>cout &lt;&lt; “ret = “ &lt;&lt; ret &lt;&lt; endl;</p>\n<pre><code>//匿名对象调用\ncout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.6 继承<br>继承是面向对象三大特性之一</p>\n<p>有些类与类之间存在特殊的关系，例如下图中：</p>\n<p>1544861202252<br>1544861202252</p>\n<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>\n<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>\n<p>4.6.1 继承的基本语法<br>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>\n<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>\n<p>普通实现：</p>\n<p>C++<br>//Java 页面<br>class Java<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “JAVA 学科视频” &lt;&lt; endl;<br>}<br>};<br>//Python 页面<br>class Python<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “Python 学科视频” &lt;&lt; endl;<br>}<br>};<br>//C++页面<br>class CPP<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}<br>void footer()<br>{<br>cout &lt;&lt; “帮助中心、交流合作、站内地图…(公共底部)” &lt;&lt; endl;<br>}<br>void left()<br>{<br>cout &lt;&lt; “Java,Python,C++…(公共分类列表)” &lt;&lt; endl;<br>}<br>void content()<br>{<br>cout &lt;&lt; “C++学科视频” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//Java 页面<br>cout &lt;&lt; “Java 下载视频页面如下： “ &lt;&lt; endl;<br>Java ja;<br>ja.header();<br>ja.footer();<br>ja.left();<br>ja.content();<br>cout &lt;&lt; “——————–” &lt;&lt; endl;</p>\n<pre><code>//Python页面\ncout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\nPython py;\npy.header();\npy.footer();\npy.left();\npy.content();\ncout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n//C++页面\ncout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\nCPP cp;\ncp.header();\ncp.footer();\ncp.left();\ncp.content();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>继承实现：</p>\n<p>C++<br>//公共页面<br>class BasePage<br>{<br>public:<br>void header()<br>{<br>cout &lt;&lt; “首页、公开课、登录、注册…（公共头部）” &lt;&lt; endl;<br>}</p>\n<pre><code>void footer()\n{\n    cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\n}\nvoid left()\n{\n    cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\n}</code></pre><p>};</p>\n<p>//Java 页面<br>class Java : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “JAVA 学科视频” &lt;&lt; endl;<br>}<br>};<br>//Python 页面<br>class Python : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “Python 学科视频” &lt;&lt; endl;<br>}<br>};<br>//C++页面<br>class CPP : public BasePage<br>{<br>public:<br>void content()<br>{<br>cout &lt;&lt; “C++学科视频” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//Java 页面<br>cout &lt;&lt; “Java 下载视频页面如下： “ &lt;&lt; endl;<br>Java ja;<br>ja.header();<br>ja.footer();<br>ja.left();<br>ja.content();<br>cout &lt;&lt; “——————–” &lt;&lt; endl;</p>\n<pre><code>//Python页面\ncout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\nPython py;\npy.header();\npy.footer();\npy.left();\npy.content();\ncout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n//C++页面\ncout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\nCPP cp;\ncp.header();\ncp.footer();\ncp.left();\ncp.content();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>继承的好处：==可以减少重复的代码==</p>\n<p>class A : public B;</p>\n<p>A 类称为子类 或 派生类</p>\n<p>B 类称为父类 或 基类</p>\n<p>派生类中的成员，包含两大部分：</p>\n<p>一类是从基类继承过来的，一类是自己增加的成员。</p>\n<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>\n<p>4.6.2 继承方式<br>继承的语法：class 子类 : 继承方式 父类</p>\n<p>继承方式一共有三种：</p>\n<p>公共继承<br>保护继承<br>私有继承<br>img<br>img</p>\n<p>示例：</p>\n<p>C++<br>class Base1<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};</p>\n<p>//公共继承<br>class Son1 :public Base1<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 public 权限<br>m_B; //可访问 protected 权限<br>//m_C; //不可访问<br>}<br>};</p>\n<p>void myClass()<br>{<br>Son1 s1;<br>s1.m_A; //其他类只能访问到公共权限<br>}</p>\n<p>//保护继承<br>class Base2<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};<br>class Son2:protected Base2<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 protected 权限<br>m_B; //可访问 protected 权限<br>//m_C; //不可访问<br>}<br>};<br>void myClass2()<br>{<br>Son2 s;<br>//s.m_A; //不可访问<br>}</p>\n<p>//私有继承<br>class Base3<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C;<br>};<br>class Son3:private Base3<br>{<br>public:<br>void func()<br>{<br>m_A; //可访问 private 权限<br>m_B; //可访问 private 权限<br>//m_C; //不可访问<br>}<br>};<br>class GrandSon3 :public Son3<br>{<br>public:<br>void func()<br>{<br>//Son3 是私有继承，所以继承 Son3 的属性在 GrandSon3 中都无法访问到<br>//m_A;<br>//m_B;<br>//m_C;<br>}<br>};<br>4.6.3 继承中的对象模型<br>问题：从父类继承过来的成员，哪些属于子类对象中？</p>\n<p>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>int m_A;<br>protected:<br>int m_B;<br>private:<br>int m_C; //私有成员只是被隐藏了，但是还是会继承下去<br>};</p>\n<p>//公共继承<br>class Son :public Base<br>{<br>public:<br>int m_D;<br>};</p>\n<p>void test01()<br>{<br>cout &lt;&lt; “sizeof Son = “ &lt;&lt; sizeof(Son) &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>利用工具查看：</p>\n<p>1545881904150<br>1545881904150</p>\n<p>打开工具窗口后，定位到当前 CPP 文件的盘符</p>\n<p>然后输入： cl /d1 reportSingleClassLayout 查看的类名 所属文件名</p>\n<p>效果如下图：</p>\n<p>1545882158050<br>1545882158050</p>\n<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>\n<p>4.6.4 继承中构造和析构顺序<br>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>\n<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>\n<p>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>Base()<br>{<br>cout &lt;&lt; “Base 构造函数!” &lt;&lt; endl;<br>}<br>~Base()<br>{<br>cout &lt;&lt; “Base 析构函数!” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Son : public Base<br>{<br>public:<br>Son()<br>{<br>cout &lt;&lt; “Son 构造函数!” &lt;&lt; endl;<br>}<br>~Son()<br>{<br>cout &lt;&lt; “Son 析构函数!” &lt;&lt; endl;<br>}</p>\n<p>};</p>\n<p>void test01()<br>{<br>//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反<br>Son s;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>\n<p>4.6.5 继承同名成员处理方式<br>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>\n<p>访问子类同名成员 直接访问即可<br>访问父类同名成员 需要加作用域<br>示例：</p>\n<p>C++<br>class Base {<br>public:<br>Base()<br>{<br>m_A = 100;<br>}</p>\n<pre><code>void func()\n{\n    cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;\n}\n\nvoid func(int a)\n{\n    cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;\n}</code></pre><p>public:<br>int m_A;<br>};</p>\n<p>class Son : public Base {<br>public:<br>Son()<br>{<br>m_A = 200;<br>}</p>\n<pre><code>//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\n//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\nvoid func()\n{\n    cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;\n}</code></pre><p>public:<br>int m_A;<br>};</p>\n<p>void test01()<br>{<br>Son s;</p>\n<pre><code>cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;\ncout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\n\ns.func();\ns.Base::func();\ns.Base::func(10);</code></pre><p>}<br>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\nreturn EXIT_SUCCESS;</code></pre><p>}<br>总结：</p>\n<p>子类对象可以直接访问到子类中同名成员<br>子类对象加作用域可以访问到父类同名成员<br>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数<br>4.6.6 继承同名静态成员处理方式<br>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>\n<p>静态成员和非静态成员出现同名，处理方式一致</p>\n<p>访问子类同名成员 直接访问即可<br>访问父类同名成员 需要加作用域<br>示例：</p>\n<p>C++<br>class Base {<br>public:<br>static void func()<br>{<br>cout &lt;&lt; “Base - static void func()” &lt;&lt; endl;<br>}<br>static void func(int a)<br>{<br>cout &lt;&lt; “Base - static void func(int a)” &lt;&lt; endl;<br>}</p>\n<pre><code>static int m_A;</code></pre><p>};</p>\n<p>int Base::m_A = 100;</p>\n<p>class Son : public Base {<br>public:<br>static void func()<br>{<br>cout &lt;&lt; “Son - static void func()” &lt;&lt; endl;<br>}<br>static int m_A;<br>};</p>\n<p>int Son::m_A = 200;</p>\n<p>//同名成员属性<br>void test01()<br>{<br>//通过对象访问<br>cout &lt;&lt; “通过对象访问： “ &lt;&lt; endl;<br>Son s;<br>cout &lt;&lt; “Son 下 m_A = “ &lt;&lt; s.m_A &lt;&lt; endl;<br>cout &lt;&lt; “Base 下 m_A = “ &lt;&lt; s.Base::m_A &lt;&lt; endl;</p>\n<pre><code>//通过类名访问\ncout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;\ncout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;</code></pre><p>}</p>\n<p>//同名成员函数<br>void test02()<br>{<br>//通过对象访问<br>cout &lt;&lt; “通过对象访问： “ &lt;&lt; endl;<br>Son s;<br>s.func();<br>s.Base::func();</p>\n<pre><code>cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\nSon::func();\nSon::Base::func();\n//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\nSon::Base::func(100);</code></pre><p>}<br>int main() {</p>\n<pre><code>//test01();\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>\n<p>4.6.7 多继承语法<br>C++允许一个类继承多个类</p>\n<p>语法：class 子类 ：继承方式 父类 1 ， 继承方式 父类 2…</p>\n<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>\n<p>C++实际开发中不建议用多继承</p>\n<p>示例：</p>\n<p>C++<br>class Base1 {<br>public:<br>Base1()<br>{<br>m_A = 100;<br>}<br>public:<br>int m_A;<br>};</p>\n<p>class Base2 {<br>public:<br>Base2()<br>{<br>m_A = 200; //开始是 m_B 不会出问题，但是改为 mA 就会出现不明确<br>}<br>public:<br>int m_A;<br>};</p>\n<p>//语法：class 子类：继承方式 父类 1 ，继承方式 父类 2<br>class Son : public Base2, public Base1<br>{<br>public:<br>Son()<br>{<br>m_C = 300;<br>m_D = 400;<br>}<br>public:<br>int m_C;<br>int m_D;<br>};</p>\n<p>//多继承容易产生成员同名的情况<br>//通过使用类名作用域可以区分调用哪一个基类的成员<br>void test01()<br>{<br>Son s;<br>cout &lt;&lt; “sizeof Son = “ &lt;&lt; sizeof(s) &lt;&lt; endl;<br>cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;<br>cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>\n<p>4.6.8 菱形继承<br>菱形继承概念：</p>\n<p>​ 两个派生类继承同一个基类</p>\n<p>​ 又有某个类同时继承者两个派生类</p>\n<p>​ 这种继承被称为菱形继承，或者钻石继承</p>\n<p>典型的菱形继承案例：</p>\n<p>IMG_256<br>IMG_256</p>\n<p>菱形继承问题：</p>\n<p>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</p>\n<p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>\n<p>示例：</p>\n<p>C++<br>class Animal<br>{<br>public:<br>int m_Age;<br>};</p>\n<p>//继承前加 virtual 关键字后，变为虚继承<br>//此时公共的父类 Animal 称为虚基类<br>class Sheep : virtual public Animal {};<br>class Tuo : virtual public Animal {};<br>class SheepTuo : public Sheep, public Tuo {};</p>\n<p>void test01()<br>{<br>SheepTuo st;<br>st.Sheep::m_Age = 100;<br>st.Tuo::m_Age = 200;</p>\n<pre><code>cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;\ncout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;\ncout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义<br>利用虚继承可以解决菱形继承问题<br>4.7 多态<br>4.7.1 多态的基本概念<br>多态是 C++面向对象三大特性之一</p>\n<p>多态分为两类</p>\n<p>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名<br>动态多态: 派生类和虚函数实现运行时多态<br>静态多态和动态多态区别：</p>\n<p>静态多态的函数地址早绑定 - 编译阶段确定函数地址<br>动态多态的函数地址晚绑定 - 运行阶段确定函数地址<br>下面通过案例进行讲解多态</p>\n<p>C++<br>class Animal<br>{<br>public:<br>//Speak 函数就是虚函数<br>//函数前面加上 virtual 关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。<br>virtual void speak()<br>{<br>cout &lt;&lt; “动物在说话” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Cat :public Animal<br>{<br>public:<br>void speak()<br>{<br>cout &lt;&lt; “小猫在说话” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Dog :public Animal<br>{<br>public:</p>\n<pre><code>void speak()\n{\n    cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;\n}</code></pre><p>};<br>//我们希望传入什么对象，那么就调用什么对象的函数<br>//如果函数地址在编译阶段就能确定，那么静态联编<br>//如果函数地址在运行阶段才能确定，就是动态联编</p>\n<p>void DoSpeak(Animal &amp; animal)<br>{<br>animal.speak();<br>}<br>//<br>//多态满足条件：<br>//1、有继承关系<br>//2、子类重写父类中的虚函数<br>//多态使用：<br>//父类指针或引用指向子类对象</p>\n<p>void test01()<br>{<br>Cat cat;<br>DoSpeak(cat);</p>\n<pre><code>Dog dog;\nDoSpeak(dog);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>多态满足条件</p>\n<p>有继承关系<br>子类重写父类中的虚函数<br>多态使用条件</p>\n<p>父类指针或引用指向子类对象<br>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p>\n<p>4.7.2 多态案例一-计算器类<br>案例描述：</p>\n<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>\n<p>多态的优点：</p>\n<p>代码组织结构清晰<br>可读性强<br>利于前期和后期的扩展以及维护<br>示例：</p>\n<p>C++<br>//普通实现<br>class Calculator {<br>public:<br>int getResult(string oper)<br>{<br>if (oper == “+”) {<br>return m_Num1 + m_Num2;<br>}<br>else if (oper == “-“) {<br>return m_Num1 - m_Num2;<br>}<br>else if (oper == “_”) {<br>return m_Num1 _ m_Num2;<br>}<br>//如果要提供新的运算，需要修改源码<br>}<br>public:<br>int m_Num1;<br>int m_Num2;<br>};</p>\n<p>void test01()<br>{<br>//普通实现测试<br>Calculator c;<br>c.m_Num1 = 10;<br>c.m_Num2 = 10;<br>cout &lt;&lt; c.m_Num1 &lt;&lt; “ + “ &lt;&lt; c.m_Num2 &lt;&lt; “ = “ &lt;&lt; c.getResult(“+”) &lt;&lt; endl;</p>\n<pre><code>cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;\n\ncout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;</code></pre><p>}</p>\n<p>//多态实现<br>//抽象计算器类<br>//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护<br>class AbstractCalculator<br>{<br>public :</p>\n<pre><code>virtual int getResult()\n{\n    return 0;\n}\n\nint m_Num1;\nint m_Num2;</code></pre><p>};</p>\n<p>//加法计算器<br>class AddCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 + m_Num2;<br>}<br>};</p>\n<p>//减法计算器<br>class SubCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 - m_Num2;<br>}<br>};</p>\n<p>//乘法计算器<br>class MulCalculator :public AbstractCalculator<br>{<br>public:<br>int getResult()<br>{<br>return m_Num1 * m_Num2;<br>}<br>};</p>\n<p>void test02()<br>{<br>//创建加法计算器<br>AbstractCalculator *abc = new AddCalculator;<br>abc-&gt;m_Num1 = 10;<br>abc-&gt;m_Num2 = 10;<br>cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; “ + “ &lt;&lt; abc-&gt;m_Num2 &lt;&lt; “ = “ &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;<br>delete abc; //用完了记得销毁</p>\n<pre><code>//创建减法计算器\nabc = new SubCalculator;\nabc-&gt;m_Num1 = 10;\nabc-&gt;m_Num2 = 10;\ncout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\ndelete abc;\n\n//创建乘法计算器\nabc = new MulCalculator;\nabc-&gt;m_Num1 = 10;\nabc-&gt;m_Num2 = 10;\ncout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\ndelete abc;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>\n<p>4.7.3 纯虚函数和抽象类<br>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>\n<p>因此可以将虚函数改为纯虚函数</p>\n<p>纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ;</p>\n<p>当类中有了纯虚函数，这个类也称为==抽象类==</p>\n<p>抽象类特点：</p>\n<p>无法实例化对象<br>子类必须重写抽象类中的纯虚函数，否则也属于抽象类<br>示例：</p>\n<p>C++<br>class Base<br>{<br>public:<br>//纯虚函数<br>//类中只要有一个纯虚函数就称为抽象类<br>//抽象类无法实例化对象<br>//子类必须重写父类中的纯虚函数，否则也属于抽象类<br>virtual void func() = 0;<br>};</p>\n<p>class Son :public Base<br>{<br>public:<br>virtual void func()<br>{<br>cout &lt;&lt; “func 调用” &lt;&lt; endl;<br>};<br>};</p>\n<p>void test01()<br>{<br>Base * base = NULL;<br>//base = new Base; // 错误，抽象类无法实例化对象<br>base = new Son;<br>base-&gt;func();<br>delete base;//记得销毁<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.7.4 多态案例二-制作饮品<br>案例描述：</p>\n<p>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</p>\n<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>\n<p>1545985945198<br>1545985945198</p>\n<p>示例：</p>\n<p>C++<br>//抽象制作饮品<br>class AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() = 0;<br>//冲泡<br>virtual void Brew() = 0;<br>//倒入杯中<br>virtual void PourInCup() = 0;<br>//加入辅料<br>virtual void PutSomething() = 0;<br>//规定流程<br>void MakeDrink() {<br>Boil();<br>Brew();<br>PourInCup();<br>PutSomething();<br>}<br>};</p>\n<p>//制作咖啡<br>class Coffee : public AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() {<br>cout &lt;&lt; “煮农夫山泉!” &lt;&lt; endl;<br>}<br>//冲泡<br>virtual void Brew() {<br>cout &lt;&lt; “冲泡咖啡!” &lt;&lt; endl;<br>}<br>//倒入杯中<br>virtual void PourInCup() {<br>cout &lt;&lt; “将咖啡倒入杯中!” &lt;&lt; endl;<br>}<br>//加入辅料<br>virtual void PutSomething() {<br>cout &lt;&lt; “加入牛奶!” &lt;&lt; endl;<br>}<br>};</p>\n<p>//制作茶水<br>class Tea : public AbstractDrinking {<br>public:<br>//烧水<br>virtual void Boil() {<br>cout &lt;&lt; “煮自来水!” &lt;&lt; endl;<br>}<br>//冲泡<br>virtual void Brew() {<br>cout &lt;&lt; “冲泡茶叶!” &lt;&lt; endl;<br>}<br>//倒入杯中<br>virtual void PourInCup() {<br>cout &lt;&lt; “将茶水倒入杯中!” &lt;&lt; endl;<br>}<br>//加入辅料<br>virtual void PutSomething() {<br>cout &lt;&lt; “加入枸杞!” &lt;&lt; endl;<br>}<br>};</p>\n<p>//业务函数<br>void DoWork(AbstractDrinking* drink) {<br>drink-&gt;MakeDrink();<br>delete drink;<br>}</p>\n<p>void test01() {<br>DoWork(new Coffee);<br>cout &lt;&lt; “————–” &lt;&lt; endl;<br>DoWork(new Tea);<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>4.7.5 虚析构和纯虚析构<br>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>\n<p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p>\n<p>虚析构和纯虚析构共性：</p>\n<p>可以解决父类指针释放子类对象<br>都需要有具体的函数实现<br>虚析构和纯虚析构区别：</p>\n<p>如果是纯虚析构，该类属于抽象类，无法实例化对象<br>虚析构语法：</p>\n<p>virtual ~类名(){}</p>\n<p>纯虚析构语法：</p>\n<p>virtual ~类名() = 0;</p>\n<p>类名::~类名(){}</p>\n<p>示例：</p>\n<p>C++<br>class Animal {<br>public:</p>\n<pre><code>Animal()\n{\n    cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;\n}\nvirtual void Speak() = 0;\n\n//析构函数加上virtual关键字，变成虚析构函数\n//virtual ~Animal()\n//{\n//    cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;\n//}\n\n\nvirtual ~Animal() = 0;</code></pre><p>};</p>\n<p>Animal::~Animal()<br>{<br>cout &lt;&lt; “Animal 纯虚析构函数调用！” &lt;&lt; endl;<br>}</p>\n<p>//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</p>\n<p>class Cat : public Animal {<br>public:<br>Cat(string name)<br>{<br>cout &lt;&lt; “Cat 构造函数调用！” &lt;&lt; endl;<br>m_Name = new string(name);<br>}<br>virtual void Speak()<br>{<br>cout &lt;&lt; *m_Name &lt;&lt; “小猫在说话!” &lt;&lt; endl;<br>}<br>~Cat()<br>{<br>cout &lt;&lt; “Cat 析构函数调用!” &lt;&lt; endl;<br>if (this-&gt;m_Name != NULL) {<br>delete m_Name;<br>m_Name = NULL;<br>}<br>}</p>\n<p>public:<br>string *m_Name;<br>};</p>\n<p>void test01()<br>{<br>Animal *animal = new Cat(“Tom”);<br>animal-&gt;Speak();</p>\n<pre><code>//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\n//怎么解决？给基类增加一个虚析构函数\n//虚析构函数就是用来解决通过父类指针释放子类对象\ndelete animal;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>\n<p>​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>\n<p>​ 3. 拥有纯虚析构函数的类也属于抽象类</p>\n<p>4.7.6 多态案例三-电脑组装<br>案例描述：</p>\n<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>\n<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如 Intel 厂商和 Lenovo 厂商</p>\n<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>\n<p>测试时组装三台不同的电脑进行工作</p>\n<p>示例：</p>\n<p>C++<br>#include<iostream><br>using namespace std;</p>\n<p>//抽象 CPU 类<br>class CPU<br>{<br>public:<br>//抽象的计算函数<br>virtual void calculate() = 0;<br>};</p>\n<p>//抽象显卡类<br>class VideoCard<br>{<br>public:<br>//抽象的显示函数<br>virtual void display() = 0;<br>};</p>\n<p>//抽象内存条类<br>class Memory<br>{<br>public:<br>//抽象的存储函数<br>virtual void storage() = 0;<br>};</p>\n<p>//电脑类<br>class Computer<br>{<br>public:<br>Computer(CPU _ cpu, VideoCard _ vc, Memory * mem)<br>{<br>m_cpu = cpu;<br>m_vc = vc;<br>m_mem = mem;<br>}</p>\n<pre><code>//提供工作的函数\nvoid work()\n{\n    //让零件工作起来，调用接口\n    m_cpu-&gt;calculate();\n\n    m_vc-&gt;display();\n\n    m_mem-&gt;storage();\n}\n\n//提供析构函数 释放3个电脑零件\n~Computer()\n{\n\n    //释放CPU零件\n    if (m_cpu != NULL)\n    {\n        delete m_cpu;\n        m_cpu = NULL;\n    }\n\n    //释放显卡零件\n    if (m_vc != NULL)\n    {\n        delete m_vc;\n        m_vc = NULL;\n    }\n\n    //释放内存条零件\n    if (m_mem != NULL)\n    {\n        delete m_mem;\n        m_mem = NULL;\n    }\n}</code></pre><p>private:</p>\n<pre><code>CPU * m_cpu; //CPU的零件指针\nVideoCard * m_vc; //显卡零件指针\nMemory * m_mem; //内存条零件指针</code></pre><p>};</p>\n<p>//具体厂商<br>//Intel 厂商<br>class IntelCPU :public CPU<br>{<br>public:<br>virtual void calculate()<br>{<br>cout &lt;&lt; “Intel 的 CPU 开始计算了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class IntelVideoCard :public VideoCard<br>{<br>public:<br>virtual void display()<br>{<br>cout &lt;&lt; “Intel 的显卡开始显示了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class IntelMemory :public Memory<br>{<br>public:<br>virtual void storage()<br>{<br>cout &lt;&lt; “Intel 的内存条开始存储了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>//Lenovo 厂商<br>class LenovoCPU :public CPU<br>{<br>public:<br>virtual void calculate()<br>{<br>cout &lt;&lt; “Lenovo 的 CPU 开始计算了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class LenovoVideoCard :public VideoCard<br>{<br>public:<br>virtual void display()<br>{<br>cout &lt;&lt; “Lenovo 的显卡开始显示了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>class LenovoMemory :public Memory<br>{<br>public:<br>virtual void storage()<br>{<br>cout &lt;&lt; “Lenovo 的内存条开始存储了！” &lt;&lt; endl;<br>}<br>};</p>\n<p>void test01()<br>{<br>//第一台电脑零件<br>CPU _ intelCpu = new IntelCPU;<br>VideoCard _ intelCard = new IntelVideoCard;<br>Memory * intelMem = new IntelMemory;</p>\n<pre><code>cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;\n//创建第一台电脑\nComputer * computer1 = new Computer(intelCpu, intelCard, intelMem);\ncomputer1-&gt;work();\ndelete computer1;\n\ncout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;\n//第二台电脑组装\nComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\ncomputer2-&gt;work();\ndelete computer2;\n\ncout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;\n//第三台电脑组装\nComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\ncomputer3-&gt;work();\ndelete computer3;</code></pre><p>}<br>5 文件操作<br>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>\n<p>通过文件可以将数据持久化</p>\n<p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p>\n<p>文件类型分为两种：</p>\n<p>文本文件 - 文件以文本的 ASCII 码形式存储在计算机中<br>二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们<br>操作文件的三大类:</p>\n<p>ofstream：写操作<br>ifstream： 读操作<br>fstream ： 读写操作<br>5.1 文本文件<br>5.1.1 写文件<br>写文件步骤如下：</p>\n<p>包含头文件</p>\n<p>#include <fstream></p>\n<p>创建流对象</p>\n<p>ofstream ofs;</p>\n<p>打开文件</p>\n<p>ofs.open(“文件路径”,打开方式);</p>\n<p>写数据</p>\n<p>ofs &lt;&lt; “写入的数据”;</p>\n<p>关闭文件</p>\n<p>ofs.close();</p>\n<p>文件打开方式：</p>\n<p>打开方式 解释<br>ios::in 为读文件而打开文件<br>ios::out 为写文件而打开文件<br>ios::ate 初始位置：文件尾<br>ios::app 追加方式写文件<br>ios::trunc 如果文件存在先删除，再创建<br>ios::binary 二进制方式<br>注意： 文件打开方式可以配合使用，利用|操作符</p>\n<p>例如：用二进制方式写文件 ios::binary | ios:: out</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream></p>\n<p>void test01()<br>{<br>ofstream ofs;<br>ofs.open(“test.txt”, ios::out);</p>\n<pre><code>ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;\nofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;\nofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;\n\nofs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>文件操作必须包含头文件 fstream<br>读文件可以利用 ofstream ，或者 fstream 类<br>打开文件时候需要指定操作文件的路径，以及打开方式<br>利用&lt;&lt;可以向文件中写数据<br>操作完毕，要关闭文件<br>5.1.2 读文件<br>读文件与写文件步骤相似，但是读取方式相对于比较多</p>\n<p>读文件步骤如下：</p>\n<p>包含头文件</p>\n<p>#include <fstream></p>\n<p>创建流对象</p>\n<p>ifstream ifs;</p>\n<p>打开文件并判断文件是否打开成功</p>\n<p>ifs.open(“文件路径”,打开方式);</p>\n<p>读数据</p>\n<p>四种方式读取</p>\n<p>关闭文件</p>\n<p>ifs.close();</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string><br>void test01()<br>{<br>ifstream ifs;<br>ifs.open(“test.txt”, ios::in);</p>\n<pre><code>if (!ifs.is_open())\n{\n    cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;\n    return;\n}\n\n//第一种方式\n//char buf[1024] = { 0 };\n//while (ifs &gt;&gt; buf)\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\n//第二种\n//char buf[1024] = { 0 };\n//while (ifs.getline(buf,sizeof(buf)))\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\n//第三种\n//string buf;\n//while (getline(ifs, buf))\n//{\n//    cout &lt;&lt; buf &lt;&lt; endl;\n//}\n\nchar c;\nwhile ((c = ifs.get()) != EOF)\n{\n    cout &lt;&lt; c;\n}\n\nifs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>读文件可以利用 ifstream ，或者 fstream 类<br>利用 is_open 函数可以判断文件是否打开成功<br>close 关闭文件<br>5.2 二进制文件<br>以二进制的方式对文件进行读写操作</p>\n<p>打开方式要指定为 ==ios::binary==</p>\n<p>5.2.1 写文件<br>二进制方式写文件主要利用流对象调用成员函数 write</p>\n<p>函数原型 ：ostream&amp; write(const char * buffer,int len);</p>\n<p>参数解释：字符指针 buffer 指向内存中一段存储空间。len 是读写的字节数</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string></p>\n<p>class Person<br>{<br>public:<br>char m_Name[64];<br>int m_Age;<br>};</p>\n<p>//二进制文件 写文件<br>void test01()<br>{<br>//1、包含头文件</p>\n<pre><code>//2、创建输出流对象\nofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary);\n\n//3、打开文件\n//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);\n\nPerson p = {&quot;张三&quot;  , 18};\n\n//4、写文件\nofs.write((const char *)&amp;p, sizeof(p));\n\n//5、关闭文件\nofs.close();</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>文件输出流对象 可以通过 write 函数，以二进制方式写数据<br>5.2.2 读文件<br>二进制方式读文件主要利用流对象调用成员函数 read</p>\n<p>函数原型：istream&amp; read(char *buffer,int len);</p>\n<p>参数解释：字符指针 buffer 指向内存中一段存储空间。len 是读写的字节数</p>\n<p>示例：</p>\n<p>C++<br>#include <fstream><br>#include <string></p>\n<p>class Person<br>{<br>public:<br>char m_Name[64];<br>int m_Age;<br>};</p>\n<p>void test01()<br>{<br>ifstream ifs(“person.txt”, ios::in | ios::binary);<br>if (!ifs.is_open())<br>{<br>cout &lt;&lt; “文件打开失败” &lt;&lt; endl;<br>}</p>\n<pre><code>Person p;\nifs.read((char *)&amp;p, sizeof(p));\n\ncout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>文件输入流对象 可以通过 read 函数，以二进制方式读数据</p>\n"},{"title":"A first look at C++ (5)","url":"/2023/01/18/A%20first%20look%20at%20C++%20(5)/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"C-提高编程\"><a href=\"#C-提高编程\" class=\"headerlink\" title=\"C++提高编程\"></a>C++提高编程</h1><p>本阶段主要针对 C++==泛型编程==和==STL==技术做详细讲解，探讨 C++更深层的使用<br>1 模板<br>1.1 模板的概念<br>模板就是建立通用的模具，大大提高复用性</p>\n<p>例如生活中的模板</p>\n<p>一寸照片模板：</p>\n<p>1547105026929<br>1547105026929</p>\n<p>PPT 模板：</p>\n<p>1547103297864<br>1547103297864</p>\n<p>1547103359158<br>1547103359158</p>\n<p>模板的特点：</p>\n<p>模板不可以直接使用，它只是一个框架<br>模板的通用并不是万能的<br>1.2 函数模板<br>C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板<br>C++提供两种模板机制:函数模板和类模板<br>1.2.1 函数模板语法<br>函数模板作用：</p>\n<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。</p>\n<p>语法：</p>\n<p>C++<br>template<typename T><br>函数声明或定义<br>解释：</p>\n<p>template — 声明创建模板</p>\n<p>typename — 表面其后面的符号是一种数据类型，可以用 class 代替</p>\n<p>T — 通用的数据类型，名称可以替换，通常为大写字母</p>\n<p>示例：</p>\n<p>C++</p>\n<p>//交换整型函数<br>void swapInt(int&amp; a, int&amp; b) {<br>int temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>//交换浮点型函数<br>void swapDouble(double&amp; a, double&amp; b) {<br>double temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>//利用模板提供通用的交换函数<br>template<typename T><br>void mySwap(T&amp; a, T&amp; b)<br>{<br>T temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>void test01()<br>{<br>int a = 10;<br>int b = 20;<br>//swapInt(a, b);</p>\n<pre><code>//利用模板实现交换\n//1、自动类型推导\nmySwap(a, b);\n\n//2、显示指定类型\nmySwap&lt;int&gt;(a, b);\n\ncout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\ncout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>函数模板利用关键字 template<br>使用函数模板有两种方式：自动类型推导、显示指定类型<br>模板的目的是为了提高复用性，将类型参数化<br>1.2.2 函数模板注意事项<br>注意事项：</p>\n<p>自动类型推导，必须推导出一致的数据类型 T,才可以使用<br>模板必须要确定出 T 的数据类型，才可以使用<br>示例：</p>\n<p>C++<br>//利用模板提供通用的交换函数<br>template<class T><br>void mySwap(T&amp; a, T&amp; b)<br>{<br>T temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>// 1、自动类型推导，必须推导出一致的数据类型 T,才可以使用<br>void test01()<br>{<br>int a = 10;<br>int b = 20;<br>char c = ‘c’;</p>\n<pre><code>mySwap(a, b); // 正确，可以推导出一致的T\n//mySwap(a, c); // 错误，推导不出一致的T类型</code></pre><p>}</p>\n<p>// 2、模板必须要确定出 T 的数据类型，才可以使用<br>template<class T><br>void func()<br>{<br>cout &lt;&lt; “func 调用” &lt;&lt; endl;<br>}</p>\n<p>void test02()<br>{<br>//func(); //错误，模板不能独立使用，必须确定出 T 的类型<br>func<int>(); //利用显示指定类型的方式，给 T 一个类型，才可以使用该模板<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>使用模板时必须确定出通用数据类型 T，并且能够推导出一致的类型<br>1.2.3 函数模板案例<br>案例描述：</p>\n<p>利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序<br>排序规则从大到小，排序算法为选择排序<br>分别利用 char 数组和 int 数组进行测试<br>示例：</p>\n<p>C++<br>//交换的函数模板<br>template<typename T><br>void mySwap(T &amp;a, T&amp;b)<br>{<br>T temp = a;<br>a = b;<br>b = temp;<br>}</p>\n<p>template<class T> // 也可以替换成 typename<br>//利用选择排序，进行对数组从大到小的排序<br>void mySort(T arr[], int len)<br>{<br>for (int i = 0; i &lt; len; i++)<br>{<br>int max = i; //最大数的下标<br>for (int j = i + 1; j &lt; len; j++)<br>{<br>if (arr[max] &lt; arr[j])<br>{<br>max = j;<br>}<br>}<br>if (max != i) //如果最大数的下标不是 i，交换两者<br>{<br>mySwap(arr[max], arr[i]);<br>}<br>}<br>}<br>template<typename T><br>void printArray(T arr[], int len) {</p>\n<pre><code>for (int i = 0; i &lt; len; i++) {\n    cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}<br>void test01()<br>{<br>//测试 char 数组<br>char charArr[] = “bdcfeagh”;<br>int num = sizeof(charArr) / sizeof(char);<br>mySort(charArr, num);<br>printArray(charArr, num);<br>}</p>\n<p>void test02()<br>{<br>//测试 int 数组<br>int intArr[] = { 7, 5, 8, 1, 3, 9, 2, 4, 6 };<br>int num = sizeof(intArr) / sizeof(int);<br>mySort(intArr, num);<br>printArray(intArr, num);<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：模板可以提高代码复用，需要熟练掌握</p>\n<p>1.2.4 普通函数与函数模板的区别<br>普通函数与函数模板区别：</p>\n<p>普通函数调用时可以发生自动类型转换（隐式类型转换）<br>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换<br>如果利用显示指定类型的方式，可以发生隐式类型转换<br>示例：</p>\n<p>C++<br>//普通函数<br>int myAdd01(int a, int b)<br>{<br>return a + b;<br>}</p>\n<p>//函数模板<br>template<class T><br>T myAdd02(T a, T b)<br>{<br>return a + b;<br>}</p>\n<p>//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换<br>void test01()<br>{<br>int a = 10;<br>int b = 20;<br>char c = ‘c’;<br>cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //正确，将 char 类型的’c’隐式转换为 int 类型 ‘c’ 对应 ASCII 码 99</p>\n<pre><code>//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换\n\nmyAdd02&lt;int&gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型 T</p>\n<p>1.2.5 普通函数与函数模板的调用规则<br>调用规则如下：</p>\n<p>如果函数模板和普通函数都可以实现，优先调用普通函数<br>可以通过空模板参数列表来强制调用函数模板<br>函数模板也可以发生重载<br>如果函数模板可以产生更好的匹配,优先调用函数模板<br>示例：</p>\n<p>C++<br>//普通函数与函数模板调用规则<br>void myPrint(int a, int b)<br>{<br>cout &lt;&lt; “调用的普通函数” &lt;&lt; endl;<br>}</p>\n<p>template<typename T><br>void myPrint(T a, T b)<br>{<br>cout &lt;&lt; “调用的模板” &lt;&lt; endl;<br>}</p>\n<p>template<typename T><br>void myPrint(T a, T b, T c)<br>{<br>cout &lt;&lt; “调用重载的模板” &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>//1、如果函数模板和普通函数都可以实现，优先调用普通函数<br>// 注意 如果告诉编译器 普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到<br>int a = 10;<br>int b = 20;<br>myPrint(a, b); //调用普通函数</p>\n<pre><code>//2、可以通过空模板参数列表来强制调用函数模板\nmyPrint&lt;&gt;(a, b); //调用函数模板\n\n//3、函数模板也可以发生重载\nint c = 30;\nmyPrint(a, b, c); //调用重载的函数模板\n\n//4、 如果函数模板可以产生更好的匹配,优先调用函数模板\nchar c1 = &apos;a&apos;;\nchar c2 = &apos;b&apos;;\nmyPrint(c1, c2); //调用函数模板</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>\n<p>1.2.6 模板的局限性<br>局限性：</p>\n<p>模板的通用性并不是万能的<br>例如：</p>\n<p>C++<br>template<class T><br>void f(T a, T b)<br>{<br>a = b;<br>}<br>在上述代码中提供的赋值操作，如果传入的 a 和 b 是一个数组，就无法实现了</p>\n<p>再例如：</p>\n<p>C++<br>template<class T><br>void f(T a, T b)<br>{<br>if(a &gt; b) { … }<br>}<br>在上述代码中，如果 T 的数据类型传入的是像 Person 这样的自定义数据类型，也无法正常运行</p>\n<p>因此 C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板</p>\n<p>示例：</p>\n<p>C++<br>#include<iostream><br>using namespace std;</p>\n<p>#include <string></p>\n<p>class Person<br>{<br>public:<br>Person(string name, int age)<br>{<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>}<br>string m_Name;<br>int m_Age;<br>};</p>\n<p>//普通函数模板<br>template<class T><br>bool myCompare(T&amp; a, T&amp; b)<br>{<br>if (a == b)<br>{<br>return true;<br>}<br>else<br>{<br>return false;<br>}<br>}</p>\n<p>//具体化，显示具体化的原型和定意思以 template&lt;&gt;开头，并通过名称来指出类型<br>//具体化优先于常规模板<br>template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2)<br>{<br>if ( p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)<br>{<br>return true;<br>}<br>else<br>{<br>return false;<br>}<br>}</p>\n<p>void test01()<br>{<br>int a = 10;<br>int b = 20;<br>//内置数据类型可以直接使用通用的函数模板<br>bool ret = myCompare(a, b);<br>if (ret)<br>{<br>cout &lt;&lt; “a == b “ &lt;&lt; endl;<br>}<br>else<br>{<br>cout &lt;&lt; “a != b “ &lt;&lt; endl;<br>}<br>}</p>\n<p>void test02()<br>{<br>Person p1(“Tom”, 10);<br>Person p2(“Tom”, 10);<br>//自定义数据类型，不会调用普通的函数模板<br>//可以创建具体化的 Person 数据类型的模板，用于特殊处理这个类型<br>bool ret = myCompare(p1, p2);<br>if (ret)<br>{<br>cout &lt;&lt; “p1 == p2 “ &lt;&lt; endl;<br>}<br>else<br>{<br>cout &lt;&lt; “p1 != p2 “ &lt;&lt; endl;<br>}<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>利用具体化的模板，可以解决自定义类型的通用化<br>学习模板并不是为了写模板，而是在 STL 能够运用系统提供的模板<br>1.3 类模板<br>1.3.1 类模板语法<br>类模板作用：</p>\n<p>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。<br>语法：</p>\n<p>C++<br>template<typename T><br>类<br>解释：</p>\n<p>template — 声明创建模板</p>\n<p>typename — 表面其后面的符号是一种数据类型，可以用 class 代替</p>\n<p>T — 通用的数据类型，名称可以替换，通常为大写字母</p>\n<p>示例：</p>\n<p>C++<br>#include <string><br>//类模板<br>template&lt;class NameType, class AgeType&gt;<br>class Person<br>{<br>public:<br>Person(NameType name, AgeType age)<br>{<br>this-&gt;mName = name;<br>this-&gt;mAge = age;<br>}<br>void showPerson()<br>{<br>cout &lt;&lt; “name: “ &lt;&lt; this-&gt;mName &lt;&lt; “ age: “ &lt;&lt; this-&gt;mAge &lt;&lt; endl;<br>}<br>public:<br>NameType mName;<br>AgeType mAge;<br>};</p>\n<p>void test01()<br>{<br>// 指定 NameType 为 string 类型，AgeType 为 int 类型<br>Person&lt;string, int&gt;P1(“孙悟空”, 999);<br>P1.showPerson();<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：类模板和函数模板语法相似，在声明模板 template 后面加类，此类称为类模板</p>\n<p>1.3.2 类模板与函数模板区别<br>类模板与函数模板区别主要有两点：</p>\n<p>类模板没有自动类型推导的使用方式<br>类模板在模板参数列表中可以有默认参数<br>示例：</p>\n<p>C++<br>#include <string><br>//类模板<br>template&lt;class NameType, class AgeType = int&gt;<br>class Person<br>{<br>public:<br>Person(NameType name, AgeType age)<br>{<br>this-&gt;mName = name;<br>this-&gt;mAge = age;<br>}<br>void showPerson()<br>{<br>cout &lt;&lt; “name: “ &lt;&lt; this-&gt;mName &lt;&lt; “ age: “ &lt;&lt; this-&gt;mAge &lt;&lt; endl;<br>}<br>public:<br>NameType mName;<br>AgeType mAge;<br>};</p>\n<p>//1、类模板没有自动类型推导的使用方式<br>void test01()<br>{<br>// Person p(“孙悟空”, 1000); // 错误 类模板使用时候，不可以用自动类型推导<br>Person &lt;string ,int&gt;p(“孙悟空”, 1000); //必须使用显示指定类型的方式，使用类模板<br>p.showPerson();<br>}</p>\n<p>//2、类模板在模板参数列表中可以有默认参数<br>void test02()<br>{<br>Person <string> p(“猪八戒”, 999); //类模板中的模板参数列表 可以指定默认参数<br>p.showPerson();<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>类模板使用只能用显示指定类型方式<br>类模板中的模板参数列表可以有默认参数<br>1.3.3 类模板中成员函数创建时机<br>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>\n<p>普通类中的成员函数一开始就可以创建<br>类模板中的成员函数在调用时才创建<br>示例：</p>\n<p>C++<br>class Person1<br>{<br>public:<br>void showPerson1()<br>{<br>cout &lt;&lt; “Person1 show” &lt;&lt; endl;<br>}<br>};</p>\n<p>class Person2<br>{<br>public:<br>void showPerson2()<br>{<br>cout &lt;&lt; “Person2 show” &lt;&lt; endl;<br>}<br>};</p>\n<p>template<class T><br>class MyClass<br>{<br>public:<br>T obj;</p>\n<pre><code>//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成\n\nvoid fun1() { obj.showPerson1(); }\nvoid fun2() { obj.showPerson2(); }</code></pre><p>};</p>\n<p>void test01()<br>{<br>MyClass<Person1> m;<br>m.fun1();</p>\n<pre><code>//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>\n<p>1.3.4 类模板对象做函数参数<br>学习目标：</p>\n<p>类模板实例化出的对象，向函数传参的方式<br>一共有三种传入方式：</p>\n<p>指定传入的类型 — 直接显示对象的数据类型<br>参数模板化 — 将对象中的参数变为模板进行传递<br>整个类模板化 — 将这个对象类型 模板化进行传递<br>示例：</p>\n<p>C++<br>#include <string><br>//类模板<br>template&lt;class NameType, class AgeType = int&gt;<br>class Person<br>{<br>public:<br>Person(NameType name, AgeType age)<br>{<br>this-&gt;mName = name;<br>this-&gt;mAge = age;<br>}<br>void showPerson()<br>{<br>cout &lt;&lt; “name: “ &lt;&lt; this-&gt;mName &lt;&lt; “ age: “ &lt;&lt; this-&gt;mAge &lt;&lt; endl;<br>}<br>public:<br>NameType mName;<br>AgeType mAge;<br>};</p>\n<p>//1、指定传入的类型<br>void printPerson1(Person&lt;string, int&gt; &amp;p)<br>{<br>p.showPerson();<br>}<br>void test01()<br>{<br>Person &lt;string, int &gt;p(“孙悟空”, 100);<br>printPerson1(p);<br>}</p>\n<p>//2、参数模板化<br>template &lt;class T1, class T2&gt;<br>void printPerson2(Person&lt;T1, T2&gt;&amp;p)<br>{<br>p.showPerson();<br>cout &lt;&lt; “T1 的类型为： “ &lt;&lt; typeid(T1).name() &lt;&lt; endl;<br>cout &lt;&lt; “T2 的类型为： “ &lt;&lt; typeid(T2).name() &lt;&lt; endl;<br>}<br>void test02()<br>{<br>Person &lt;string, int &gt;p(“猪八戒”, 90);<br>printPerson2(p);<br>}</p>\n<p>//3、整个类模板化<br>template<class T><br>void printPerson3(T &amp; p)<br>{<br>cout &lt;&lt; “T 的类型为： “ &lt;&lt; typeid(T).name() &lt;&lt; endl;<br>p.showPerson();</p>\n<p>}<br>void test03()<br>{<br>Person &lt;string, int &gt;p(“唐僧”, 30);<br>printPerson3(p);<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\ntest02();\ntest03();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>通过类模板创建的对象，可以有三种方式向函数中进行传参<br>使用比较广泛是第一种：指定传入的类型<br>1.3.5 类模板与继承<br>当类模板碰到继承时，需要注意一下几点：</p>\n<p>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中 T 的类型<br>如果不指定，编译器无法给子类分配内存<br>如果想灵活指定出父类中 T 的类型，子类也需变为类模板<br>示例：</p>\n<p>C++<br>template<class T><br>class Base<br>{<br>T m;<br>};</p>\n<p>//class Son:public Base //错误，c++编译需要给子类分配内存，必须知道父类中 T 的类型才可以向下继承<br>class Son :public Base<int> //必须指定一个类型<br>{<br>};<br>void test01()<br>{<br>Son c;<br>}</p>\n<p>//类模板继承类模板 ,可以用 T2 指定父类中的 T 类型<br>template&lt;class T1, class T2&gt;<br>class Son2 :public Base<T2><br>{<br>public:<br>Son2()<br>{<br>cout &lt;&lt; typeid(T1).name() &lt;&lt; endl;<br>cout &lt;&lt; typeid(T2).name() &lt;&lt; endl;<br>}<br>};</p>\n<p>void test02()<br>{<br>Son2&lt;int, char&gt; child1;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：如果父类是类模板，子类需要指定出父类中 T 的数据类型</p>\n<p>1.3.6 类模板成员函数类外实现<br>学习目标：能够掌握类模板中的成员函数类外实现</p>\n<p>示例：</p>\n<p>C++<br>#include <string></p>\n<p>//类模板中成员函数类外实现<br>template&lt;class T1, class T2&gt;<br>class Person {<br>public:<br>//成员函数类内声明<br>Person(T1 name, T2 age);<br>void showPerson();</p>\n<p>public:<br>T1 m_Name;<br>T2 m_Age;<br>};</p>\n<p>//构造函数 类外实现<br>template&lt;class T1, class T2&gt;<br>Person&lt;T1, T2&gt;::Person(T1 name, T2 age) {<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>}</p>\n<p>//成员函数 类外实现<br>template&lt;class T1, class T2&gt;<br>void Person&lt;T1, T2&gt;::showPerson() {<br>cout &lt;&lt; “姓名: “ &lt;&lt; this-&gt;m_Name &lt;&lt; “ 年龄:” &lt;&lt; this-&gt;m_Age &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>Person&lt;string, int&gt; p(“Tom”, 20);<br>p.showPerson();<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p>\n<p>1.3.7 类模板分文件编写<br>学习目标：</p>\n<p>掌握类模板成员函数分文件编写产生的问题以及解决方式<br>问题：</p>\n<p>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到<br>解决：</p>\n<p>解决方式 1：直接包含.cpp 源文件<br>解决方式 2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp 是约定的名称，并不是强制<br>示例：</p>\n<p>person.hpp 中代码：</p>\n<p>C++<br>#pragma once<br>#include <iostream><br>using namespace std;<br>#include <string></p>\n<p>template&lt;class T1, class T2&gt;<br>class Person {<br>public:<br>Person(T1 name, T2 age);<br>void showPerson();<br>public:<br>T1 m_Name;<br>T2 m_Age;<br>};</p>\n<p>//构造函数 类外实现<br>template&lt;class T1, class T2&gt;<br>Person&lt;T1, T2&gt;::Person(T1 name, T2 age) {<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>}</p>\n<p>//成员函数 类外实现<br>template&lt;class T1, class T2&gt;<br>void Person&lt;T1, T2&gt;::showPerson() {<br>cout &lt;&lt; “姓名: “ &lt;&lt; this-&gt;m_Name &lt;&lt; “ 年龄:” &lt;&lt; this-&gt;m_Age &lt;&lt; endl;<br>}<br>类模板分文件编写.cpp 中代码</p>\n<p>C++<br>#include<iostream><br>using namespace std;</p>\n<p>//#include “person.h”<br>#include “person.cpp” //解决方式 1，包含 cpp 源文件</p>\n<p>//解决方式 2，将声明和实现写到一起，文件后缀名改为.hpp<br>#include “person.hpp”<br>void test01()<br>{<br>Person&lt;string, int&gt; p(“Tom”, 10);<br>p.showPerson();<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>\n<p>1.3.8 类模板与友元<br>学习目标：</p>\n<p>掌握类模板配合友元函数的类内和类外实现<br>全局函数类内实现 - 直接在类内声明友元即可</p>\n<p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p>\n<p>示例：</p>\n<p>C++<br>#include <string></p>\n<p>//2、全局函数配合友元 类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元<br>template&lt;class T1, class T2&gt; class Person;</p>\n<p>//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到<br>//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p);</p>\n<p>template&lt;class T1, class T2&gt;<br>void printPerson2(Person&lt;T1, T2&gt; &amp; p)<br>{<br>cout &lt;&lt; “类外实现 —- 姓名： “ &lt;&lt; p.m_Name &lt;&lt; “ 年龄：” &lt;&lt; p.m_Age &lt;&lt; endl;<br>}</p>\n<p>template&lt;class T1, class T2&gt;<br>class Person<br>{<br>//1、全局函数配合友元 类内实现<br>friend void printPerson(Person&lt;T1, T2&gt; &amp; p)<br>{<br>cout &lt;&lt; “姓名： “ &lt;&lt; p.m_Name &lt;&lt; “ 年龄：” &lt;&lt; p.m_Age &lt;&lt; endl;<br>}</p>\n<pre><code>//全局函数配合友元  类外实现\nfriend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</code></pre><p>public:</p>\n<pre><code>Person(T1 name, T2 age)\n{\n    this-&gt;m_Name = name;\n    this-&gt;m_Age = age;\n}</code></pre><p>private:<br>T1 m_Name;<br>T2 m_Age;</p>\n<p>};</p>\n<p>//1、全局函数在类内实现<br>void test01()<br>{<br>Person &lt;string, int &gt;p(“Tom”, 20);<br>printPerson(p);<br>}</p>\n<p>//2、全局函数在类外实现<br>void test02()<br>{<br>Person &lt;string, int &gt;p(“Jerry”, 30);<br>printPerson2(p);<br>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>\n<p>1.3.9 类模板案例<br>案例描述: 实现一个通用的数组类，要求如下：</p>\n<p>可以对内置数据类型以及自定义数据类型的数据进行存储<br>将数组中的数据存储到堆区<br>构造函数中可以传入数组的容量<br>提供对应的拷贝构造函数以及 operator=防止浅拷贝问题<br>提供尾插法和尾删法对数组中的数据进行增加和删除<br>可以通过下标的方式访问数组中的元素<br>可以获取数组中当前元素个数和数组的容量<br>示例：</p>\n<p>myArray.hpp 中代码</p>\n<p>C++<br>#pragma once<br>#include <iostream><br>using namespace std;</p>\n<p>template<class T><br>class MyArray<br>{<br>public:</p>\n<pre><code>//构造函数\nMyArray(int capacity)\n{\n    this-&gt;m_Capacity = capacity;\n    this-&gt;m_Size = 0;\n    pAddress = new T[this-&gt;m_Capacity];\n}\n\n//拷贝构造\nMyArray(const MyArray &amp; arr)\n{\n    this-&gt;m_Capacity = arr.m_Capacity;\n    this-&gt;m_Size = arr.m_Size;\n    this-&gt;pAddress = new T[this-&gt;m_Capacity];\n    for (int i = 0; i &lt; this-&gt;m_Size; i++)\n    {\n        //如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，\n        // 普通类型可以直接= 但是指针类型需要深拷贝\n        this-&gt;pAddress[i] = arr.pAddress[i];\n    }\n}\n\n//重载= 操作符  防止浅拷贝问题\nMyArray&amp; operator=(const MyArray&amp; myarray) {\n\n    if (this-&gt;pAddress != NULL) {\n        delete[] this-&gt;pAddress;\n        this-&gt;m_Capacity = 0;\n        this-&gt;m_Size = 0;\n    }\n\n    this-&gt;m_Capacity = myarray.m_Capacity;\n    this-&gt;m_Size = myarray.m_Size;\n    this-&gt;pAddress = new T[this-&gt;m_Capacity];\n    for (int i = 0; i &lt; this-&gt;m_Size; i++) {\n        this-&gt;pAddress[i] = myarray[i];\n    }\n    return *this;\n}\n\n//重载[] 操作符  arr[0]\nT&amp; operator [](int index)\n{\n    return this-&gt;pAddress[index]; //不考虑越界，用户自己去处理\n}\n\n//尾插法\nvoid Push_back(const T &amp; val)\n{\n    if (this-&gt;m_Capacity == this-&gt;m_Size)\n    {\n        return;\n    }\n    this-&gt;pAddress[this-&gt;m_Size] = val;\n    this-&gt;m_Size++;\n}\n\n//尾删法\nvoid Pop_back()\n{\n    if (this-&gt;m_Size == 0)\n    {\n        return;\n    }\n    this-&gt;m_Size--;\n}\n\n//获取数组容量\nint getCapacity()\n{\n    return this-&gt;m_Capacity;\n}\n\n//获取数组大小\nint    getSize()\n{\n    return this-&gt;m_Size;\n}\n\n\n//析构\n~MyArray()\n{\n    if (this-&gt;pAddress != NULL)\n    {\n        delete[] this-&gt;pAddress;\n        this-&gt;pAddress = NULL;\n        this-&gt;m_Capacity = 0;\n        this-&gt;m_Size = 0;\n    }\n}</code></pre><p>private:<br>T * pAddress; //指向一个堆空间，这个空间存储真正的数据<br>int m_Capacity; //容量<br>int m_Size; // 大小<br>};<br>类模板案例—数组类封装.cpp 中</p>\n<p>C++<br>#include “myArray.hpp”<br>#include <string></p>\n<p>void printIntArray(MyArray<int>&amp; arr) {<br>for (int i = 0; i &lt; arr.getSize(); i++) {<br>cout &lt;&lt; arr[i] &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>}</p>\n<p>//测试内置数据类型<br>void test01()<br>{<br>MyArray<int> array1(10);<br>for (int i = 0; i &lt; 10; i++)<br>{<br>array1.Push_back(i);<br>}<br>cout &lt;&lt; “array1 打印输出：” &lt;&lt; endl;<br>printIntArray(array1);<br>cout &lt;&lt; “array1 的大小：” &lt;&lt; array1.getSize() &lt;&lt; endl;<br>cout &lt;&lt; “array1 的容量：” &lt;&lt; array1.getCapacity() &lt;&lt; endl;</p>\n<pre><code>cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl;\n\nMyArray&lt;int&gt; array2(array1);\narray2.Pop_back();\ncout &lt;&lt; &quot;array2打印输出：&quot; &lt;&lt; endl;\nprintIntArray(array2);\ncout &lt;&lt; &quot;array2的大小：&quot; &lt;&lt; array2.getSize() &lt;&lt; endl;\ncout &lt;&lt; &quot;array2的容量：&quot; &lt;&lt; array2.getCapacity() &lt;&lt; endl;</code></pre><p>}</p>\n<p>//测试自定义数据类型<br>class Person {<br>public:<br>Person() {}<br>Person(string name, int age) {<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>}<br>public:<br>string m_Name;<br>int m_Age;<br>};</p>\n<p>void printPersonArray(MyArray<Person>&amp; personArr)<br>{<br>for (int i = 0; i &lt; personArr.getSize(); i++) {<br>cout &lt;&lt; “姓名：” &lt;&lt; personArr[i].m_Name &lt;&lt; “ 年龄： “ &lt;&lt; personArr[i].m_Age &lt;&lt; endl;<br>}</p>\n<p>}</p>\n<p>void test02()<br>{<br>//创建数组<br>MyArray<Person> pArray(10);<br>Person p1(“孙悟空”, 30);<br>Person p2(“韩信”, 20);<br>Person p3(“妲己”, 18);<br>Person p4(“王昭君”, 15);<br>Person p5(“赵云”, 24);</p>\n<pre><code>//插入数据\npArray.Push_back(p1);\npArray.Push_back(p2);\npArray.Push_back(p3);\npArray.Push_back(p4);\npArray.Push_back(p5);\n\nprintPersonArray(pArray);\n\ncout &lt;&lt; &quot;pArray的大小：&quot; &lt;&lt; pArray.getSize() &lt;&lt; endl;\ncout &lt;&lt; &quot;pArray的容量：&quot; &lt;&lt; pArray.getCapacity() &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>能够利用所学知识点实现通用的数组</p>\n<p>2 STL 初识<br>2.1 STL 的诞生<br>长久以来，软件界一直希望建立一种可重复利用的东西</p>\n<p>C++的面向对象和泛型编程思想，目的就是复用性的提升</p>\n<p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p>\n<p>为了建立数据结构和算法的一套标准,诞生了 STL</p>\n<p>2.2 STL 基本概念<br>STL(Standard Template Library,标准模板库)<br>STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)<br>容器和算法之间通过迭代器进行无缝连接。<br>STL 几乎所有的代码都采用了模板类或者模板函数<br>2.3 STL 六大组件<br>STL 大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</p>\n<p>容器：各种数据结构，如 vector、list、deque、set、map 等,用来存放数据。<br>算法：各种常用的算法，如 sort、find、copy、for_each 等<br>迭代器：扮演了容器与算法之间的胶合剂。<br>仿函数：行为类似函数，可作为算法的某种策略。<br>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。<br>空间配置器：负责空间的配置与管理。<br>2.4 STL 中容器、算法、迭代器<br>容器：置物之所也</p>\n<p>STL 容器就是将运用最广泛的一些数据结构实现出来</p>\n<p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p>\n<p>这些容器分为序列式容器和关联式容器两种:</p>\n<p>​ 序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​ 关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系</p>\n<p>算法：问题之解法也</p>\n<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p>\n<p>算法分为:质变算法和非质变算法。</p>\n<p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p>\n<p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p>\n<p>迭代器：容器和算法之间粘合剂</p>\n<p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>\n<p>每个容器都有自己专属的迭代器</p>\n<p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p>\n<p>迭代器种类：</p>\n<p>种类 功能 支持运算<br>输入迭代器 对数据的只读访问 只读，支持++、==、！=<br>输出迭代器 对数据的只写访问 只写，支持++<br>前向迭代器 读写操作，并能向前推进迭代器 读写，支持++、==、！=<br>双向迭代器 读写操作，并能向前和向后操作 读写，支持++、–，<br>随机访问迭代器 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=<br>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p>\n<p>2.5 容器算法迭代器初识<br>了解 STL 中容器、算法、迭代器概念之后，我们利用代码感受 STL 的魅力</p>\n<p>STL 中最常用的容器为 Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p>\n<p>2.5.1 vector 存放内置数据类型<br>容器： vector</p>\n<p>算法： for_each</p>\n<p>迭代器： vector<int>::iterator</p>\n<p>示例：</p>\n<p>C++<br>#include <vector><br>#include <algorithm></p>\n<p>void MyPrint(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; endl;<br>}</p>\n<p>void test01() {</p>\n<pre><code>//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型\nvector&lt;int&gt; v;\n//向容器中放数据\nv.push_back(10);\nv.push_back(20);\nv.push_back(30);\nv.push_back(40);\n\n//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素\n//v.begin()返回迭代器，这个迭代器指向容器中第一个数据\n//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置\n//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型\n\nvector&lt;int&gt;::iterator pBegin = v.begin();\nvector&lt;int&gt;::iterator pEnd = v.end();\n\n//第一种遍历方式：\nwhile (pBegin != pEnd) {\n    cout &lt;&lt; *pBegin &lt;&lt; endl;\n    pBegin++;\n}\n\n\n//第二种遍历方式：\nfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; endl;\n}\ncout &lt;&lt; endl;\n\n//第三种遍历方式：\n//使用STL提供标准遍历算法  头文件 algorithm\nfor_each(v.begin(), v.end(), MyPrint);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2.5.2 Vector 存放自定义数据类型<br>学习目标：vector 中存放自定义数据类型，并打印输出</p>\n<p>示例：</p>\n<p>C++<br>#include <vector><br>#include <string></p>\n<p>//自定义数据类型<br>class Person {<br>public:<br>Person(string name, int age) {<br>mName = name;<br>mAge = age;<br>}<br>public:<br>string mName;<br>int mAge;<br>};<br>//存放对象<br>void test01() {</p>\n<pre><code>vector&lt;Person&gt; v;\n\n//创建数据\nPerson p1(&quot;aaa&quot;, 10);\nPerson p2(&quot;bbb&quot;, 20);\nPerson p3(&quot;ccc&quot;, 30);\nPerson p4(&quot;ddd&quot;, 40);\nPerson p5(&quot;eee&quot;, 50);\n\nv.push_back(p1);\nv.push_back(p2);\nv.push_back(p3);\nv.push_back(p4);\nv.push_back(p5);\n\nfor (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) {\n    cout &lt;&lt; &quot;Name:&quot; &lt;&lt; (*it).mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it).mAge &lt;&lt; endl;\n\n}</code></pre><p>}</p>\n<p>//放对象指针<br>void test02() {</p>\n<pre><code>vector&lt;Person*&gt; v;\n\n//创建数据\nPerson p1(&quot;aaa&quot;, 10);\nPerson p2(&quot;bbb&quot;, 20);\nPerson p3(&quot;ccc&quot;, 30);\nPerson p4(&quot;ddd&quot;, 40);\nPerson p5(&quot;eee&quot;, 50);\n\nv.push_back(&amp;p1);\nv.push_back(&amp;p2);\nv.push_back(&amp;p3);\nv.push_back(&amp;p4);\nv.push_back(&amp;p5);\n\nfor (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) {\n    Person * p = (*it);\n    cout &lt;&lt; &quot;Name:&quot; &lt;&lt; p-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>2.5.3 Vector 容器嵌套容器<br>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p>\n<p>示例：</p>\n<p>C++<br>#include <vector></p>\n<p>//容器嵌套容器<br>void test01() {</p>\n<pre><code>vector&lt; vector&lt;int&gt; &gt;  v;\n\nvector&lt;int&gt; v1;\nvector&lt;int&gt; v2;\nvector&lt;int&gt; v3;\nvector&lt;int&gt; v4;\n\nfor (int i = 0; i &lt; 4; i++) {\n    v1.push_back(i + 1);\n    v2.push_back(i + 2);\n    v3.push_back(i + 3);\n    v4.push_back(i + 4);\n}\n\n//将容器元素插入到vector v中\nv.push_back(v1);\nv.push_back(v2);\nv.push_back(v3);\nv.push_back(v4);\n\n\nfor (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) {\n\n    for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) {\n        cout &lt;&lt; *vit &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>3 STL- 常用容器<br>3.1 string 容器<br>3.1.1 string 基本概念<br>本质：</p>\n<p>string 是 C++风格的字符串，而 string 本质上是一个类<br>string 和 char * 区别：</p>\n<p>char _ 是一个指针<br>string 是一个类，类内部封装了 char_，管理这个字符串，是一个 char*型的容器。<br>特点：</p>\n<p>string 类内部封装了很多成员方法</p>\n<p>例如：查找 find，拷贝 copy，删除 delete 替换 replace，插入 insert</p>\n<p>string 管理 char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>\n<p>3.1.2 string 构造函数<br>构造函数原型：</p>\n<p>string(); //创建一个空的字符串 例如: string str;<br>string(const char* s); //使用字符串 s 初始化<br>string(const string&amp; str); //使用一个 string 对象初始化另一个 string 对象<br>string(int n, char c); //使用 n 个字符 c 初始化<br>示例：</p>\n<p>C++<br>#include <string><br>//string 构造<br>void test01()<br>{<br>string s1; //创建空字符串，调用无参构造函数<br>cout &lt;&lt; “str1 = “ &lt;&lt; s1 &lt;&lt; endl;</p>\n<pre><code>const char* str = &quot;hello world&quot;;\nstring s2(str); //把c_string转换成了string\n\ncout &lt;&lt; &quot;str2 = &quot; &lt;&lt; s2 &lt;&lt; endl;\n\nstring s3(s2); //调用拷贝构造函数\ncout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;\n\nstring s4(10, &apos;a&apos;);\ncout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：string 的多种构造方式没有可比性，灵活使用即可</p>\n<p>3.1.3 string 赋值操作<br>功能描述：</p>\n<p>给 string 字符串进行赋值<br>赋值的函数原型：</p>\n<p>string&amp; operator=(const char* s); //char*类型字符串 赋值给当前的字符串<br>string&amp; operator=(const string &amp;s); //把字符串 s 赋给当前的字符串<br>string&amp; operator=(char c); //字符赋值给当前的字符串<br>string&amp; assign(const char *s); //把字符串 s 赋给当前的字符串<br>string&amp; assign(const char *s, int n); //把字符串 s 的前 n 个字符赋给当前的字符串<br>string&amp; assign(const string &amp;s); //把字符串 s 赋给当前字符串<br>string&amp; assign(int n, char c); //用 n 个字符 c 赋给当前字符串<br>示例：</p>\n<p>C++<br>//赋值<br>void test01()<br>{<br>string str1;<br>str1 = “hello world”;<br>cout &lt;&lt; “str1 = “ &lt;&lt; str1 &lt;&lt; endl;</p>\n<pre><code>string str2;\nstr2 = str1;\ncout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl;\n\nstring str3;\nstr3 = &apos;a&apos;;\ncout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;\n\nstring str4;\nstr4.assign(&quot;hello c++&quot;);\ncout &lt;&lt; &quot;str4 = &quot; &lt;&lt; str4 &lt;&lt; endl;\n\nstring str5;\nstr5.assign(&quot;hello c++&quot;,5);\ncout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; endl;\n\n\nstring str6;\nstr6.assign(str5);\ncout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl;\n\nstring str7;\nstr7.assign(5, &apos;x&apos;);\ncout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>​ string 的赋值方式很多，operator= 这种方式是比较实用的</p>\n<p>3.1.4 string 字符串拼接<br>功能描述：</p>\n<p>实现在字符串末尾拼接字符串<br>函数原型：</p>\n<p>string&amp; operator+=(const char* str); //重载+=操作符<br>string&amp; operator+=(const char c); //重载+=操作符<br>string&amp; operator+=(const string&amp; str); //重载+=操作符<br>string&amp; append(const char <em>s); //把字符串 s 连接到当前字符串结尾<br>string&amp; append(const char \\</em>s, int n); //把字符串 s 的前 n 个字符连接到当前字符串结尾<br>string&amp; append(const string &amp;s); //同 operator+=(const string&amp; str)<br>string&amp; append(const string &amp;s, int pos, int n);//字符串 s 中从 pos 开始的 n 个字符连接到字符串结尾<br>示例：</p>\n<p>C++<br>//字符串拼接<br>void test01()<br>{<br>string str1 = “我”;</p>\n<pre><code>str1 += &quot;爱玩游戏&quot;;\n\ncout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\n\nstr1 += &apos;:&apos;;\n\ncout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\n\nstring str2 = &quot;LOL DNF&quot;;\n\nstr1 += str2;\n\ncout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\n\nstring str3 = &quot;I&quot;;\nstr3.append(&quot; love &quot;);\nstr3.append(&quot;game abcde&quot;, 4);\n//str3.append(str2);\nstr3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾\ncout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;</code></pre><p>}<br>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p>\n<p>3.1.5 string 查找和替换<br>功能描述：</p>\n<p>查找：查找指定字符串是否存在<br>替换：在指定的位置替换字符串<br>函数原型：</p>\n<p>int find(const string&amp; str, int pos = 0) const; //查找 str 第一次出现位置,从 pos 开始查找<br>int find(const char* s, int pos = 0) const; //查找 s 第一次出现位置,从 pos 开始查找<br>int find(const char* s, int pos, int n) const; //从 pos 位置查找 s 的前 n 个字符第一次位置<br>int find(const char c, int pos = 0) const; //查找字符 c 第一次出现位置<br>int rfind(const string&amp; str, int pos = npos) const; //查找 str 最后一次位置,从 pos 开始查找<br>int rfind(const char* s, int pos = npos) const; //查找 s 最后一次出现位置,从 pos 开始查找<br>int rfind(const char* s, int pos, int n) const; //从 pos 查找 s 的前 n 个字符最后一次位置<br>int rfind(const char c, int pos = 0) const; //查找字符 c 最后一次出现位置<br>string&amp; replace(int pos, int n, const string&amp; str); //替换从 pos 开始 n 个字符为字符串 str<br>string&amp; replace(int pos, int n,const char* s); //替换从 pos 开始的 n 个字符为字符串 s<br>示例：</p>\n<p>C++<br>//查找和替换<br>void test01()<br>{<br>//查找<br>string str1 = “abcdefgde”;</p>\n<pre><code>int pos = str1.find(&quot;de&quot;);\n\nif (pos == -1)\n{\n    cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;\n}\n\n\npos = str1.rfind(&quot;de&quot;);\n\ncout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;</code></pre><p>}</p>\n<p>void test02()<br>{<br>//替换<br>string str1 = “abcdefgde”;<br>str1.replace(1, 3, “1111”);</p>\n<pre><code>cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n//test02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>find 查找是从左往后，rfind 从右往左<br>find 找到字符串后返回查找的第一个字符位置，找不到返回-1<br>replace 在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串<br>3.1.6 string 字符串比较<br>功能描述：</p>\n<p>字符串之间的比较<br>比较方式：</p>\n<p>字符串比较是按字符的 ASCII 码进行对比<br>= 返回 0</p>\n<blockquote>\n<p>返回 1</p>\n</blockquote>\n<p>&lt; 返回 -1</p>\n<p>函数原型：</p>\n<p>int compare(const string &amp;s) const; //与字符串 s 比较<br>int compare(const char *s) const; //与字符串 s 比较<br>示例：</p>\n<p>C++<br>//字符串比较<br>void test01()<br>{</p>\n<pre><code>string s1 = &quot;hello&quot;;\nstring s2 = &quot;aello&quot;;\n\nint ret = s1.compare(s2);\n\nif (ret == 0) {\n    cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl;\n}\nelse if (ret &gt; 0)\n{\n    cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>\n<p>3.1.7 string 字符存取<br>string 中单个字符存取方式有两种</p>\n<p>char&amp; operator[](int n); //通过[]方式取字符<br>char&amp; at(int n); //通过 at 方法获取字符<br>示例：</p>\n<p>C++<br>void test01()<br>{<br>string str = “hello world”;</p>\n<pre><code>for (int i = 0; i &lt; str.size(); i++)\n{\n    cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;\n\nfor (int i = 0; i &lt; str.size(); i++)\n{\n    cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;\n\n\n//字符修改\nstr[0] = &apos;x&apos;;\nstr.at(1) = &apos;x&apos;;\ncout &lt;&lt; str &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：string 字符串中单个字符存取有两种方式，利用 [ ] 或 at</p>\n<p>3.1.8 string 插入和删除<br>功能描述：</p>\n<p>对 string 字符串进行插入和删除字符操作<br>函数原型：</p>\n<p>string&amp; insert(int pos, const char* s); //插入字符串<br>string&amp; insert(int pos, const string&amp; str); //插入字符串<br>string&amp; insert(int pos, int n, char c); //在指定位置插入 n 个字符 c<br>string&amp; erase(int pos, int n = npos); //删除从 Pos 开始的 n 个字符<br>示例：</p>\n<p>C++<br>//字符串插入和删除<br>void test01()<br>{<br>string str = “hello”;<br>str.insert(1, “111”);<br>cout &lt;&lt; str &lt;&lt; endl;</p>\n<pre><code>str.erase(1, 3);  //从1号位置开始3个字符\ncout &lt;&lt; str &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：插入和删除的起始下标都是从 0 开始</p>\n<p>3.1.9 string 子串<br>功能描述：</p>\n<p>从字符串中获取想要的子串<br>函数原型：</p>\n<p>string substr(int pos = 0, int n = npos) const; //返回由 pos 开始的 n 个字符组成的字符串<br>示例：</p>\n<p>C++<br>//子串<br>void test01()<br>{</p>\n<pre><code>string str = &quot;abcdefg&quot;;\nstring subStr = str.substr(1, 3);\ncout &lt;&lt; &quot;subStr = &quot; &lt;&lt; subStr &lt;&lt; endl;\n\nstring email = &quot;hello@sina.com&quot;;\nint pos = email.find(&quot;@&quot;);\nstring username = email.substr(0, pos);\ncout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>\n<p>3.2 vector 容器<br>3.2.1 vector 基本概念<br>功能：</p>\n<p>vector 数据结构和数组非常相似，也称为单端数组<br>vector 与普通数组区别：</p>\n<p>不同之处在于数组是静态空间，而 vector 可以动态扩展<br>动态扩展：</p>\n<p>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间<br>说明: 2015-11-10_151152<br>说明: 2015-11-10_151152</p>\n<p>vector 容器的迭代器是支持随机访问的迭代器<br>3.2.2 vector 构造函数<br>功能描述：</p>\n<p>创建 vector 容器<br>函数原型：</p>\n<p>vector<T> v; //采用模板实现类实现，默认构造函数<br>vector(v.begin(), v.end()); //将 v[begin(), end())区间中的元素拷贝给本身。<br>vector(n, elem); //构造函数将 n 个 elem 拷贝给本身。<br>vector(const vector &amp;vec); //拷贝构造函数。<br>示例：</p>\n<p>C++<br>#include <vector></p>\n<p>void printVector(vector<int>&amp; v) {</p>\n<pre><code>for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>void test01()<br>{<br>vector<int> v1; //无参构造<br>for (int i = 0; i &lt; 10; i++)<br>{<br>v1.push_back(i);<br>}<br>printVector(v1);</p>\n<pre><code>vector&lt;int&gt; v2(v1.begin(), v1.end());\nprintVector(v2);\n\nvector&lt;int&gt; v3(10, 100);\nprintVector(v3);\n\nvector&lt;int&gt; v4(v3);\nprintVector(v4);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：vector 的多种构造方式没有可比性，灵活使用即可</p>\n<p>3.2.3 vector 赋值操作</p>\n<p>功能描述：</p>\n<p>给 vector 容器进行赋值<br>函数原型：</p>\n<p>vector&amp; operator=(const vector &amp;vec);//重载等号操作符<br>assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。<br>assign(n, elem); //将 n 个 elem 拷贝赋值给本身。<br>示例：</p>\n<p>C++<br>#include <vector></p>\n<p>void printVector(vector<int>&amp; v) {</p>\n<pre><code>for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>//赋值操作<br>void test01()<br>{<br>vector<int> v1; //无参构造<br>for (int i = 0; i &lt; 10; i++)<br>{<br>v1.push_back(i);<br>}<br>printVector(v1);</p>\n<pre><code>vector&lt;int&gt;v2;\nv2 = v1;\nprintVector(v2);\n\nvector&lt;int&gt;v3;\nv3.assign(v1.begin(), v1.end());\nprintVector(v3);\n\nvector&lt;int&gt;v4;\nv4.assign(10, 100);\nprintVector(v4);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： vector 赋值方式比较简单，使用 operator=，或者 assign 都可以</p>\n<p>3.2.4 vector 容量和大小<br>功能描述：</p>\n<p>对 vector 容器的容量和大小操作<br>函数原型：</p>\n<p>empty(); //判断容器是否为空</p>\n<p>capacity(); //容器的容量</p>\n<p>size(); //返回容器中元素的个数</p>\n<p>resize(int num); //重新指定容器的长度为 num，若容器变长，则以默认值填充新位置。</p>\n<p>​ //如果容器变短，则末尾超出容器长度的元素被删除。</p>\n<p>resize(int num, elem); //重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位置。</p>\n<p>​ //如果容器变短，则末尾超出容器长度的元素被删除</p>\n<p>示例：</p>\n<p>C++<br>#include <vector></p>\n<p>void printVector(vector<int>&amp; v) {</p>\n<pre><code>for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>void test01()<br>{<br>vector<int> v1;<br>for (int i = 0; i &lt; 10; i++)<br>{<br>v1.push_back(i);<br>}<br>printVector(v1);<br>if (v1.empty())<br>{<br>cout &lt;&lt; “v1 为空” &lt;&lt; endl;<br>}<br>else<br>{<br>cout &lt;&lt; “v1 不为空” &lt;&lt; endl;<br>cout &lt;&lt; “v1 的容量 = “ &lt;&lt; v1.capacity() &lt;&lt; endl;<br>cout &lt;&lt; “v1 的大小 = “ &lt;&lt; v1.size() &lt;&lt; endl;<br>}</p>\n<pre><code>//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充\nv1.resize(15,10);\nprintVector(v1);\n\n//resize 重新指定大小 ，若指定的更小，超出部分元素被删除\nv1.resize(5);\nprintVector(v1);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>判断是否为空 — empty<br>返回元素个数 — size<br>返回容器容量 — capacity<br>重新指定大小 — resize<br>3.2.5 vector 插入和删除<br>功能描述：</p>\n<p>对 vector 容器进行插入、删除操作<br>函数原型：</p>\n<p>push_back(ele); //尾部插入元素 ele<br>pop_back(); //删除最后一个元素<br>insert(const_iterator pos, ele); //迭代器指向位置 pos 插入元素 ele<br>insert(const_iterator pos, int count,ele);//迭代器指向位置 pos 插入 count 个元素 ele<br>erase(const_iterator pos); //删除迭代器指向的元素<br>erase(const_iterator start, const_iterator end);//删除迭代器从 start 到 end 之间的元素<br>clear(); //删除容器中所有元素<br>示例：</p>\n<p>C++</p>\n<p>#include <vector></p>\n<p>void printVector(vector<int>&amp; v) {</p>\n<pre><code>for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>//插入和删除<br>void test01()<br>{<br>vector<int> v1;<br>//尾插<br>v1.push_back(10);<br>v1.push_back(20);<br>v1.push_back(30);<br>v1.push_back(40);<br>v1.push_back(50);<br>printVector(v1);<br>//尾删<br>v1.pop_back();<br>printVector(v1);<br>//插入<br>v1.insert(v1.begin(), 100);<br>printVector(v1);</p>\n<pre><code>v1.insert(v1.begin(), 2, 1000);\nprintVector(v1);\n\n//删除\nv1.erase(v1.begin());\nprintVector(v1);\n\n//清空\nv1.erase(v1.begin(), v1.end());\nv1.clear();\nprintVector(v1);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>尾插 — push_back<br>尾删 — pop_back<br>插入 — insert (位置迭代器)<br>删除 — erase （位置迭代器）<br>清空 — clear<br>3.2.6 vector 数据存取<br>功能描述：</p>\n<p>对 vector 中的数据的存取操作<br>函数原型：</p>\n<p>at(int idx); //返回索引 idx 所指的数据<br>operator[]; //返回索引 idx 所指的数据<br>front(); //返回容器中第一个数据元素<br>back(); //返回容器中最后一个数据元素<br>示例：</p>\n<p>C++<br>#include <vector></p>\n<p>void test01()<br>{<br>vector<int>v1;<br>for (int i = 0; i &lt; 10; i++)<br>{<br>v1.push_back(i);<br>}</p>\n<pre><code>for (int i = 0; i &lt; v1.size(); i++)\n{\n    cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;\n\nfor (int i = 0; i &lt; v1.size(); i++)\n{\n    cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;\n\ncout &lt;&lt; &quot;v1的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl;\ncout &lt;&lt; &quot;v1的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>除了用迭代器获取 vector 容器中元素，[ ]和 at 也可以<br>front 返回容器第一个元素<br>back 返回容器最后一个元素<br>3.2.7 vector 互换容器<br>功能描述：</p>\n<p>实现两个容器内元素进行互换<br>函数原型：</p>\n<p>swap(vec); // 将 vec 与本身的元素互换<br>示例：</p>\n<p>C++<br>#include <vector></p>\n<p>void printVector(vector<int>&amp; v) {</p>\n<pre><code>for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>void test01()<br>{<br>vector<int>v1;<br>for (int i = 0; i &lt; 10; i++)<br>{<br>v1.push_back(i);<br>}<br>printVector(v1);</p>\n<pre><code>vector&lt;int&gt;v2;\nfor (int i = 10; i &gt; 0; i--)\n{\n    v2.push_back(i);\n}\nprintVector(v2);\n\n//互换容器\ncout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl;\nv1.swap(v2);\nprintVector(v1);\nprintVector(v2);</code></pre><p>}</p>\n<p>void test02()<br>{<br>vector<int> v;<br>for (int i = 0; i &lt; 100000; i++) {<br>v.push_back(i);<br>}</p>\n<pre><code>cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;\ncout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;\n\nv.resize(3);\n\ncout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;\ncout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;\n\n//收缩内存\nvector&lt;int&gt;(v).swap(v); //匿名对象\n\ncout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;\ncout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：swap 可以使两个容器互换，可以达到实用的收缩内存效果</p>\n<p>3.2.8 vector 预留空间<br>功能描述：</p>\n<p>减少 vector 在动态扩展容量时的扩展次数<br>函数原型：</p>\n<p>reserve(int len);//容器预留 len 个元素长度，预留位置不初始化，元素不可访问。<br>示例：</p>\n<p>C++<br>#include <vector></p>\n<p>void test01()<br>{<br>vector<int> v;</p>\n<pre><code>//预留空间\nv.reserve(100000);\n\nint num = 0;\nint* p = NULL;\nfor (int i = 0; i &lt; 100000; i++) {\n    v.push_back(i);\n    if (p != &amp;v[0]) {\n        p = &amp;v[0];\n        num++;\n    }\n}\n\ncout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：如果数据量较大，可以一开始利用 reserve 预留空间</p>\n<p>3.3 deque 容器<br>3.3.1 deque 容器基本概念<br>功能：</p>\n<p>双端数组，可以对头端进行插入删除操作<br>deque 与 vector 区别：</p>\n<p>vector 对于头部的插入删除效率低，数据量越大，效率越低<br>deque 相对而言，对头部的插入删除速度回比 vector 快<br>vector 访问元素时的速度会比 deque 快,这和两者内部实现有关<br>说明: 2015-11-19_204101<br>说明: 2015-11-19_204101</p>\n<p>deque 内部工作原理:</p>\n<p>deque 内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>\n<p>中控器维护的是每个缓冲区的地址，使得使用 deque 时像一片连续的内存空间</p>\n<p>clip_image002-1547547896341<br>clip_image002-1547547896341</p>\n<p>deque 容器的迭代器也是支持随机访问的<br>3.3.2 deque 构造函数<br>功能描述：</p>\n<p>deque 容器构造<br>函数原型：</p>\n<p>deque<T> deqT; //默认构造形式<br>deque(beg, end); //构造函数将[beg, end)区间中的元素拷贝给本身。<br>deque(n, elem); //构造函数将 n 个 elem 拷贝给本身。<br>deque(const deque &amp;deq); //拷贝构造函数<br>示例：</p>\n<p>C++<br>#include <deque></p>\n<p>void printDeque(const deque<int>&amp; d)<br>{<br>for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {<br>cout &lt;&lt; *it &lt;&lt; “ “;</p>\n<pre><code>}\ncout &lt;&lt; endl;</code></pre><p>}<br>//deque 构造<br>void test01() {</p>\n<pre><code>deque&lt;int&gt; d1; //无参构造函数\nfor (int i = 0; i &lt; 10; i++)\n{\n    d1.push_back(i);\n}\nprintDeque(d1);\ndeque&lt;int&gt; d2(d1.begin(),d1.end());\nprintDeque(d2);\n\ndeque&lt;int&gt;d3(10,100);\nprintDeque(d3);\n\ndeque&lt;int&gt;d4 = d3;\nprintDeque(d4);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：deque 容器和 vector 容器的构造方式几乎一致，灵活使用即可</p>\n<p>3.3.3 deque 赋值操作<br>功能描述：</p>\n<p>给 deque 容器进行赋值<br>函数原型：</p>\n<p>deque&amp; operator=(const deque &amp;deq); //重载等号操作符<br>assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。<br>assign(n, elem); //将 n 个 elem 拷贝赋值给本身。<br>示例：</p>\n<p>C++<br>#include <deque></p>\n<p>void printDeque(const deque<int>&amp; d)<br>{<br>for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {<br>cout &lt;&lt; *it &lt;&lt; “ “;</p>\n<pre><code>}\ncout &lt;&lt; endl;</code></pre><p>}<br>//赋值操作<br>void test01()<br>{<br>deque<int> d1;<br>for (int i = 0; i &lt; 10; i++)<br>{<br>d1.push_back(i);<br>}<br>printDeque(d1);</p>\n<pre><code>deque&lt;int&gt;d2;\nd2 = d1;\nprintDeque(d2);\n\ndeque&lt;int&gt;d3;\nd3.assign(d1.begin(), d1.end());\nprintDeque(d3);\n\ndeque&lt;int&gt;d4;\nd4.assign(10, 100);\nprintDeque(d4);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：deque 赋值操作也与 vector 相同，需熟练掌握</p>\n<p>3.3.4 deque 大小操作<br>功能描述：</p>\n<p>对 deque 容器的大小进行操作<br>函数原型：</p>\n<p>deque.empty(); //判断容器是否为空</p>\n<p>deque.size(); //返回容器中元素的个数</p>\n<p>deque.resize(num); //重新指定容器的长度为 num,若容器变长，则以默认值填充新位置。</p>\n<p>​ //如果容器变短，则末尾超出容器长度的元素被删除。</p>\n<p>deque.resize(num, elem); //重新指定容器的长度为 num,若容器变长，则以 elem 值填充新位置。</p>\n<p>​ //如果容器变短，则末尾超出容器长度的元素被删除。</p>\n<p>示例：</p>\n<p>C++<br>#include <deque></p>\n<p>void printDeque(const deque<int>&amp; d)<br>{<br>for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {<br>cout &lt;&lt; *it &lt;&lt; “ “;</p>\n<pre><code>}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>//大小操作<br>void test01()<br>{<br>deque<int> d1;<br>for (int i = 0; i &lt; 10; i++)<br>{<br>d1.push_back(i);<br>}<br>printDeque(d1);</p>\n<pre><code>//判断容器是否为空\nif (d1.empty()) {\n    cout &lt;&lt; &quot;d1为空!&quot; &lt;&lt; endl;\n}\nelse {\n    cout &lt;&lt; &quot;d1不为空!&quot; &lt;&lt; endl;\n    //统计大小\n    cout &lt;&lt; &quot;d1的大小为：&quot; &lt;&lt; d1.size() &lt;&lt; endl;\n}\n\n//重新指定大小\nd1.resize(15, 1);\nprintDeque(d1);\n\nd1.resize(5);\nprintDeque(d1);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>deque 没有容量的概念<br>判断是否为空 — empty<br>返回元素个数 — size<br>重新指定个数 — resize<br>3.3.5 deque 插入和删除<br>功能描述：</p>\n<p>向 deque 容器中插入和删除数据<br>函数原型：</p>\n<p>两端插入操作：</p>\n<p>push_back(elem); //在容器尾部添加一个数据<br>push_front(elem); //在容器头部插入一个数据<br>pop_back(); //删除容器最后一个数据<br>pop_front(); //删除容器第一个数据<br>指定位置操作：</p>\n<p>insert(pos,elem); //在 pos 位置插入一个 elem 元素的拷贝，返回新数据的位置。</p>\n<p>insert(pos,n,elem); //在 pos 位置插入 n 个 elem 数据，无返回值。</p>\n<p>insert(pos,beg,end); //在 pos 位置插入[beg,end)区间的数据，无返回值。</p>\n<p>clear(); //清空容器的所有数据</p>\n<p>erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。</p>\n<p>erase(pos); //删除 pos 位置的数据，返回下一个数据的位置。</p>\n<p>示例：</p>\n<p>C++<br>#include <deque></p>\n<p>void printDeque(const deque<int>&amp; d)<br>{<br>for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {<br>cout &lt;&lt; *it &lt;&lt; “ “;</p>\n<pre><code>}\ncout &lt;&lt; endl;</code></pre><p>}<br>//两端操作<br>void test01()<br>{<br>deque<int> d;<br>//尾插<br>d.push_back(10);<br>d.push_back(20);<br>//头插<br>d.push_front(100);<br>d.push_front(200);</p>\n<pre><code>printDeque(d);\n\n//尾删\nd.pop_back();\n//头删\nd.pop_front();\nprintDeque(d);</code></pre><p>}</p>\n<p>//插入<br>void test02()<br>{<br>deque<int> d;<br>d.push_back(10);<br>d.push_back(20);<br>d.push_front(100);<br>d.push_front(200);<br>printDeque(d);</p>\n<pre><code>d.insert(d.begin(), 1000);\nprintDeque(d);\n\nd.insert(d.begin(), 2,10000);\nprintDeque(d);\n\ndeque&lt;int&gt;d2;\nd2.push_back(1);\nd2.push_back(2);\nd2.push_back(3);\n\nd.insert(d.begin(), d2.begin(), d2.end());\nprintDeque(d);</code></pre><p>}</p>\n<p>//删除<br>void test03()<br>{<br>deque<int> d;<br>d.push_back(10);<br>d.push_back(20);<br>d.push_front(100);<br>d.push_front(200);<br>printDeque(d);</p>\n<pre><code>d.erase(d.begin());\nprintDeque(d);\n\nd.erase(d.begin(), d.end());\nd.clear();\nprintDeque(d);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n\n//test02();\n\ntest03();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>插入和删除提供的位置是迭代器！<br>尾插 — push_back<br>尾删 — pop_back<br>头插 — push_front<br>头删 — pop_front<br>3.3.6 deque 数据存取<br>功能描述：</p>\n<p>对 deque 中的数据的存取操作<br>函数原型：</p>\n<p>at(int idx); //返回索引 idx 所指的数据<br>operator[]; //返回索引 idx 所指的数据<br>front(); //返回容器中第一个数据元素<br>back(); //返回容器中最后一个数据元素<br>示例：</p>\n<p>C++<br>#include <deque></p>\n<p>void printDeque(const deque<int>&amp; d)<br>{<br>for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {<br>cout &lt;&lt; *it &lt;&lt; “ “;</p>\n<pre><code>}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>//数据存取<br>void test01()<br>{</p>\n<pre><code>deque&lt;int&gt; d;\nd.push_back(10);\nd.push_back(20);\nd.push_front(100);\nd.push_front(200);\n\nfor (int i = 0; i &lt; d.size(); i++) {\n    cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;\n\n\nfor (int i = 0; i &lt; d.size(); i++) {\n    cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;\n\ncout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl;\n\ncout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>除了用迭代器获取 deque 容器中元素，[ ]和 at 也可以<br>front 返回容器第一个元素<br>back 返回容器最后一个元素<br>3.3.7 deque 排序<br>功能描述：</p>\n<p>利用算法实现对 deque 容器进行排序<br>算法：</p>\n<p>sort(iterator beg, iterator end) //对 beg 和 end 区间内元素进行排序<br>示例：</p>\n<p>C++<br>#include <deque><br>#include <algorithm></p>\n<p>void printDeque(const deque<int>&amp; d)<br>{<br>for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {<br>cout &lt;&lt; *it &lt;&lt; “ “;</p>\n<pre><code>}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>void test01()<br>{</p>\n<pre><code>deque&lt;int&gt; d;\nd.push_back(10);\nd.push_back(20);\nd.push_front(100);\nd.push_front(200);\n\nprintDeque(d);\nsort(d.begin(), d.end());\nprintDeque(d);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：sort 算法非常实用，使用时包含头文件 algorithm 即可</p>\n<p>3.4 案例-评委打分<br>3.4.1 案例描述<br>有 5 名选手：选手 ABCDE，10 个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p>\n<p>3.4.2 实现步骤<br>创建五名选手，放到 vector 中<br>遍历 vector 容器，取出来每一个选手，执行 for 循环，可以把 10 个评分打分存到 deque 容器中<br>sort 算法对 deque 容器中分数排序，去除最高和最低分<br>deque 容器遍历一遍，累加总分<br>获取平均分<br>示例代码：</p>\n<p>C++<br>//选手类<br>class Person<br>{<br>public:<br>Person(string name, int score)<br>{<br>this-&gt;m_Name = name;<br>this-&gt;m_Score = score;<br>}</p>\n<pre><code>string m_Name; //姓名\nint m_Score;  //平均分</code></pre><p>};</p>\n<p>void createPerson(vector<Person>&amp;v)<br>{<br>string nameSeed = “ABCDE”;<br>for (int i = 0; i &lt; 5; i++)<br>{<br>string name = “选手”;<br>name += nameSeed[i];</p>\n<pre><code>    int score = 0;\n\n    Person p(name, score);\n\n    //将创建的person对象 放入到容器中\n    v.push_back(p);\n}</code></pre><p>}</p>\n<p>//打分<br>void setScore(vector<Person>&amp;v)<br>{<br>for (vector<Person>::iterator it = v.begin(); it != v.end(); it++)<br>{<br>//将评委的分数 放入到 deque 容器中<br>deque<int>d;<br>for (int i = 0; i &lt; 10; i++)<br>{<br>int score = rand() % 41 + 60; // 60 ~ 100<br>d.push_back(score);<br>}</p>\n<pre><code>    //cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;\n    //for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)\n    //{\n    //    cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;\n    //}\n    //cout &lt;&lt; endl;\n\n    //排序\n    sort(d.begin(), d.end());\n\n    //去除最高和最低分\n    d.pop_back();\n    d.pop_front();\n\n    //取平均分\n    int sum = 0;\n    for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)\n    {\n        sum += *dit; //累加每个评委的分数\n    }\n\n    int avg = sum / d.size();\n\n    //将平均分 赋值给选手身上\n    it-&gt;m_Score = avg;\n}</code></pre><p>}</p>\n<p>void showScore(vector<Person>&amp;v)<br>{<br>for (vector<Person>::iterator it = v.begin(); it != v.end(); it++)<br>{<br>cout &lt;&lt; “姓名： “ &lt;&lt; it-&gt;m_Name &lt;&lt; “ 平均分： “ &lt;&lt; it-&gt;m_Score &lt;&lt; endl;<br>}<br>}</p>\n<p>int main() {</p>\n<pre><code>//随机数种子\nsrand((unsigned int)time(NULL));\n\n//1、创建5名选手\nvector&lt;Person&gt;v;  //存放选手容器\ncreatePerson(v);\n\n//测试\n//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)\n//{\n//    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;\n//}\n\n//2、给5名选手打分\nsetScore(v);\n\n//3、显示最后得分\nshowScore(v);\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 选取不同的容器操作数据，可以提升代码的效率</p>\n<p>3.5 stack 容器<br>3.5.1 stack 基本概念<br>概念：stack 是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口</p>\n<p>说明: 2015-11-15_195707<br>说明: 2015-11-15_195707</p>\n<p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p>\n<p>栈中进入数据称为 — 入栈 push</p>\n<p>栈中弹出数据称为 — 出栈 pop</p>\n<p>生活中的栈：</p>\n<p>img<br>img</p>\n<p>img<br>img</p>\n<p>3.5.2 stack 常用接口<br>功能描述：栈容器常用的对外接口</p>\n<p>构造函数：</p>\n<p>stack<T> stk; //stack 采用模板类实现， stack 对象的默认构造形式<br>stack(const stack &amp;stk); //拷贝构造函数<br>赋值操作：</p>\n<p>stack&amp; operator=(const stack &amp;stk); //重载等号操作符<br>数据存取：</p>\n<p>push(elem); //向栈顶添加元素<br>pop(); //从栈顶移除第一个元素<br>top(); //返回栈顶元素<br>大小操作：</p>\n<p>empty(); //判断堆栈是否为空<br>size(); //返回栈的大小<br>示例：</p>\n<p>C++<br>#include <stack></p>\n<p>//栈容器常用接口<br>void test01()<br>{<br>//创建栈容器 栈容器必须符合先进后出<br>stack<int> s;</p>\n<pre><code>//向栈中添加元素，叫做 压栈 入栈\ns.push(10);\ns.push(20);\ns.push(30);\n\nwhile (!s.empty()) {\n    //输出栈顶元素\n    cout &lt;&lt; &quot;栈顶元素为： &quot; &lt;&lt; s.top() &lt;&lt; endl;\n    //弹出栈顶元素\n    s.pop();\n}\ncout &lt;&lt; &quot;栈的大小为：&quot; &lt;&lt; s.size() &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>入栈 — push<br>出栈 — pop<br>返回栈顶 — top<br>判断栈是否为空 — empty<br>返回栈大小 — size<br>3.6 queue 容器<br>3.6.1 queue 基本概念<br>概念：Queue 是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口</p>\n<p>说明: 2015-11-15_214429<br>说明: 2015-11-15_214429</p>\n<p>队列容器允许从一端新增元素，从另一端移除元素</p>\n<p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p>\n<p>队列中进数据称为 — 入队 push</p>\n<p>队列中出数据称为 — 出队 pop</p>\n<p>生活中的队列：</p>\n<p>1547606785041<br>1547606785041</p>\n<p>3.6.2 queue 常用接口<br>功能描述：栈容器常用的对外接口</p>\n<p>构造函数：</p>\n<p>queue<T> que; //queue 采用模板类实现，queue 对象的默认构造形式<br>queue(const queue &amp;que); //拷贝构造函数<br>赋值操作：</p>\n<p>queue&amp; operator=(const queue &amp;que); //重载等号操作符<br>数据存取：</p>\n<p>push(elem); //往队尾添加元素<br>pop(); //从队头移除第一个元素<br>back(); //返回最后一个元素<br>front(); //返回第一个元素<br>大小操作：</p>\n<p>empty(); //判断堆栈是否为空<br>size(); //返回栈的大小<br>示例：</p>\n<p>C++<br>#include <queue><br>#include <string><br>class Person<br>{<br>public:<br>Person(string name, int age)<br>{<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>}</p>\n<pre><code>string m_Name;\nint m_Age;</code></pre><p>};</p>\n<p>void test01() {</p>\n<pre><code>//创建队列\nqueue&lt;Person&gt; q;\n\n//准备数据\nPerson p1(&quot;唐僧&quot;, 30);\nPerson p2(&quot;孙悟空&quot;, 1000);\nPerson p3(&quot;猪八戒&quot;, 900);\nPerson p4(&quot;沙僧&quot;, 800);\n\n//向队列中添加元素  入队操作\nq.push(p1);\nq.push(p2);\nq.push(p3);\nq.push(p4);\n\n//队列不提供迭代器，更不支持随机访问\nwhile (!q.empty()) {\n    //输出队头元素\n    cout &lt;&lt; &quot;队头元素-- 姓名： &quot; &lt;&lt; q.front().m_Name\n          &lt;&lt; &quot; 年龄： &quot;&lt;&lt; q.front().m_Age &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;队尾元素-- 姓名： &quot; &lt;&lt; q.back().m_Name\n          &lt;&lt; &quot; 年龄： &quot; &lt;&lt; q.back().m_Age &lt;&lt; endl;\n\n    cout &lt;&lt; endl;\n    //弹出队头元素\n    q.pop();\n}\n\ncout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>入队 — push<br>出队 — pop<br>返回队头元素 — front<br>返回队尾元素 — back<br>判断队是否为空 — empty<br>返回队列大小 — size<br>3.7 list 容器<br>3.7.1 list 基本概念<br>功能：将数据进行链式存储</p>\n<p>链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>\n<p>链表的组成：链表由一系列结点组成</p>\n<p>结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>\n<p>STL 中的链表是一个双向循环链表</p>\n<p>说明: 2015-11-15_225145<br>说明: 2015-11-15_225145</p>\n<p>由于链表的存储方式并不是连续的内存空间，因此链表 list 中的迭代器只支持前移和后移，属于双向迭代器</p>\n<p>list 的优点：</p>\n<p>采用动态存储分配，不会造成内存浪费和溢出<br>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素<br>list 的缺点：</p>\n<p>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大<br>List 有一个重要的性质，插入操作和删除操作都不会造成原有 list 迭代器的失效，这在 vector 是不成立的。</p>\n<p>总结：STL 中 List 和 vector 是两个最常被使用的容器，各有优缺点</p>\n<p>3.7.2 list 构造函数<br>功能描述：</p>\n<p>创建 list 容器<br>函数原型：</p>\n<p>list<T> lst; //list 采用采用模板类实现,对象的默认构造形式：<br>list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。<br>list(n,elem); //构造函数将 n 个 elem 拷贝给本身。<br>list(const list &amp;lst); //拷贝构造函数。<br>示例：</p>\n<p>C++<br>#include <list></p>\n<p>void printList(const list<int>&amp; L) {</p>\n<pre><code>for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>void test01()<br>{<br>list<int>L1;<br>L1.push_back(10);<br>L1.push_back(20);<br>L1.push_back(30);<br>L1.push_back(40);</p>\n<pre><code>printList(L1);\n\nlist&lt;int&gt;L2(L1.begin(),L1.end());\nprintList(L2);\n\nlist&lt;int&gt;L3(L2);\nprintList(L3);\n\nlist&lt;int&gt;L4(10, 1000);\nprintList(L4);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：list 构造方式同其他几个 STL 常用容器，熟练掌握即可</p>\n<p>3.7.3 list 赋值和交换<br>功能描述：</p>\n<p>给 list 容器进行赋值，以及交换 list 容器<br>函数原型：</p>\n<p>assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。<br>assign(n, elem); //将 n 个 elem 拷贝赋值给本身。<br>list&amp; operator=(const list &amp;lst); //重载等号操作符<br>swap(lst); //将 lst 与本身的元素互换。<br>示例：</p>\n<p>C++<br>#include <list></p>\n<p>void printList(const list<int>&amp; L) {</p>\n<pre><code>for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>//赋值和交换<br>void test01()<br>{<br>list<int>L1;<br>L1.push_back(10);<br>L1.push_back(20);<br>L1.push_back(30);<br>L1.push_back(40);<br>printList(L1);</p>\n<pre><code>//赋值\nlist&lt;int&gt;L2;\nL2 = L1;\nprintList(L2);\n\nlist&lt;int&gt;L3;\nL3.assign(L2.begin(), L2.end());\nprintList(L3);\n\nlist&lt;int&gt;L4;\nL4.assign(10, 100);\nprintList(L4);</code></pre><p>}</p>\n<p>//交换<br>void test02()<br>{</p>\n<pre><code>list&lt;int&gt;L1;\nL1.push_back(10);\nL1.push_back(20);\nL1.push_back(30);\nL1.push_back(40);\n\nlist&lt;int&gt;L2;\nL2.assign(10, 100);\n\ncout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;\nprintList(L1);\nprintList(L2);\n\ncout &lt;&lt; endl;\n\nL1.swap(L2);\n\ncout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;\nprintList(L1);\nprintList(L2);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：list 赋值和交换操作能够灵活运用即可</p>\n<p>3.7.4 list 大小操作<br>功能描述：</p>\n<p>对 list 容器的大小进行操作<br>函数原型：</p>\n<p>size(); //返回容器中元素的个数</p>\n<p>empty(); //判断容器是否为空</p>\n<p>resize(num); //重新指定容器的长度为 num，若容器变长，则以默认值填充新位置。</p>\n<p>​ //如果容器变短，则末尾超出容器长度的元素被删除。</p>\n<p>resize(num, elem); //重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位置。</p>\n<p>​ //如果容器变短，则末尾超出容器长度的元素被删除。<br>示例：</p>\n<p>C++<br>#include <list></p>\n<p>void printList(const list<int>&amp; L) {</p>\n<pre><code>for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>//大小操作<br>void test01()<br>{<br>list<int>L1;<br>L1.push_back(10);<br>L1.push_back(20);<br>L1.push_back(30);<br>L1.push_back(40);</p>\n<pre><code>if (L1.empty())\n{\n    cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl;\n}\n\n//重新指定大小\nL1.resize(10);\nprintList(L1);\n\nL1.resize(2);\nprintList(L1);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>判断是否为空 — empty<br>返回元素个数 — size<br>重新指定个数 — resize<br>3.7.5 list 插入和删除<br>功能描述：</p>\n<p>对 list 容器进行数据的插入和删除<br>函数原型：</p>\n<p>push_back(elem);//在容器尾部加入一个元素<br>pop_back();//删除容器中最后一个元素<br>push_front(elem);//在容器开头插入一个元素<br>pop_front();//从容器开头移除第一个元素<br>insert(pos,elem);//在 pos 位置插 elem 元素的拷贝，返回新数据的位置。<br>insert(pos,n,elem);//在 pos 位置插入 n 个 elem 数据，无返回值。<br>insert(pos,beg,end);//在 pos 位置插入[beg,end)区间的数据，无返回值。<br>clear();//移除容器的所有数据<br>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。<br>erase(pos);//删除 pos 位置的数据，返回下一个数据的位置。<br>remove(elem);//删除容器中所有与 elem 值匹配的元素。<br>示例：</p>\n<p>C++<br>#include <list></p>\n<p>void printList(const list<int>&amp; L) {</p>\n<pre><code>for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>//插入和删除<br>void test01()<br>{<br>list<int> L;<br>//尾插<br>L.push_back(10);<br>L.push_back(20);<br>L.push_back(30);<br>//头插<br>L.push_front(100);<br>L.push_front(200);<br>L.push_front(300);</p>\n<pre><code>printList(L);\n\n//尾删\nL.pop_back();\nprintList(L);\n\n//头删\nL.pop_front();\nprintList(L);\n\n//插入\nlist&lt;int&gt;::iterator it = L.begin();\nL.insert(++it, 1000);\nprintList(L);\n\n//删除\nit = L.begin();\nL.erase(++it);\nprintList(L);\n\n//移除\nL.push_back(10000);\nL.push_back(10000);\nL.push_back(10000);\nprintList(L);\nL.remove(10000);\nprintList(L);\n\n//清空\nL.clear();\nprintList(L);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>尾插 — push_back<br>尾删 — pop_back<br>头插 — push_front<br>头删 — pop_front<br>插入 — insert<br>删除 — erase<br>移除 — remove<br>清空 — clear<br>3.7.6 list 数据存取<br>功能描述：</p>\n<p>对 list 容器中数据进行存取<br>函数原型：</p>\n<p>front(); //返回第一个元素。<br>back(); //返回最后一个元素。<br>示例：</p>\n<p>C++<br>#include <list></p>\n<p>//数据存取<br>void test01()<br>{<br>list<int>L1;<br>L1.push_back(10);<br>L1.push_back(20);<br>L1.push_back(30);<br>L1.push_back(40);</p>\n<pre><code>//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据\n//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据\ncout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl;\ncout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl;\n\n//list容器的迭代器是双向迭代器，不支持随机访问\nlist&lt;int&gt;::iterator it = L1.begin();\n//it = it + 1;//错误，不可以跳跃访问，即使是+1</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>list 容器中不可以通过[]或者 at 方式访问数据<br>返回第一个元素 — front<br>返回最后一个元素 — back<br>3.7.7 list 反转和排序<br>功能描述：</p>\n<p>将容器中的元素反转，以及将容器中的数据进行排序<br>函数原型：</p>\n<p>reverse(); //反转链表<br>sort(); //链表排序<br>示例：</p>\n<p>C++<br>void printList(const list<int>&amp; L) {</p>\n<pre><code>for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>bool myCompare(int val1 , int val2)<br>{<br>return val1 &gt; val2;<br>}</p>\n<p>//反转和排序<br>void test01()<br>{<br>list<int> L;<br>L.push_back(90);<br>L.push_back(30);<br>L.push_back(20);<br>L.push_back(70);<br>printList(L);</p>\n<pre><code>//反转容器的元素\nL.reverse();\nprintList(L);\n\n//排序\nL.sort(); //默认的排序规则 从小到大\nprintList(L);\n\nL.sort(myCompare); //指定规则，从大到小\nprintList(L);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>反转 — reverse<br>排序 — sort （成员函数）<br>3.7.8 排序案例<br>案例描述：将 Person 自定义数据类型进行排序，Person 中属性有姓名、年龄、身高</p>\n<p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p>\n<p>示例：</p>\n<p>C++<br>#include <list><br>#include <string><br>class Person {<br>public:<br>Person(string name, int age , int height) {<br>m_Name = name;<br>m_Age = age;<br>m_Height = height;<br>}</p>\n<p>public:<br>string m_Name; //姓名<br>int m_Age; //年龄<br>int m_Height; //身高<br>};</p>\n<p>bool ComparePerson(Person&amp; p1, Person&amp; p2) {</p>\n<pre><code>if (p1.m_Age == p2.m_Age) {\n    return p1.m_Height  &gt; p2.m_Height;\n}\nelse\n{\n    return  p1.m_Age &lt; p2.m_Age;\n}</code></pre><p>}</p>\n<p>void test01() {</p>\n<pre><code>list&lt;Person&gt; L;\n\nPerson p1(&quot;刘备&quot;, 35 , 175);\nPerson p2(&quot;曹操&quot;, 45 , 180);\nPerson p3(&quot;孙权&quot;, 40 , 170);\nPerson p4(&quot;赵云&quot;, 25 , 190);\nPerson p5(&quot;张飞&quot;, 35 , 160);\nPerson p6(&quot;关羽&quot;, 35 , 200);\n\nL.push_back(p1);\nL.push_back(p2);\nL.push_back(p3);\nL.push_back(p4);\nL.push_back(p5);\nL.push_back(p6);\n\nfor (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) {\n    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age\n          &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;\n}\n\ncout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;\nL.sort(ComparePerson); //排序\n\nfor (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) {\n    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age\n          &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序<br>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂<br>3.8 set/ multiset 容器<br>3.8.1 set 基本概念<br>简介：</p>\n<p>所有元素都会在插入时自动被排序<br>本质：</p>\n<p>set/multiset 属于关联式容器，底层结构是用二叉树实现。<br>set 和 multiset 区别：</p>\n<p>set 不允许容器中有重复的元素<br>multiset 允许容器中有重复的元素<br>3.8.2 set 构造和赋值<br>功能描述：创建 set 容器以及赋值</p>\n<p>构造：</p>\n<p>set<T> st; //默认构造函数：<br>set(const set &amp;st); //拷贝构造函数<br>赋值：</p>\n<p>set&amp; operator=(const set &amp;st); //重载等号操作符<br>示例：</p>\n<p>C++<br>#include <set></p>\n<p>void printSet(set<int> &amp; s)<br>{<br>for (set<int>::iterator it = s.begin(); it != s.end(); it++)<br>{<br>cout &lt;&lt; *it &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>}</p>\n<p>//构造和赋值<br>void test01()<br>{<br>set<int> s1;</p>\n<pre><code>s1.insert(10);\ns1.insert(30);\ns1.insert(20);\ns1.insert(40);\nprintSet(s1);\n\n//拷贝构造\nset&lt;int&gt;s2(s1);\nprintSet(s2);\n\n//赋值\nset&lt;int&gt;s3;\ns3 = s2;\nprintSet(s3);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>set 容器插入数据时用 insert<br>set 容器插入数据的数据会自动排序<br>3.8.3 set 大小和交换<br>功能描述：</p>\n<p>统计 set 容器大小以及交换 set 容器<br>函数原型：</p>\n<p>size(); //返回容器中元素的数目<br>empty(); //判断容器是否为空<br>swap(st); //交换两个集合容器<br>示例：</p>\n<p>C++<br>#include <set></p>\n<p>void printSet(set<int> &amp; s)<br>{<br>for (set<int>::iterator it = s.begin(); it != s.end(); it++)<br>{<br>cout &lt;&lt; *it &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>}</p>\n<p>//大小<br>void test01()<br>{</p>\n<pre><code>set&lt;int&gt; s1;\n\ns1.insert(10);\ns1.insert(30);\ns1.insert(20);\ns1.insert(40);\n\nif (s1.empty())\n{\n    cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>//交换<br>void test02()<br>{<br>set<int> s1;</p>\n<pre><code>s1.insert(10);\ns1.insert(30);\ns1.insert(20);\ns1.insert(40);\n\nset&lt;int&gt; s2;\n\ns2.insert(100);\ns2.insert(300);\ns2.insert(200);\ns2.insert(400);\n\ncout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;\nprintSet(s1);\nprintSet(s2);\ncout &lt;&lt; endl;\n\ncout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;\ns1.swap(s2);\nprintSet(s1);\nprintSet(s2);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>统计大小 — size<br>判断是否为空 — empty<br>交换容器 — swap<br>3.8.4 set 插入和删除<br>功能描述：</p>\n<p>set 容器进行插入数据和删除数据<br>函数原型：</p>\n<p>insert(elem); //在容器中插入元素。<br>clear(); //清除所有元素<br>erase(pos); //删除 pos 迭代器所指的元素，返回下一个元素的迭代器。<br>erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。<br>erase(elem); //删除容器中值为 elem 的元素。<br>示例：</p>\n<p>C++<br>#include <set></p>\n<p>void printSet(set<int> &amp; s)<br>{<br>for (set<int>::iterator it = s.begin(); it != s.end(); it++)<br>{<br>cout &lt;&lt; *it &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>}</p>\n<p>//插入和删除<br>void test01()<br>{<br>set<int> s1;<br>//插入<br>s1.insert(10);<br>s1.insert(30);<br>s1.insert(20);<br>s1.insert(40);<br>printSet(s1);</p>\n<pre><code>//删除\ns1.erase(s1.begin());\nprintSet(s1);\n\ns1.erase(30);\nprintSet(s1);\n\n//清空\n//s1.erase(s1.begin(), s1.end());\ns1.clear();\nprintSet(s1);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>插入 — insert<br>删除 — erase<br>清空 — clear<br>3.8.5 set 查找和统计<br>功能描述：</p>\n<p>对 set 容器进行查找数据以及统计数据<br>函数原型：</p>\n<p>find(key); //查找 key 是否存在,若存在，返回该键的元素的迭代器；若不存在，返回 set.end();<br>count(key); //统计 key 的元素个数<br>示例：</p>\n<p>C++<br>#include <set></p>\n<p>//查找和统计<br>void test01()<br>{<br>set<int> s1;<br>//插入<br>s1.insert(10);<br>s1.insert(30);<br>s1.insert(20);<br>s1.insert(40);<br>//查找<br>set<int>::iterator pos = s1.find(30);</p>\n<pre><code>if (pos != s1.end())\n{\n    cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;\n}\n\n//统计\nint num = s1.count(30);\ncout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>查找 — find （返回的是迭代器）<br>统计 — count （对于 set，结果为 0 或者 1）<br>3.8.6 set 和 multiset 区别<br>学习目标：</p>\n<p>掌握 set 和 multiset 的区别<br>区别：</p>\n<p>set 不可以插入重复数据，而 multiset 可以<br>set 插入数据的同时会返回插入结果，表示插入是否成功<br>multiset 不会检测数据，因此可以插入重复数据<br>示例：</p>\n<p>C++<br>#include <set></p>\n<p>//set 和 multiset 区别<br>void test01()<br>{<br>set<int> s;<br>pair&lt;set<int>::iterator, bool&gt; ret = s.insert(10);<br>if (ret.second) {<br>cout &lt;&lt; “第一次插入成功!” &lt;&lt; endl;<br>}<br>else {<br>cout &lt;&lt; “第一次插入失败!” &lt;&lt; endl;<br>}</p>\n<pre><code>ret = s.insert(10);\nif (ret.second) {\n    cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl;\n}\nelse {\n    cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl;\n}\n\n//multiset\nmultiset&lt;int&gt; ms;\nms.insert(10);\nms.insert(10);\n\nfor (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>如果不允许插入重复数据可以利用 set<br>如果需要插入重复数据利用 multiset<br>3.8.7 pair 对组创建<br>功能描述：</p>\n<p>成对出现的数据，利用对组可以返回两个数据<br>两种创建方式：</p>\n<p>pair&lt;type, type&gt; p ( value1, value2 );<br>pair&lt;type, type&gt; p = make_pair( value1, value2 );<br>示例：</p>\n<p>C++<br>#include <string></p>\n<p>//对组创建<br>void test01()<br>{<br>pair&lt;string, int&gt; p(string(“Tom”), 20);<br>cout &lt;&lt; “姓名： “ &lt;&lt; p.first &lt;&lt; “ 年龄： “ &lt;&lt; p.second &lt;&lt; endl;</p>\n<pre><code>pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 10);\ncout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p2.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>两种方式都可以创建对组，记住一种即可</p>\n<p>3.8.8 set 容器排序<br>学习目标：</p>\n<p>set 容器默认排序规则为从小到大，掌握如何改变排序规则<br>主要技术点：</p>\n<p>利用仿函数，可以改变排序规则<br>示例一 set 存放内置数据类型</p>\n<p>C++<br>#include <set></p>\n<p>class MyCompare<br>{<br>public:<br>bool operator()(int v1, int v2) {<br>return v1 &gt; v2;<br>}<br>};<br>void test01()<br>{<br> set<int> s1;<br>s1.insert(10);<br>s1.insert(40);<br>s1.insert(20);<br>s1.insert(30);<br>s1.insert(50);</p>\n<pre><code>//默认从小到大\nfor (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;\n\n//指定排序规则\nset&lt;int,MyCompare&gt; s2;\ns2.insert(10);\ns2.insert(40);\ns2.insert(20);\ns2.insert(30);\ns2.insert(50);\n\nfor (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：利用仿函数可以指定 set 容器的排序规则</p>\n<p>示例二 set 存放自定义数据类型</p>\n<p>C++<br>#include <set><br>#include <string></p>\n<p>class Person<br>{<br>public:<br>Person(string name, int age)<br>{<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>}</p>\n<pre><code>string m_Name;\nint m_Age;</code></pre><p>};<br>class comparePerson<br>{<br>public:<br>bool operator()(const Person&amp; p1, const Person &amp;p2)<br>{<br>//按照年龄进行排序 降序<br>return p1.m_Age &gt; p2.m_Age;<br>}<br>};</p>\n<p>void test01()<br>{<br>set&lt;Person, comparePerson&gt; s;</p>\n<pre><code>Person p1(&quot;刘备&quot;, 23);\nPerson p2(&quot;关羽&quot;, 27);\nPerson p3(&quot;张飞&quot;, 25);\nPerson p4(&quot;赵云&quot;, 21);\n\ns.insert(p1);\ns.insert(p2);\ns.insert(p3);\ns.insert(p4);\n\nfor (set&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++)\n{\n    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;\n}</code></pre><p>}<br>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>对于自定义数据类型，set 必须指定排序规则才可以插入数据</p>\n<p>3.9 map/ multimap 容器<br>3.9.1 map 基本概念<br>简介：</p>\n<p>map 中所有元素都是 pair<br>pair 中第一个元素为 key（键值），起到索引作用，第二个元素为 value（实值）<br>所有元素都会根据元素的键值自动排序<br>本质：</p>\n<p>map/multimap 属于关联式容器，底层结构是用二叉树实现。<br>优点：</p>\n<p>可以根据 key 值快速找到 value 值<br>map 和 multimap 区别：</p>\n<p>map 不允许容器中有重复 key 值元素<br>multimap 允许容器中有重复 key 值元素<br>3.9.2 map 构造和赋值<br>功能描述：</p>\n<p>对 map 容器进行构造和赋值操作<br>函数原型：</p>\n<p>构造：</p>\n<p>map&lt;T1, T2&gt; mp; //map 默认构造函数:<br>map(const map &amp;mp); //拷贝构造函数<br>赋值：</p>\n<p>map&amp; operator=(const map &amp;mp); //重载等号操作符<br>示例：</p>\n<p>C++<br>#include <map></p>\n<p>void printMap(map&lt;int,int&gt;&amp;m)<br>{<br>for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)<br>{<br>cout &lt;&lt; “key = “ &lt;&lt; it-&gt;first &lt;&lt; “ value = “ &lt;&lt; it-&gt;second &lt;&lt; endl;<br>}<br>cout &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>map&lt;int,int&gt;m; //默认构造<br>m.insert(pair&lt;int, int&gt;(1, 10));<br>m.insert(pair&lt;int, int&gt;(2, 20));<br>m.insert(pair&lt;int, int&gt;(3, 30));<br>printMap(m);</p>\n<pre><code>map&lt;int, int&gt;m2(m); //拷贝构造\nprintMap(m2);\n\nmap&lt;int, int&gt;m3;\nm3 = m2; //赋值\nprintMap(m3);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：map 中所有元素都是成对出现，插入数据时候要使用对组</p>\n<p>3.9.3 map 大小和交换<br>功能描述：</p>\n<p>统计 map 容器大小以及交换 map 容器<br>函数原型：</p>\n<p>size(); //返回容器中元素的数目<br>empty(); //判断容器是否为空<br>swap(st); //交换两个集合容器<br>示例：</p>\n<p>C++<br>#include <map></p>\n<p>void printMap(map&lt;int,int&gt;&amp;m)<br>{<br>for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)<br>{<br>cout &lt;&lt; “key = “ &lt;&lt; it-&gt;first &lt;&lt; “ value = “ &lt;&lt; it-&gt;second &lt;&lt; endl;<br>}<br>cout &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>map&lt;int, int&gt;m;<br>m.insert(pair&lt;int, int&gt;(1, 10));<br>m.insert(pair&lt;int, int&gt;(2, 20));<br>m.insert(pair&lt;int, int&gt;(3, 30));</p>\n<pre><code>if (m.empty())\n{\n    cout &lt;&lt; &quot;m为空&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;m不为空&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;m的大小为： &quot; &lt;&lt; m.size() &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>//交换<br>void test02()<br>{<br>map&lt;int, int&gt;m;<br>m.insert(pair&lt;int, int&gt;(1, 10));<br>m.insert(pair&lt;int, int&gt;(2, 20));<br>m.insert(pair&lt;int, int&gt;(3, 30));</p>\n<pre><code>map&lt;int, int&gt;m2;\nm2.insert(pair&lt;int, int&gt;(4, 100));\nm2.insert(pair&lt;int, int&gt;(5, 200));\nm2.insert(pair&lt;int, int&gt;(6, 300));\n\ncout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;\nprintMap(m);\nprintMap(m2);\n\ncout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;\nm.swap(m2);\nprintMap(m);\nprintMap(m2);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>统计大小 — size<br>判断是否为空 — empty<br>交换容器 — swap<br>3.9.4 map 插入和删除<br>功能描述：</p>\n<p>map 容器进行插入数据和删除数据<br>函数原型：</p>\n<p>insert(elem); //在容器中插入元素。<br>clear(); //清除所有元素<br>erase(pos); //删除 pos 迭代器所指的元素，返回下一个元素的迭代器。<br>erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。<br>erase(key); //删除容器中值为 key 的元素。<br>示例：</p>\n<p>C++<br>#include <map></p>\n<p>void printMap(map&lt;int,int&gt;&amp;m)<br>{<br>for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)<br>{<br>cout &lt;&lt; “key = “ &lt;&lt; it-&gt;first &lt;&lt; “ value = “ &lt;&lt; it-&gt;second &lt;&lt; endl;<br>}<br>cout &lt;&lt; endl;<br>}</p>\n<p>void test01()<br>{<br>//插入<br>map&lt;int, int&gt; m;<br>//第一种插入方式<br>m.insert(pair&lt;int, int&gt;(1, 10));<br>//第二种插入方式<br>m.insert(make_pair(2, 20));<br>//第三种插入方式<br>m.insert(map&lt;int, int&gt;::value_type(3, 30));<br>//第四种插入方式<br>m[4] = 40;<br>printMap(m);</p>\n<pre><code>//删除\nm.erase(m.begin());\nprintMap(m);\n\nm.erase(3);\nprintMap(m);\n\n//清空\nm.erase(m.begin(),m.end());\nm.clear();\nprintMap(m);</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>map 插入方式很多，记住其一即可<br>插入 — insert<br>删除 — erase<br>清空 — clear<br>3.9.5 map 查找和统计<br>功能描述：</p>\n<p>对 map 容器进行查找数据以及统计数据<br>函数原型：</p>\n<p>find(key); //查找 key 是否存在,若存在，返回该键的元素的迭代器；若不存在，返回 set.end();<br>count(key); //统计 key 的元素个数<br>示例：</p>\n<p>C++<br>#include <map></p>\n<p>//查找和统计<br>void test01()<br>{<br>map&lt;int, int&gt;m;<br>m.insert(pair&lt;int, int&gt;(1, 10));<br>m.insert(pair&lt;int, int&gt;(2, 20));<br>m.insert(pair&lt;int, int&gt;(3, 30));</p>\n<pre><code>//查找\nmap&lt;int, int&gt;::iterator pos = m.find(3);\n\nif (pos != m.end())\n{\n    cout &lt;&lt; &quot;找到了元素 key = &quot; &lt;&lt; (*pos).first &lt;&lt; &quot; value = &quot; &lt;&lt; (*pos).second &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;\n}\n\n//统计\nint num = m.count(3);\ncout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>查找 — find （返回的是迭代器）<br>统计 — count （对于 map，结果为 0 或者 1）<br>3.9.6 map 容器排序<br>学习目标：</p>\n<p>map 容器默认排序规则为 按照 key 值进行 从小到大排序，掌握如何改变排序规则<br>主要技术点:</p>\n<p>利用仿函数，可以改变排序规则<br>示例：</p>\n<p>C++<br>#include <map></p>\n<p>class MyCompare {<br>public:<br>bool operator()(int v1, int v2) {<br>return v1 &gt; v2;<br>}<br>};</p>\n<p>void test01()<br>{<br>//默认从小到大排序<br>//利用仿函数实现从大到小排序<br>map&lt;int, int, MyCompare&gt; m;</p>\n<pre><code>m.insert(make_pair(1, 10));\nm.insert(make_pair(2, 20));\nm.insert(make_pair(3, 30));\nm.insert(make_pair(4, 40));\nm.insert(make_pair(5, 50));\n\nfor (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) {\n    cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n}</code></pre><p>}<br>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>利用仿函数可以指定 map 容器的排序规则<br>对于自定义数据类型，map 必须要指定排序规则,同 set 容器<br>3.10 案例-员工分组<br>3.10.1 案例描述<br>公司今天招聘了 10 个员工（ABCDEFGHIJ），10 名员工进入公司之后，需要指派员工在那个部门工作<br>员工信息有: 姓名 工资组成；部门分为：策划、美术、研发<br>随机给 10 名员工分配部门和工资<br>通过 multimap 进行信息的插入 key(部门编号) value(员工)<br>分部门显示员工信息<br>3.10.2 实现步骤<br>创建 10 名员工，放到 vector 中<br>遍历 vector 容器，取出每个员工，进行随机分组<br>分组后，将员工部门编号作为 key，具体员工作为 value，放入到 multimap 容器中<br>分部门显示员工信息<br>案例代码：</p>\n<p>C++<br>#include<iostream><br>using namespace std;<br>#include <vector><br>#include <string><br>#include <map><br>#include <ctime></p>\n<p>/*</p>\n<ul>\n<li>公司今天招聘了 10 个员工（ABCDEFGHIJ），10 名员工进入公司之后，需要指派员工在那个部门工作</li>\n<li>员工信息有: 姓名 工资组成；部门分为：策划、美术、研发</li>\n<li>随机给 10 名员工分配部门和工资</li>\n<li>通过 multimap 进行信息的插入 key(部门编号) value(员工)</li>\n<li>分部门显示员工信息<br>*/</li>\n</ul>\n<p>#define CEHUA 0<br>#define MEISHU 1<br>#define YANFA 2</p>\n<p>class Worker<br>{<br>public:<br>string m_Name;<br>int m_Salary;<br>};</p>\n<p>void createWorker(vector<Worker>&amp;v)<br>{<br>string nameSeed = “ABCDEFGHIJ”;<br>for (int i = 0; i &lt; 10; i++)<br>{<br>Worker worker;<br>worker.m_Name = “员工”;<br>worker.m_Name += nameSeed[i];</p>\n<pre><code>    worker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999\n    //将员工放入到容器中\n    v.push_back(worker);\n}</code></pre><p>}</p>\n<p>//员工分组<br>void setGroup(vector<Worker>&amp;v,multimap&lt;int,Worker&gt;&amp;m)<br>{<br>for (vector<Worker>::iterator it = v.begin(); it != v.end(); it++)<br>{<br>//产生随机部门编号<br>int deptId = rand() % 3; // 0 1 2</p>\n<pre><code>    //将员工插入到分组中\n    //key部门编号，value具体员工\n    m.insert(make_pair(deptId, *it));\n}</code></pre><p>}</p>\n<p>void showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m)<br>{<br>// 0 A B C 1 D E 2 F G …<br>cout &lt;&lt; “策划部门：” &lt;&lt; endl;</p>\n<pre><code>multimap&lt;int,Worker&gt;::iterator pos = m.find(CEHUA);\nint count = m.count(CEHUA); // 统计具体人数\nint index = 0;\nfor (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++)\n{\n    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;\n}\n\ncout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;美术部门： &quot; &lt;&lt; endl;\npos = m.find(MEISHU);\ncount = m.count(MEISHU); // 统计具体人数\nindex = 0;\nfor (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)\n{\n    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;\n}\n\ncout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;研发部门： &quot; &lt;&lt; endl;\npos = m.find(YANFA);\ncount = m.count(YANFA); // 统计具体人数\nindex = 0;\nfor (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)\n{\n    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>srand((unsigned int)time(NULL));\n\n//1、创建员工\nvector&lt;Worker&gt;vWorker;\ncreateWorker(vWorker);\n\n//2、员工分组\nmultimap&lt;int, Worker&gt;mWorker;\nsetGroup(vWorker, mWorker);\n\n\n//3、分组显示员工\nshowWorkerByGourp(mWorker);\n\n////测试\n//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)\n//{\n//    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;\n//}\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>当数据以键值对形式存在，可以考虑用 map 或 multimap<br>4 STL- 函数对象<br>4.1 函数对象<br>4.1.1 函数对象概念<br>概念：</p>\n<p>重载函数调用操作符的类，其对象常称为函数对象<br>函数对象使用重载的()时，行为类似函数调用，也叫仿函数<br>本质：</p>\n<p>函数对象(仿函数)是一个类，不是一个函数</p>\n<p>4.1.2 函数对象使用<br>特点：</p>\n<p>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值<br>函数对象超出普通函数的概念，函数对象可以有自己的状态<br>函数对象可以作为参数传递<br>示例:</p>\n<p>C++<br>#include <string></p>\n<p>//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值<br>class MyAdd<br>{<br>public :<br>int operator()(int v1,int v2)<br>{<br>return v1 + v2;<br>}<br>};</p>\n<p>void test01()<br>{<br>MyAdd myAdd;<br>cout &lt;&lt; myAdd(10, 10) &lt;&lt; endl;<br>}</p>\n<p>//2、函数对象可以有自己的状态<br>class MyPrint<br>{<br>public:<br>MyPrint()<br>{<br>count = 0;<br>}<br>void operator()(string test)<br>{<br>cout &lt;&lt; test &lt;&lt; endl;<br>count++; //统计使用次数<br>}</p>\n<pre><code>int count; //内部自己的状态</code></pre><p>};<br>void test02()<br>{<br>MyPrint myPrint;<br>myPrint(“hello world”);<br>myPrint(“hello world”);<br>myPrint(“hello world”);<br>cout &lt;&lt; “myPrint 调用次数为： “ &lt;&lt; myPrint.count &lt;&lt; endl;<br>}</p>\n<p>//3、函数对象可以作为参数传递<br>void doPrint(MyPrint &amp;mp , string test)<br>{<br>mp(test);<br>}</p>\n<p>void test03()<br>{<br>MyPrint myPrint;<br>doPrint(myPrint, “Hello C++”);<br>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n//test02();\ntest03();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>仿函数写法非常灵活，可以作为参数进行传递。<br>4.2 谓词<br>4.2.1 谓词概念<br>概念：</p>\n<p>返回 bool 类型的仿函数称为谓词<br>如果 operator()接受一个参数，那么叫做一元谓词<br>如果 operator()接受两个参数，那么叫做二元谓词<br>4.2.2 一元谓词<br>示例：</p>\n<p>C++<br>#include <vector><br>#include <algorithm></p>\n<p>//1.一元谓词<br>struct GreaterFive{<br>bool operator()(int val) {<br>return val &gt; 5;<br>}<br>};</p>\n<p>void test01() {</p>\n<pre><code>vector&lt;int&gt; v;\nfor (int i = 0; i &lt; 10; i++)\n{\n    v.push_back(i);\n}\n\nvector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());\nif (it == v.end()) {\n    cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl;\n}\nelse {\n    cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：参数只有一个的谓词，称为一元谓词</p>\n<p>4.2.3 二元谓词<br>示例：</p>\n<p>C++<br>#include <vector><br>#include <algorithm><br>//二元谓词<br>class MyCompare<br>{<br>public:<br>bool operator()(int num1, int num2)<br>{<br>return num1 &gt; num2;<br>}<br>};</p>\n<p>void test01()<br>{<br>vector<int> v;<br>v.push_back(10);<br>v.push_back(40);<br>v.push_back(20);<br>v.push_back(30);<br>v.push_back(50);</p>\n<pre><code>//默认从小到大\nsort(v.begin(), v.end());\nfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)\n{\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;\ncout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;\n\n//使用函数对象改变算法策略，排序从大到小\nsort(v.begin(), v.end(), MyCompare());\nfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)\n{\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：参数只有两个的谓词，称为二元谓词</p>\n<p>4.3 内建函数对象<br>4.3.1 内建函数对象意义<br>概念：</p>\n<p>STL 内建了一些函数对象<br>分类:</p>\n<p>算术仿函数</p>\n<p>关系仿函数</p>\n<p>逻辑仿函数</p>\n<p>用法：</p>\n<p>这些仿函数所产生的对象，用法和一般函数完全相同<br>使用内建函数对象，需要引入头文件 #include<functional><br>4.3.2 算术仿函数<br>功能描述：</p>\n<p>实现四则运算<br>其中 negate 是一元运算，其他都是二元运算<br>仿函数原型：</p>\n<p>template<class T> T plus<T> //加法仿函数<br>template<class T> T minus<T> //减法仿函数<br>template<class T> T multiplies<T> //乘法仿函数<br>template<class T> T divides<T> //除法仿函数<br>template<class T> T modulus<T> //取模仿函数<br>template<class T> T negate<T> //取反仿函数<br>示例：</p>\n<p>C++<br>#include <functional><br>//negate<br>void test01()<br>{<br>negate<int> n;<br>cout &lt;&lt; n(50) &lt;&lt; endl;<br>}</p>\n<p>//plus<br>void test02()<br>{<br>plus<int> p;<br>cout &lt;&lt; p(10, 20) &lt;&lt; endl;<br>}</p>\n<p>int main() {</p>\n<pre><code>test01();\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：使用内建函数对象时，需要引入头文件 #include <functional></p>\n<p>4.3.3 关系仿函数<br>功能描述：</p>\n<p>实现关系对比<br>仿函数原型：</p>\n<p>template<class T> bool equal_to<T> //等于<br>template<class T> bool not_equal_to<T> //不等于<br>template<class T> bool greater<T> //大于<br>template<class T> bool greater_equal<T> //大于等于<br>template<class T> bool less<T> //小于<br>template<class T> bool less_equal<T> //小于等于<br>示例：</p>\n<p>C++<br>#include <functional><br>#include <vector><br>#include <algorithm></p>\n<p>class MyCompare<br>{<br>public:<br>bool operator()(int v1,int v2)<br>{<br>return v1 &gt; v2;<br>}<br>};<br>void test01()<br>{<br>vector<int> v;</p>\n<pre><code>v.push_back(10);\nv.push_back(30);\nv.push_back(50);\nv.push_back(40);\nv.push_back(20);\n\nfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;\n\n//自己实现仿函数\n//sort(v.begin(), v.end(), MyCompare());\n//STL内建仿函数  大于仿函数\nsort(v.begin(), v.end(), greater&lt;int&gt;());\n\nfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：关系仿函数中最常用的就是 greater&lt;&gt;大于</p>\n<p>4.3.4 逻辑仿函数<br>功能描述：</p>\n<p>实现逻辑运算<br>函数原型：</p>\n<p>template<class T> bool logical_and<T> //逻辑与<br>template<class T> bool logical_or<T> //逻辑或<br>template<class T> bool logical_not<T> //逻辑非<br>示例：</p>\n<p>C++<br>#include <vector><br>#include <functional><br>#include <algorithm><br>void test01()<br>{<br>vector<bool> v;<br>v.push_back(true);<br>v.push_back(false);<br>v.push_back(true);<br>v.push_back(false);</p>\n<pre><code>for (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++)\n{\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;\n\n//逻辑非  将v容器搬运到v2中，并执行逻辑非运算\nvector&lt;bool&gt; v2;\nv2.resize(v.size());\ntransform(v.begin(), v.end(),  v2.begin(), logical_not&lt;bool&gt;());\nfor (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++)\n{\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：逻辑仿函数实际应用较少，了解即可</p>\n<p>5 STL- 常用算法<br>概述:</p>\n<p>算法主要是由头文件<algorithm> <functional> <numeric>组成。<br><algorithm>是所有 STL 头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等<br><numeric>体积很小，只包括几个在序列上面进行简单数学运算的模板函数<br><functional>定义了一些模板类,用以声明函数对象。<br>5.1 常用遍历算法<br>学习目标：</p>\n<p>掌握常用的遍历算法<br>算法简介：</p>\n<p>for_each //遍历容器<br>transform //搬运容器到另一个容器中<br>5.1.1 for_each<br>功能描述：</p>\n<p>实现遍历容器<br>函数原型：</p>\n<p>for_each(iterator beg, iterator end, _func);</p>\n<p>// 遍历算法 遍历容器元素</p>\n<p>// beg 开始迭代器</p>\n<p>// end 结束迭代器</p>\n<p>// _func 函数或者函数对象</p>\n<p>示例：</p>\n<p>C++<br>#include <algorithm><br>#include <vector></p>\n<p>//普通函数<br>void print01(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>//函数对象<br>class print02<br>{<br>public:<br>void operator()(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>};</p>\n<p>//for_each 算法基本用法<br>void test01() {</p>\n<pre><code>vector&lt;int&gt; v;\nfor (int i = 0; i &lt; 10; i++)\n{\n    v.push_back(i);\n}\n\n//遍历算法\nfor_each(v.begin(), v.end(), print01);\ncout &lt;&lt; endl;\n\nfor_each(v.begin(), v.end(), print02());\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：for_each 在实际开发中是最常用遍历算法，需要熟练掌握</p>\n<p>5.1.2 transform<br>功能描述：</p>\n<p>搬运容器到另一个容器中<br>函数原型：</p>\n<p>transform(iterator beg1, iterator end1, iterator beg2, _func);<br>//beg1 源容器开始迭代器</p>\n<p>//end1 源容器结束迭代器</p>\n<p>//beg2 目标容器开始迭代器</p>\n<p>//_func 函数或者函数对象</p>\n<p>示例：</p>\n<p>C++<br>#include<vector><br>#include<algorithm></p>\n<p>//常用遍历算法 搬运 transform</p>\n<p>class TransForm<br>{<br>public:<br>int operator()(int val)<br>{<br>return val;<br>}</p>\n<p>};</p>\n<p>class MyPrint<br>{<br>public:<br>void operator()(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>};</p>\n<p>void test01()<br>{<br>vector<int>v;<br>for (int i = 0; i &lt; 10; i++)<br>{<br>v.push_back(i);<br>}</p>\n<pre><code>vector&lt;int&gt;vTarget; //目标容器\n\nvTarget.resize(v.size()); // 目标容器需要提前开辟空间\n\ntransform(v.begin(), v.end(), vTarget.begin(), TransForm());\n\nfor_each(vTarget.begin(), vTarget.end(), MyPrint());</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>\n<p>5.2 常用查找算法<br>学习目标：</p>\n<p>掌握常用的查找算法<br>算法简介：</p>\n<p>find //查找元素<br>find_if //按条件查找元素<br>adjacent_find //查找相邻重复元素<br>binary_search //二分查找法<br>count //统计元素个数<br>count_if //按条件统计元素个数<br>5.2.1 find<br>功能描述：</p>\n<p>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器 end()<br>函数原型：</p>\n<p>find(iterator beg, iterator end, value);</p>\n<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>\n<p>// beg 开始迭代器</p>\n<p>// end 结束迭代器</p>\n<p>// value 查找的元素</p>\n<p>示例：</p>\n<p>C++<br>#include <algorithm><br>#include <vector><br>#include <string><br>void test01() {</p>\n<pre><code>vector&lt;int&gt; v;\nfor (int i = 0; i &lt; 10; i++) {\n    v.push_back(i + 1);\n}\n//查找容器中是否有 5 这个元素\nvector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5);\nif (it == v.end())\n{\n    cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>class Person {<br>public:<br>Person(string name, int age)<br>{<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>}<br>//重载==<br>bool operator==(const Person&amp; p)<br>{<br>if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)<br>{<br>return true;<br>}<br>return false;<br>}</p>\n<p>public:<br>string m_Name;<br>int m_Age;<br>};</p>\n<p>void test02() {</p>\n<pre><code>vector&lt;Person&gt; v;\n\n//创建数据\nPerson p1(&quot;aaa&quot;, 10);\nPerson p2(&quot;bbb&quot;, 20);\nPerson p3(&quot;ccc&quot;, 30);\nPerson p4(&quot;ddd&quot;, 40);\n\nv.push_back(p1);\nv.push_back(p2);\nv.push_back(p3);\nv.push_back(p4);\n\nvector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);\nif (it == v.end())\n{\n    cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;\n}</code></pre><p>}<br>总结： 利用 find 可以在容器中找指定的元素，返回值是迭代器</p>\n<p>5.2.2 find_if<br>功能描述：</p>\n<p>按条件查找元素<br>函数原型：</p>\n<p>find_if(iterator beg, iterator end, _Pred);</p>\n<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>\n<p>// beg 开始迭代器</p>\n<p>// end 结束迭代器</p>\n<p>// _Pred 函数或者谓词（返回 bool 类型的仿函数）</p>\n<p>示例：</p>\n<p>C++<br>#include <algorithm><br>#include <vector><br>#include <string></p>\n<p>//内置数据类型<br>class GreaterFive<br>{<br>public:<br>bool operator()(int val)<br>{<br>return val &gt; 5;<br>}<br>};</p>\n<p>void test01() {</p>\n<pre><code>vector&lt;int&gt; v;\nfor (int i = 0; i &lt; 10; i++) {\n    v.push_back(i + 1);\n}\n\nvector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());\nif (it == v.end()) {\n    cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\n}\nelse {\n    cout &lt;&lt; &quot;找到大于5的数字:&quot; &lt;&lt; *it &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>//自定义数据类型<br>class Person {<br>public:<br>Person(string name, int age)<br>{<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>}<br>public:<br>string m_Name;<br>int m_Age;<br>};</p>\n<p>class Greater20<br>{<br>public:<br>bool operator()(Person &amp;p)<br>{<br>return p.m_Age &gt; 20;<br>}</p>\n<p>};</p>\n<p>void test02() {</p>\n<pre><code>vector&lt;Person&gt; v;\n\n//创建数据\nPerson p1(&quot;aaa&quot;, 10);\nPerson p2(&quot;bbb&quot;, 20);\nPerson p3(&quot;ccc&quot;, 30);\nPerson p4(&quot;ddd&quot;, 40);\n\nv.push_back(p1);\nv.push_back(p2);\nv.push_back(p3);\nv.push_back(p4);\n\nvector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20());\nif (it == v.end())\n{\n    cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：find_if 按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p>\n<p>5.2.3 adjacent_find<br>功能描述：</p>\n<p>查找相邻重复元素<br>函数原型：</p>\n<p>adjacent_find(iterator beg, iterator end);</p>\n<p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p>\n<p>// beg 开始迭代器</p>\n<p>// end 结束迭代器</p>\n<p>示例：</p>\n<p>C++<br>#include <algorithm><br>#include <vector></p>\n<p>void test01()<br>{<br>vector<int> v;<br>v.push_back(1);<br>v.push_back(2);<br>v.push_back(5);<br>v.push_back(2);<br>v.push_back(4);<br>v.push_back(4);<br>v.push_back(3);</p>\n<pre><code>//查找相邻重复元素\nvector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end());\nif (it == v.end()) {\n    cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl;\n}\nelse {\n    cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl;\n}</code></pre><p>}<br>总结：面试题中如果出现查找相邻重复元素，记得用 STL 中的 adjacent_find 算法</p>\n<p>5.2.4 binary_search<br>功能描述：</p>\n<p>查找指定元素是否存在<br>函数原型：</p>\n<p>bool binary_search(iterator beg, iterator end, value);</p>\n<p>// 查找指定的元素，查到 返回 true 否则 false</p>\n<p>// 注意: 在无序序列中不可用</p>\n<p>// beg 开始迭代器</p>\n<p>// end 结束迭代器</p>\n<p>// value 查找的元素</p>\n<p>示例：</p>\n<p>C++<br>#include <algorithm><br>#include <vector></p>\n<p>void test01()<br>{<br>vector<int>v;</p>\n<pre><code>for (int i = 0; i &lt; 10; i++)\n{\n    v.push_back(i);\n}\n//二分查找\nbool ret = binary_search(v.begin(), v.end(),2);\nif (ret)\n{\n    cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl;\n}\nelse\n{\n    cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;\n}</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p>\n<p>5.2.5 count<br>功能描述：</p>\n<p>统计元素个数<br>函数原型：</p>\n<p>count(iterator beg, iterator end, value);</p>\n<p>// 统计元素出现次数</p>\n<p>// beg 开始迭代器</p>\n<p>// end 结束迭代器</p>\n<p>// value 统计的元素</p>\n<p>示例：</p>\n<p>C++<br>#include <algorithm><br>#include <vector></p>\n<p>//内置数据类型<br>void test01()<br>{<br>vector<int> v;<br>v.push_back(1);<br>v.push_back(2);<br>v.push_back(4);<br>v.push_back(5);<br>v.push_back(3);<br>v.push_back(4);<br>v.push_back(4);</p>\n<pre><code>int num = count(v.begin(), v.end(), 4);\n\ncout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;</code></pre><p>}</p>\n<p>//自定义数据类型<br>class Person<br>{<br>public:<br>Person(string name, int age)<br>{<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>}<br>bool operator==(const Person &amp; p)<br>{<br>if (this-&gt;m_Age == p.m_Age)<br>{<br>return true;<br>}<br>else<br>{<br>return false;<br>}<br>}<br>string m_Name;<br>int m_Age;<br>};</p>\n<p>void test02()<br>{<br>vector<Person> v;</p>\n<pre><code>Person p1(&quot;刘备&quot;, 35);\nPerson p2(&quot;关羽&quot;, 35);\nPerson p3(&quot;张飞&quot;, 35);\nPerson p4(&quot;赵云&quot;, 30);\nPerson p5(&quot;曹操&quot;, 25);\n\nv.push_back(p1);\nv.push_back(p2);\nv.push_back(p3);\nv.push_back(p4);\nv.push_back(p5);\n\nPerson p(&quot;诸葛亮&quot;,35);\n\nint num = count(v.begin(), v.end(), p);\ncout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;</code></pre><p>}<br>int main() {</p>\n<pre><code>//test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结： 统计自定义数据类型时候，需要配合重载 operator==</p>\n<p>5.2.6 count_if<br>功能描述：</p>\n<p>按条件统计元素个数<br>函数原型：</p>\n<p>count_if(iterator beg, iterator end, _Pred);</p>\n<p>// 按条件统计元素出现次数</p>\n<p>// beg 开始迭代器</p>\n<p>// end 结束迭代器</p>\n<p>// _Pred 谓词</p>\n<p>示例：</p>\n<p>C++<br>#include <algorithm><br>#include <vector></p>\n<p>class Greater4<br>{<br>public:<br>bool operator()(int val)<br>{<br>return val &gt;= 4;<br>}<br>};</p>\n<p>//内置数据类型<br>void test01()<br>{<br>vector<int> v;<br>v.push_back(1);<br>v.push_back(2);<br>v.push_back(4);<br>v.push_back(5);<br>v.push_back(3);<br>v.push_back(4);<br>v.push_back(4);</p>\n<pre><code>int num = count_if(v.begin(), v.end(), Greater4());\n\ncout &lt;&lt; &quot;大于4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;</code></pre><p>}</p>\n<p>//自定义数据类型<br>class Person<br>{<br>public:<br>Person(string name, int age)<br>{<br>this-&gt;m_Name = name;<br>this-&gt;m_Age = age;<br>}</p>\n<pre><code>string m_Name;\nint m_Age;</code></pre><p>};</p>\n<p>class AgeLess35<br>{<br>public:<br>bool operator()(const Person &amp;p)<br>{<br>return p.m_Age &lt; 35;<br>}<br>};<br>void test02()<br>{<br>vector<Person> v;</p>\n<pre><code>Person p1(&quot;刘备&quot;, 35);\nPerson p2(&quot;关羽&quot;, 35);\nPerson p3(&quot;张飞&quot;, 35);\nPerson p4(&quot;赵云&quot;, 30);\nPerson p5(&quot;曹操&quot;, 25);\n\nv.push_back(p1);\nv.push_back(p2);\nv.push_back(p3);\nv.push_back(p4);\nv.push_back(p5);\n\nint num = count_if(v.begin(), v.end(), AgeLess35());\ncout &lt;&lt; &quot;小于35岁的个数：&quot; &lt;&lt; num &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>//test01();\n\ntest02();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：按值统计用 count，按条件统计用 count_if</p>\n<p>5.3 常用排序算法<br>学习目标：</p>\n<p>掌握常用的排序算法<br>算法简介：</p>\n<p>sort //对容器内元素进行排序<br>random_shuffle //洗牌 指定范围内的元素随机调整次序<br>merge // 容器元素合并，并存储到另一容器中<br>reverse // 反转指定范围的元素<br>5.3.1 sort<br>功能描述：</p>\n<p>对容器内元素进行排序<br>函数原型：</p>\n<p>sort(iterator beg, iterator end, _Pred);</p>\n<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>\n<p>// beg 开始迭代器</p>\n<p>// end 结束迭代器</p>\n<p>// _Pred 谓词</p>\n<p>示例：</p>\n<p>C++<br>#include <algorithm><br>#include <vector></p>\n<p>void myPrint(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}</p>\n<p>void test01() {<br>vector<int> v;<br>v.push_back(10);<br>v.push_back(30);<br>v.push_back(50);<br>v.push_back(20);<br>v.push_back(40);</p>\n<pre><code>//sort默认从小到大排序\nsort(v.begin(), v.end());\nfor_each(v.begin(), v.end(), myPrint);\ncout &lt;&lt; endl;\n\n//从大到小排序\nsort(v.begin(), v.end(), greater&lt;int&gt;());\nfor_each(v.begin(), v.end(), myPrint);\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：sort 属于开发中最常用的算法之一，需熟练掌握</p>\n<p>5.3.2 random_shuffle<br>功能描述：</p>\n<p>洗牌 指定范围内的元素随机调整次序<br>函数原型：</p>\n<p>random_shuffle(iterator beg, iterator end);</p>\n<p>// 指定范围内的元素随机调整次序</p>\n<p>// beg 开始迭代器</p>\n<p>// end 结束迭代器</p>\n<p>示例：</p>\n<p>C++<br>#include <algorithm><br>#include <vector><br>#include <ctime></p>\n<p>class myPrint<br>{<br>public:<br>void operator()(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>};</p>\n<p>void test01()<br>{<br>srand((unsigned int)time(NULL));<br>vector<int> v;<br>for(int i = 0 ; i &lt; 10;i++)<br>{<br>v.push_back(i);<br>}<br>for_each(v.begin(), v.end(), myPrint());<br>cout &lt;&lt; endl;</p>\n<pre><code>//打乱顺序\nrandom_shuffle(v.begin(), v.end());\nfor_each(v.begin(), v.end(), myPrint());\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：random_shuffle 洗牌算法比较实用，使用时记得加随机数种子</p>\n<p>5.3.3 merge<br>功能描述：</p>\n<p>两个容器元素合并，并存储到另一容器中<br>函数原型：</p>\n<p>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</p>\n<p>// 容器元素合并，并存储到另一容器中</p>\n<p>// 注意: 两个容器必须是有序的</p>\n<p>// beg1 容器 1 开始迭代器<br>// end1 容器 1 结束迭代器<br>// beg2 容器 2 开始迭代器<br>// end2 容器 2 结束迭代器<br>// dest 目标容器开始迭代器</p>\n<p>示例：</p>\n<p>C++<br>#include <algorithm><br>#include <vector></p>\n<p>class myPrint<br>{<br>public:<br>void operator()(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>};</p>\n<p>void test01()<br>{<br>vector<int> v1;<br>vector<int> v2;<br>for (int i = 0; i &lt; 10 ; i++)<br>{<br>v1.push_back(i);<br>v2.push_back(i + 1);<br>}</p>\n<pre><code>vector&lt;int&gt; vtarget;\n//目标容器需要提前开辟空间\nvtarget.resize(v1.size() + v2.size());\n//合并  需要两个有序序列\nmerge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());\nfor_each(vtarget.begin(), vtarget.end(), myPrint());\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：merge 合并的两个容器必须的有序序列</p>\n<p>5.3.4 reverse<br>功能描述：</p>\n<p>将容器内元素进行反转<br>函数原型：</p>\n<p>reverse(iterator beg, iterator end);</p>\n<p>// 反转指定范围的元素</p>\n<p>// beg 开始迭代器</p>\n<p>// end 结束迭代器</p>\n<p>示例：</p>\n<p>C++<br>#include <algorithm><br>#include <vector></p>\n<p>class myPrint<br>{<br>public:<br>void operator()(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>};</p>\n<p>void test01()<br>{<br>vector<int> v;<br>v.push_back(10);<br>v.push_back(30);<br>v.push_back(50);<br>v.push_back(20);<br>v.push_back(40);</p>\n<pre><code>cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl;\nfor_each(v.begin(), v.end(), myPrint());\ncout &lt;&lt; endl;\n\ncout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl;\n\nreverse(v.begin(), v.end());\nfor_each(v.begin(), v.end(), myPrint());\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：reverse 反转区间内元素，面试题可能涉及到</p>\n<p>5.4 常用拷贝和替换算法<br>学习目标：</p>\n<p>掌握常用的拷贝和替换算法<br>算法简介：</p>\n<p>copy // 容器内指定范围的元素拷贝到另一容器中<br>replace // 将容器内指定范围的旧元素修改为新元素<br>replace_if // 容器内指定范围满足条件的元素替换为新元素<br>swap // 互换两个容器的元素<br>5.4.1 copy<br>功能描述：</p>\n<p>容器内指定范围的元素拷贝到另一容器中<br>函数原型：</p>\n<p>copy(iterator beg, iterator end, iterator dest);</p>\n<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>\n<p>// beg 开始迭代器</p>\n<p>// end 结束迭代器</p>\n<p>// dest 目标起始迭代器</p>\n<p>示例：</p>\n<p>C++<br>#include <algorithm><br>#include <vector></p>\n<p>class myPrint<br>{<br>public:<br>void operator()(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>};</p>\n<p>void test01()<br>{<br>vector<int> v1;<br>for (int i = 0; i &lt; 10; i++) {<br>v1.push_back(i + 1);<br>}<br>vector<int> v2;<br>v2.resize(v1.size());<br>copy(v1.begin(), v1.end(), v2.begin());</p>\n<pre><code>for_each(v2.begin(), v2.end(), myPrint());\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：利用 copy 算法在拷贝时，目标容器记得提前开辟空间</p>\n<p>5.4.2 replace<br>功能描述：</p>\n<p>将容器内指定范围的旧元素修改为新元素<br>函数原型：</p>\n<p>replace(iterator beg, iterator end, oldvalue, newvalue);</p>\n<p>// 将区间内旧元素 替换成 新元素</p>\n<p>// beg 开始迭代器</p>\n<p>// end 结束迭代器</p>\n<p>// oldvalue 旧元素</p>\n<p>// newvalue 新元素</p>\n<p>示例：</p>\n<p>C++<br>#include <algorithm><br>#include <vector></p>\n<p>class myPrint<br>{<br>public:<br>void operator()(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>};</p>\n<p>void test01()<br>{<br>vector<int> v;<br>v.push_back(20);<br>v.push_back(30);<br>v.push_back(20);<br>v.push_back(40);<br>v.push_back(50);<br>v.push_back(10);<br>v.push_back(20);</p>\n<pre><code>cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;\nfor_each(v.begin(), v.end(), myPrint());\ncout &lt;&lt; endl;\n\n//将容器中的20 替换成 2000\ncout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;\nreplace(v.begin(), v.end(), 20,2000);\nfor_each(v.begin(), v.end(), myPrint());\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：replace 会替换区间内满足条件的元素</p>\n<p>5.4.3 replace_if<br>功能描述:</p>\n<p>将区间内满足条件的元素，替换成指定元素<br>函数原型：</p>\n<p>replace_if(iterator beg, iterator end, _pred, newvalue);</p>\n<p>// 按条件替换元素，满足条件的替换成指定元素</p>\n<p>// beg 开始迭代器</p>\n<p>// end 结束迭代器</p>\n<p>// _pred 谓词</p>\n<p>// newvalue 替换的新元素</p>\n<p>示例：</p>\n<p>C++<br>#include <algorithm><br>#include <vector></p>\n<p>class myPrint<br>{<br>public:<br>void operator()(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>};</p>\n<p>class ReplaceGreater30<br>{<br>public:<br>bool operator()(int val)<br>{<br>return val &gt;= 30;<br>}</p>\n<p>};</p>\n<p>void test01()<br>{<br>vector<int> v;<br>v.push_back(20);<br>v.push_back(30);<br>v.push_back(20);<br>v.push_back(40);<br>v.push_back(50);<br>v.push_back(10);<br>v.push_back(20);</p>\n<pre><code>cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;\nfor_each(v.begin(), v.end(), myPrint());\ncout &lt;&lt; endl;\n\n//将容器中大于等于的30 替换成 3000\ncout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;\nreplace_if(v.begin(), v.end(), ReplaceGreater30(), 3000);\nfor_each(v.begin(), v.end(), myPrint());\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：replace_if 按条件查找，可以利用仿函数灵活筛选满足的条件</p>\n<p>5.4.4 swap<br>功能描述：</p>\n<p>互换两个容器的元素<br>函数原型：</p>\n<p>swap(container c1, container c2);</p>\n<p>// 互换两个容器的元素</p>\n<p>// c1 容器 1</p>\n<p>// c2 容器 2</p>\n<p>示例：</p>\n<p>C++<br>#include <algorithm><br>#include <vector></p>\n<p>class myPrint<br>{<br>public:<br>void operator()(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>};</p>\n<p>void test01()<br>{<br>vector<int> v1;<br>vector<int> v2;<br>for (int i = 0; i &lt; 10; i++) {<br>v1.push_back(i);<br>v2.push_back(i+100);<br>}</p>\n<pre><code>cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;\nfor_each(v1.begin(), v1.end(), myPrint());\ncout &lt;&lt; endl;\nfor_each(v2.begin(), v2.end(), myPrint());\ncout &lt;&lt; endl;\n\ncout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;\nswap(v1, v2);\nfor_each(v1.begin(), v1.end(), myPrint());\ncout &lt;&lt; endl;\nfor_each(v2.begin(), v2.end(), myPrint());\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：swap 交换容器时，注意交换的容器要同种类型</p>\n<p>5.5 常用算术生成算法<br>学习目标：</p>\n<p>掌握常用的算术生成算法<br>注意：</p>\n<p>算术生成算法属于小型算法，使用时包含的头文件为 #include <numeric><br>算法简介：</p>\n<p>accumulate // 计算容器元素累计总和</p>\n<p>fill // 向容器中添加元素</p>\n<p>5.5.1 accumulate<br>功能描述：</p>\n<p>计算区间内 容器元素累计总和<br>函数原型：</p>\n<p>accumulate(iterator beg, iterator end, value);</p>\n<p>// 计算容器元素累计总和</p>\n<p>// beg 开始迭代器</p>\n<p>// end 结束迭代器</p>\n<p>// value 起始值</p>\n<p>示例：</p>\n<p>C++<br>#include <numeric><br>#include <vector><br>void test01()<br>{<br>vector<int> v;<br>for (int i = 0; i &lt;= 100; i++) {<br>v.push_back(i);<br>}</p>\n<pre><code>int total = accumulate(v.begin(), v.end(), 0);\n\ncout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：accumulate 使用时头文件注意是 numeric，这个算法很实用</p>\n<p>5.5.2 fill<br>功能描述：</p>\n<p>向容器中填充指定的元素<br>函数原型：</p>\n<p>fill(iterator beg, iterator end, value);</p>\n<p>// 向容器中填充元素</p>\n<p>// beg 开始迭代器</p>\n<p>// end 结束迭代器</p>\n<p>// value 填充的值</p>\n<p>示例：</p>\n<p>C++<br>#include <numeric><br>#include <vector><br>#include <algorithm></p>\n<p>class myPrint<br>{<br>public:<br>void operator()(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>};</p>\n<p>void test01()<br>{</p>\n<pre><code>vector&lt;int&gt; v;\nv.resize(10);\n//填充\nfill(v.begin(), v.end(), 100);\n\nfor_each(v.begin(), v.end(), myPrint());\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：利用 fill 可以将容器区间内元素填充为 指定的值</p>\n<p>5.6 常用集合算法<br>学习目标：</p>\n<p>掌握常用的集合算法<br>算法简介：</p>\n<p>set_intersection // 求两个容器的交集</p>\n<p>set_union // 求两个容器的并集</p>\n<p>set_difference // 求两个容器的差集</p>\n<p>5.6.1 set_intersection<br>功能描述：</p>\n<p>求两个容器的交集<br>函数原型：</p>\n<p>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</p>\n<p>// 求两个集合的交集</p>\n<p>// 注意:两个集合必须是有序序列</p>\n<p>// beg1 容器 1 开始迭代器<br>// end1 容器 1 结束迭代器<br>// beg2 容器 2 开始迭代器<br>// end2 容器 2 结束迭代器<br>// dest 目标容器开始迭代器</p>\n<p>示例：</p>\n<p>C++<br>#include <vector><br>#include <algorithm></p>\n<p>class myPrint<br>{<br>public:<br>void operator()(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>};</p>\n<p>void test01()<br>{<br>vector<int> v1;<br>vector<int> v2;<br>for (int i = 0; i &lt; 10; i++)<br>{<br>v1.push_back(i);<br>v2.push_back(i+5);<br>}</p>\n<pre><code>vector&lt;int&gt; vTarget;\n//取两个里面较小的值给目标容器开辟空间\nvTarget.resize(min(v1.size(), v2.size()));\n\n//返回目标容器的最后一个元素的迭代器地址\nvector&lt;int&gt;::iterator itEnd =\n    set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());\n\nfor_each(vTarget.begin(), itEnd, myPrint());\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>求交集的两个集合必须的有序序列<br>目标容器开辟空间需要从两个容器中取小值<br>set_intersection 返回值既是交集中最后一个元素的位置<br>5.6.2 set_union<br>功能描述：</p>\n<p>求两个集合的并集<br>函数原型：</p>\n<p>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</p>\n<p>// 求两个集合的并集</p>\n<p>// 注意:两个集合必须是有序序列</p>\n<p>// beg1 容器 1 开始迭代器<br>// end1 容器 1 结束迭代器<br>// beg2 容器 2 开始迭代器<br>// end2 容器 2 结束迭代器<br>// dest 目标容器开始迭代器</p>\n<p>示例：</p>\n<p>C++<br>#include <vector><br>#include <algorithm></p>\n<p>class myPrint<br>{<br>public:<br>void operator()(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>};</p>\n<p>void test01()<br>{<br>vector<int> v1;<br>vector<int> v2;<br>for (int i = 0; i &lt; 10; i++) {<br>v1.push_back(i);<br>v2.push_back(i+5);<br>}</p>\n<pre><code>vector&lt;int&gt; vTarget;\n//取两个容器的和给目标容器开辟空间\nvTarget.resize(v1.size() + v2.size());\n\n//返回目标容器的最后一个元素的迭代器地址\nvector&lt;int&gt;::iterator itEnd =\n    set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());\n\nfor_each(vTarget.begin(), itEnd, myPrint());\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>求并集的两个集合必须的有序序列<br>目标容器开辟空间需要两个容器相加<br>set_union 返回值既是并集中最后一个元素的位置<br>5.6.3 set_difference<br>功能描述：</p>\n<p>求两个集合的差集<br>函数原型：</p>\n<p>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</p>\n<p>// 求两个集合的差集</p>\n<p>// 注意:两个集合必须是有序序列</p>\n<p>// beg1 容器 1 开始迭代器<br>// end1 容器 1 结束迭代器<br>// beg2 容器 2 开始迭代器<br>// end2 容器 2 结束迭代器<br>// dest 目标容器开始迭代器</p>\n<p>示例：</p>\n<p>C++<br>#include <vector><br>#include <algorithm></p>\n<p>class myPrint<br>{<br>public:<br>void operator()(int val)<br>{<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>};</p>\n<p>void test01()<br>{<br>vector<int> v1;<br>vector<int> v2;<br>for (int i = 0; i &lt; 10; i++) {<br>v1.push_back(i);<br>v2.push_back(i+5);<br>}</p>\n<pre><code>vector&lt;int&gt; vTarget;\n//取两个里面较大的值给目标容器开辟空间\nvTarget.resize( max(v1.size() , v2.size()));\n\n//返回目标容器的最后一个元素的迭代器地址\ncout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl;\nvector&lt;int&gt;::iterator itEnd =\n    set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());\nfor_each(vTarget.begin(), itEnd, myPrint());\ncout &lt;&lt; endl;\n\n\ncout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl;\nitEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());\nfor_each(vTarget.begin(), itEnd, myPrint());\ncout &lt;&lt; endl;</code></pre><p>}</p>\n<p>int main() {</p>\n<pre><code>test01();\n\nsystem(&quot;pause&quot;);\n\nreturn 0;</code></pre><p>}<br>总结：</p>\n<p>求差集的两个集合必须的有序序列<br>目标容器开辟空间需要从两个容器取较大值<br>set_difference 返回值既是差集中最后一个元素的位置</p>\n"},{"title":"Wolfram Alpha 算微积分指令集合","url":"/2020/06/29/Wolfram-Alpha-%E7%AE%97%E5%BE%AE%E7%A7%AF%E5%88%86%E6%8C%87%E4%BB%A4%E9%9B%86%E5%90%88/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\css\\APlayer.min.css\"><script src=\"\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\js\\Meting.min.js\"></script><h1 id=\"一、Wolfram-Alpha介绍\"><a href=\"#一、Wolfram-Alpha介绍\" class=\"headerlink\" title=\"一、Wolfram Alpha介绍\"></a>一、Wolfram Alpha介绍</h1><p>Wolfram Alpha网址：<a href=\"https://www.wolframalpha.com/\" target=\"_blank\" rel=\"noopener\">https://www.wolframalpha.com/</a></p>\n<p>WolframAlpha是开发计算数学应用软件的沃尔夫勒姆研究公司开发出的新一代的搜索引擎，能根据问题直接给出答案的网站，用户在搜索框键入需要查询的问题后，该搜索引擎将直接向用户返回答案。</p>\n<p>它是基于 Wolfram 早期旗舰产品 <a href=\"https://baike.baidu.com/item/Mathematica\" target=\"_blank\" rel=\"noopener\">Mathematica</a>，一款囊括了计算机代数、符号和数值计算、可视化和统计功能的计算平台和工具包开发的。其数据来源包括学术网站和出版物、商业网站和公司、科学机构等等。</p>\n<h1 id=\"二、计算微积分（图片版）\"><a href=\"#二、计算微积分（图片版）\" class=\"headerlink\" title=\"二、计算微积分（图片版）\"></a>二、计算微积分（图片版）</h1><p>那么怎么使用Wolfram Alpha来计算微积分呢？</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/06/29/iRwNft9jPGu3Yna.gif\" alt=\"\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/06/29/QKNiA9V4lF5ehjH.gif\" alt=\"view_1_DGFPSw0wdoOatkCLh_ffwwmdwdHiFZTi3DpqnHqkJf0=\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/06/29/U2xfBstVX7YnMzJ.gif\" alt=\"wKh2ClzcsvWAdBmEAAEWkzPRifs071\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://i.loli.net/2020/07/23/bOAtU8WTQGYXvxE.png\" alt=\"image008\"></p>\n<p>说明： 点击公式进入WolframAlpha网页，然后将其中的函数换成需要计算函数即可。</p>\n<p><a href=\"http://www.wolfram.com/\" target=\"_blank\" rel=\"noopener\">http://www.wolfram.com/</a></p>\n<h1 id=\"三、计算微积分（表格版）\"><a href=\"#三、计算微积分（表格版）\" class=\"headerlink\" title=\"三、计算微积分（表格版）\"></a>三、计算微积分（表格版）</h1><table>\n<thead>\n<tr>\n<th><strong>求极限</strong></th>\n<th><a href=\"http://www.wolframalpha.com/input/?i=+lim+sin2x%2F(e^x-1)%2C+x->0\" target=\"_blank\" rel=\"noopener\">lim sin2x/(e^x-1), x-&gt;0</a></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=lim+arctan(1%2Fx)+as+x->0%2B\" target=\"_blank\" rel=\"noopener\">lim arctan(1/x) as x-&gt;0+</a>   <a href=\"http://www.wolframalpha.com/input/?i=+lim+exp(1%2Fx)+as+x->0-\" target=\"_blank\" rel=\"noopener\">lim exp(1/x) as x-&gt;0-</a></td>\n<td>单侧极限</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=lim+x^2sin(3%2Fx^2)\" target=\"_blank\" rel=\"noopener\">lim x^2sin(3/x^2)) , x-&gt;oo</a>+%2C+x-&gt;oo)   <a href=\"http://www.wolframalpha.com/input/?i=lim+arctan(x)%2C+x->-oo\" target=\"_blank\" rel=\"noopener\">lim arctan(x), x-&gt;-oo</a></td>\n<td>x 趋于无穷大：oo</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>求导数</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=derivative+of+(2x^2%2B3)sin(x)\" target=\"_blank\" rel=\"noopener\">derivative of (2x^2+3)sin(x)</a>   或  <a href=\"http://www.wolframalpha.com/input/?i=derivative+(2x^2%2B3)sin(x)\" target=\"_blank\" rel=\"noopener\">derivative (2x^2+3)sin(x)</a></td>\n<td>导数：derivative</td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=d%2Fdx+(2x^2%2B3)sin(x)\" target=\"_blank\" rel=\"noopener\">d/dx (2x^2+3)sin(x)</a></td>\n<td>分式记号</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=((2x^2%2B3)sin(x))’\" target=\"_blank\" rel=\"noopener\">((2x^2+3)sin(x))’</a></td>\n<td>撇记号，最简单</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=derivative+of+(2x^2%2B3)sin(x)+at+x%3D3\" target=\"_blank\" rel=\"noopener\">derivative of (2x^2+3)sin(x) at x=3</a></td>\n<td>求一点的导数</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=d%2Fdx+(2x^2%2B3)sin(x)+at+x%3D3\" target=\"_blank\" rel=\"noopener\">d/dx (2x^2+3)sin(x) at x=3</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=((2x^2%2B3)sin(x))' target=\"_blank\" rel=\"noopener\"+at+x%3D3\">((2x^2+3)sin(x))’ at x=3</a></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>二阶导数</strong></th>\n<th><a href=\"http://www.wolframalpha.com/input/?i=second+derivative+of+sin(2x^2%2B3)\" target=\"_blank\" rel=\"noopener\">second derivative of sin(2x^2+3)</a></th>\n<th>二阶导数：second derivative</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=2nd+derivative+sin(2x^2%2B3)\" target=\"_blank\" rel=\"noopener\">2nd derivative sin(2x^2+3)</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=(sin(2x^2%2B3))' target=\"_blank\" rel=\"noopener\"'\">(sin(2x^2+3))’’</a></td>\n<td>撇记号，最简单：打两撇</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>三阶导数</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=(sin(2x^2%2B3))' target=\"_blank\" rel=\"noopener\"''\">(sin(2x^2+3))’’’</a></td>\n<td>撇记号，最简单：打三撇</td>\n</tr>\n<tr>\n<td><strong>10阶导数</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=10th+derivative+1%2F(1%2Bx)\" target=\"_blank\" rel=\"noopener\">10th derivative 1/(1+x)</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=d^10%2Fdx^10(1%2F(1%2Bx))\" target=\"_blank\" rel=\"noopener\">d^10/dx^10(1/(1+x))</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=(exp(x)cos(2x^2))' target=\"_blank\" rel=\"noopener\"'+at+x%3D1\">(exp(x)cos(2x^2))’’ at x=1</a></td>\n<td>x=1处的2阶导数</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=7th+derivative+of+1%2F(1%2Bx)+at+0\" target=\"_blank\" rel=\"noopener\">7th derivative of 1/(1+x) at 0</a></td>\n<td>0处的7阶导数</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>参数方程的导数</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=+(sin(t))' target=\"_blank\" rel=\"noopener\"%2F(2t^2)'\">(sin(t))’/(2t^2)’</a></td>\n<td>x=2t^2, y=sint 的导数：dy/dx</td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=(cost)' target=\"_blank\" rel=\"noopener\"%2F(sin2t)'+at+t%3Dpi%2F6\">(cost)’/(sin2t)’ at t=pi/6</a></td>\n<td>x=sin2t, y=cost 在 t=pi/6 处的导数</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>隐函数的导数</strong></th>\n<th><a href=\"http://www.wolframalpha.com/input/?i=-(+d%2Fdx(+1-x*exp(y)-y+)+)%2F(+d%2Fdy(+1-x*exp(y)-y+)+)\" target=\"_blank\" rel=\"noopener\">-( d/dx( 1-x<em>exp(y)-y ) )/( d/dy( 1-x</em>exp(y)-y ) )</a></th>\n<th>方程 y=1-xe^y 的导数:dy/dx</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>求方程的根</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=solve+x^3%2B1.1*x^2%2B0.9*x-1.4%3D0\" target=\"_blank\" rel=\"noopener\">solve x^3+1.1<em>x^2+0.9</em>x-1.4=0</a></td>\n<td>解方程求根（包括复根）</td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=real+root+x^3%2B1.1*x^2%2B0.9*x-1.4%3D0\" target=\"_blank\" rel=\"noopener\">real root x^3+1.1<em>x^2+0.9</em>x-1.4=0</a></td>\n<td>只求实根(real root)</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>求函数的驻点</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=stationary+point+of+x^3-2x%2B3\" target=\"_blank\" rel=\"noopener\">stationary point of x^3-2x+3</a></td>\n<td>驻点：stationary point</td>\n</tr>\n<tr>\n<td><strong>求函数的极值</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=local+min+x%2F(x^2%2B2)\" target=\"_blank\" rel=\"noopener\">local min x/(x^2+2)</a></td>\n<td>极小值：local min</td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=local+max+x%2F(x^2%2B2)\" target=\"_blank\" rel=\"noopener\">local max x/(x^2+2)</a></td>\n<td>极大值：local max</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=local+max+2sin(2x)^2-(5%2F2)cos(x%2F2)%2C+x%3D0+to+pi\" target=\"_blank\" rel=\"noopener\">local max 2sin(2x)^2-(5/2)cos(x/2), x=0 to pi</a></td>\n<td>求指定区间内的极大值</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>求函数的最值</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=global+min+of+2sin(2x)^2-(5%2F2)cos(x%2F2)^2+for+1<%3Dx<%3D3\" target=\"_blank\" rel=\"noopener\">global min of 2sin(2x)^2-(5/2)cos(x/2)^2 for 1&lt;=x&lt;=3</a></td>\n<td>求指定区间内的最小值</td>\n</tr>\n<tr>\n<td><strong>求曲线的拐点</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=inflection+point+of+x%2F(x^2%2B2)\" target=\"_blank\" rel=\"noopener\">inflection point of x/(x^2+2)</a></td>\n<td>拐点：inflection point</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>求不定积分</strong></th>\n<th><a href=\"http://www.wolframalpha.com/input/?i=integrate++x^2%2Bsin(x)%2B1\" target=\"_blank\" rel=\"noopener\">integrate x^2+sin(x)+1</a></th>\n<th>积分：integrate</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=int+xarctan(x)\" target=\"_blank\" rel=\"noopener\">int xarctan(x)</a></td>\n<td>int：integrate 的简写</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>求定积分</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=integrate++x^2%2Bsin(x)%2B1+from+0+to+1+\" target=\"_blank\" rel=\"noopener\">integrate x^2+sin(x)+1 from 0 to 1</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=int++1%2Fsqrt(1-x^2)+%2C+x%3D+0+..1%2F2\" target=\"_blank\" rel=\"noopener\">int 1/sqrt(1-x^2) , x= 0 ..1/2</a></td>\n<td>简单的格式</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>求广义积分</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=int++xexp(-2x)+from+0+to+oo\" target=\"_blank\" rel=\"noopener\">int xexp(-2x) from 0 to oo</a></td>\n<td>无穷大用两个o表示：oo</td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=+int++1%2F(x^2%2B3)+%2C+x%3D+-oo+..+oo\" target=\"_blank\" rel=\"noopener\">int 1/(x^2+3) , x= -oo .. oo</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>求积分变限函数</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=integrate+texp(-t)+from+0+to+x+\" target=\"_blank\" rel=\"noopener\">integrate texp(-t) from 0 to x</a></td>\n<td>积分上限函数</td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=d%2Fdx+(+int+texp(-t)+from+0+to+x+)\" target=\"_blank\" rel=\"noopener\">d/dx ( int texp(-t) from 0 to x )</a></td>\n<td>积分上限函数求导</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=F(x)%3D%3Dintegrate+texp(-t)+from+ln(x)+to+x^2\" target=\"_blank\" rel=\"noopener\">F(x)==integrate texp(-t) from ln(x) to x^2</a></td>\n<td>积分变限函数</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=d%2Fdx+(integrate+texp(-t)+from+ln(x)+to+x^2+)\" target=\"_blank\" rel=\"noopener\">d/dx (integrate texp(-t) from ln(x) to x^2 )</a></td>\n<td>积分变限函数求导</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>曲线与x轴之间的面积</strong></th>\n<th><a href=\"http://www.wolframalpha.com/input/?i=area+between+2-x^2+and+x-axis\" target=\"_blank\" rel=\"noopener\">area between 2-x^2 and x-axis</a></th>\n<th>曲线y=2-x^2与x轴之间的面积</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>曲线下方的面积</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=area+under+3-x^2\" target=\"_blank\" rel=\"noopener\">area under 3-x^2</a></td>\n<td>曲线y=3-x^2与x轴之间的面积</td>\n</tr>\n<tr>\n<td><strong>求两曲线之间的面积</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=area+between+x+and+x^2\" target=\"_blank\" rel=\"noopener\">area between x and x^2</a></td>\n<td>曲线y=x与y=x^2之间的面积</td>\n</tr>\n<tr>\n<td>求两曲线的交点</td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=solve++x^2+%3D+x^3\" target=\"_blank\" rel=\"noopener\">solve x^2 = x^3</a></td>\n<td>曲线y=x^2与y=x^3的交点</td>\n</tr>\n<tr>\n<td><strong>求两曲线之间的面积</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=area+between+sin(x)+and+cos(2x)+from+x%3D0+to+pi\" target=\"_blank\" rel=\"noopener\">area between sin(x) and cos(2x) from x=0 to pi</a></td>\n<td>曲线y=sinx与y=cos2x (0&lt;x&lt;pi) 之间的面积</td>\n</tr>\n<tr>\n<td><strong>旋转体的体积</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=V%3Dpi*Integrate+(sin(x)^2%2C+x%3D0..2)\" target=\"_blank\" rel=\"noopener\">V=pi*Integrate (sin(x)^2, x=0..2)</a></td>\n<td>曲线y=sinx (0&lt;x&lt;2) 与x轴 之间的区域绕x轴旋转</td>\n</tr>\n<tr>\n<td><strong>旋转体的体积</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=V%3Dpi*Integrate+(x^2-sin(x)^2%2C+x%3D0..pi)\" target=\"_blank\" rel=\"noopener\">V=pi*Integrate (x^2-sin(x)^2, x=0..pi)</a></td>\n<td>曲线y=x与y=sinx (0&lt;x&lt;pi) 之间的区域绕x轴旋转</td>\n</tr>\n<tr>\n<td><strong>求曲线的弧长</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=int+sqrt(1%2B+(+(x^2)' target=\"_blank\" rel=\"noopener\"+)^2)%2C+x%3D1..3\">int sqrt(1+ ( (x^2)’ )^2), x=1..3</a></td>\n<td>曲线 y=x^2 (1&lt;x&lt;3) 的弧长</td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=int++sqrt(+(sin(t^3))' target=\"_blank\" rel=\"noopener\"+^2%2B(t)'^2+)%2C+t%3D-1..1\">int sqrt( (sin(t^3))’ ^2+(t)’^2 ), t=-1..1</a></td>\n<td>参数曲线 x=sin(t^3), y=t (-1&lt;t&lt;1) 的弧长</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>向量的点积</strong></th>\n<th><a href=\"http://www.wolframalpha.com/input/?i=(1%2C2%2C4)+.+(-2%2C3%2C6)+\" target=\"_blank\" rel=\"noopener\">(1,2,4) . (-2,3,6)</a></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>向量的叉积</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=+(1%2C2%2C4)+cross+(-2%2C3%2C6)\" target=\"_blank\" rel=\"noopener\">(1,2,4) cross (-2,3,6)</a></td>\n<td>叉积：cross</td>\n</tr>\n<tr>\n<td><strong>求偏导数</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=+d%2Fdx+sin(x^2%2B2y)\" target=\"_blank\" rel=\"noopener\">d/dx sin(x^2+2y)</a></td>\n<td>对 x 求偏导数</td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=d%2Fdy+sin(x^2%2B2y)\" target=\"_blank\" rel=\"noopener\">d/dy sin(x^2+2y)</a></td>\n<td>对 y 求偏导数</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=d%2Fdx+sin(x^2%2B2y)+at+(1%2C2)\" target=\"_blank\" rel=\"noopener\">d/dx sin(x^2+2y) at (1,2)</a></td>\n<td>在某一点的偏导数</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>高阶偏导数</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=d%2Fdx+d%2Fdx+x^3*y^2+-+3*x*y^3+-+x*y+%2B+1\" target=\"_blank\" rel=\"noopener\">d/dx d/dx x^3<em>y^2 - 3</em>x<em>y^3 - x</em>y + 1</a></td>\n<td>对 x 的二阶偏导数</td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=d%2Fdy+d%2Fdx+x^3*y^2+-+3*x*y^3+-+x*y+%2B+1\" target=\"_blank\" rel=\"noopener\">d/dy d/dx x^3<em>y^2 - 3</em>x<em>y^3 - x</em>y + 1</a></td>\n<td>混合偏导数</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>隐函数的偏导数</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=-(+d%2Fdx(+exp(z)-xyz+)+)%2F(+d%2Fdz+(exp(z)-xyz)+)\" target=\"_blank\" rel=\"noopener\">-( d/dx( exp(z)-xyz ) )/( d/dz (exp(z)-xyz) )</a></td>\n<td>方程e^z=xyz的偏导数：dz/dx</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>向量函数的导数</strong></th>\n<th><a href=\"http://www.wolframalpha.com/input/?i=(t^2%2C+4t-3%2C+2t^2-6t)' target=\"_blank\" rel=\"noopener\"\">(t^2, 4t-3, 2t^2-6t)’</a></th>\n<th>速度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>向量函数的二阶导数</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=(t^2%2C+e^t%2C+2t^3)' target=\"_blank\" rel=\"noopener\"'\">(t^2, e^t, 2t^3)’’</a></td>\n<td>加速度</td>\n</tr>\n<tr>\n<td><strong>求梯度</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=grad++x^2%2Bcos(2y)+\" target=\"_blank\" rel=\"noopener\">grad x^2+cos(2y) </a></td>\n<td>二元函数的梯度</td>\n</tr>\n<tr>\n<td>用 grad 或 del 求梯度</td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=del++x^2y%2Bcos(xy)%2Bxyz^2\" target=\"_blank\" rel=\"noopener\">del x^2y+cos(xy)+xyz^2</a></td>\n<td>三元函数的梯度</td>\n</tr>\n<tr>\n<td><strong>求方向导数</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=+derivative+of+x^2%2Bcos(2y)+in+the+direction+(2%2C-3)+at+(1%2C2)\" target=\"_blank\" rel=\"noopener\">derivative of x^2+cos(2y) in the direction (2,-3) at (1,2)</a></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>求二元函数的驻点</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=stationary+point+of++x^3-y^3%2B3*x^2%2B3*y^2-9*x\" target=\"_blank\" rel=\"noopener\">stationary point of x^3-y^3+3<em>x^2+3</em>y^2-9*x</a></td>\n<td>驻点：stationary point</td>\n</tr>\n<tr>\n<td><strong>求二元函数的极值</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=local+max++x^3-y^3%2B3*x^2%2B3*y^2-9*x\" target=\"_blank\" rel=\"noopener\">local max x^3-y^3+3<em>x^2+3</em>y^2-9*x</a></td>\n<td>极大值：local max</td>\n</tr>\n<tr>\n<td>或 <a href=\"http://www.wolframalpha.com/input/?i=+maximize++x^3-y^3%2B3*x^2%2B3*y^2-9*x\" target=\"_blank\" rel=\"noopener\">maximize x^3-y^3+3<em>x^2+3</em>y^2-9*x</a></td>\n<td>最大化：maximize</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>求二元函数的最值</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=minimize+2(xy%2B2%2Fx%2B2%2Fy)++for+x>0%2C+y>0\" target=\"_blank\" rel=\"noopener\">minimize 2(xy+2/x+2/y) for x&gt;0, y&gt;0</a></td>\n<td>最小化：minimize</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>求条件极值</strong></th>\n<th><a href=\"http://www.wolframalpha.com/input/?i=maximize+xy+on+x%2By%3D1\" target=\"_blank\" rel=\"noopener\">maximize xy on x+y=1</a></th>\n<th>求函数xy在x+y=1上的最大值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=maximize++xyz+on++2*(x*y+%2B+y*z+%2B+z*x)+%3D1%2C+x>0%2Cy>0%2Cz>0+\" target=\"_blank\" rel=\"noopener\">maximize xyz on 2<em>(x</em>y + y<em>z + z</em>x) =1, x&gt;0,y&gt;0,z&gt;0</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=maximize+sqrt(x^2%2By^2%2Bz^2)+on+z%3Dx^2%2By^2+and+x%2By%2Bz%3D1\" target=\"_blank\" rel=\"noopener\">maximize sqrt(x^2+y^2+z^2) on z=x^2+y^2 and x+y+z=1</a></td>\n<td>两个约束条件</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>二重积分</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=int++x^2y%2Bx%2C++y%3D2..4%2C+x%3D1..3\" target=\"_blank\" rel=\"noopener\">int x^2y+x, y=2..4, x=1..3</a></td>\n<td>矩形区域</td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=int++xy+%2C+x%3D1..2%2C+y%3D1..x\" target=\"_blank\" rel=\"noopener\">int xy , x=1..2, y=1..x</a></td>\n<td>先y, 后x</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=int++xy+%2C+y%3D-1..2%2C+x%3Dy^2..y%2B2\" target=\"_blank\" rel=\"noopener\">int xy , y=-1..2, x=y^2..y+2</a></td>\n<td>先x, 后y</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>三重积分</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=int++x+%2C+x%3D0..1%2C+y%3D0..(1-x)%2F2%2C+z%3D0..1-x-2y\" target=\"_blank\" rel=\"noopener\">int x , x=0..1, y=0..(1-x)/2, z=0..1-x-2y</a></td>\n<td>积分次序:：z, y,x</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>级数求和</strong></th>\n<th><a href=\"http://www.wolframalpha.com/input/?i=sum+3*(2%2F5)^n%2C+n%3D1..oo\" target=\"_blank\" rel=\"noopener\">sum 3*(2/5)^n, n=1..oo</a></th>\n<th>等比级数求和</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>用 sum 求和</td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=sum+1%2Fn^2%2C+n%3D1..oo\" target=\"_blank\" rel=\"noopener\">sum 1/n^2, n=1..oo</a></td>\n<td>p-级数求和</td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=sum+(-1)^(n%2B1)%2Fn^2%2C+n%3D1..oo\" target=\"_blank\" rel=\"noopener\">sum (-1)^(n+1)/n^2, n=1..oo</a></td>\n<td>交错级数求和</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>幂级数的和函数</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=sum+(-1)^(n%2B1)*x^(2n-1)%2F(2n-1)%2Cn%3D1...oo\" target=\"_blank\" rel=\"noopener\">sum (-1)^(n+1)*x^(2n-1)/(2n-1),n=1…oo</a></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>函数的泰勒公式</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=series+xsin(x)+to+order+5\" target=\"_blank\" rel=\"noopener\">series xsin(x) to order 5</a>      series：级数</td>\n<td>xsinx在x=0处的5阶泰勒公式</td>\n</tr>\n<tr>\n<td>用series 或 taylor</td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=+taylor+e^x+at+x%3D1+to+order+5\" target=\"_blank\" rel=\"noopener\">taylor e^x at x=1 to order 5</a>   taylor：泰勒</td>\n<td>e^x在x=1处的5阶泰勒公式</td>\n</tr>\n<tr>\n<td><strong>解微分方程</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=+y’%3D2xy\" target=\"_blank\" rel=\"noopener\">y’=2xy</a></td>\n<td>直接输入微分方程</td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=y’%3De^(2x-y)%2C+y(0)%3D0\" target=\"_blank\" rel=\"noopener\">y’=e^(2x-y), y(0)=0</a></td>\n<td>求特解</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=(1%2Bx^2)y’’%3D2xy’%2C+y(0)%3D1%2C+y’(0)%3D3\" target=\"_blank\" rel=\"noopener\">(1+x^2)y’’=2xy’, y(0)=1, y’(0)=3</a></td>\n<td>二阶微分方程的特解</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>高阶线性微分方程</strong></th>\n<th><a href=\"http://www.wolframalpha.com/input/?i=y’’-5y’%2B6y%3Dxe^(2x)\" target=\"_blank\" rel=\"noopener\">y’’-5y’+6y=xe^(2x)</a></th>\n<th>二阶微分方程的通解</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=+y’’%2By%2Bsin(2x)%3D0%2C+y(pi)%3D1%2C+y’(pi)%3D1\" target=\"_blank\" rel=\"noopener\">y’’+y+sin(2x)=0, y(pi)=1, y’(pi)=1</a></td>\n<td>二阶微分方程的特解</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>作 图</strong></td>\n<td><img src= \"/img/loading.gif\" data-lazy-src=\"http://b.bst.126.net/common/portrait/face/preview/face1.gif\" alt=\"WolframAlpha 快速指南 - calculus - 高等数学\"></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>一元函数图形</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=+plot+y%3Dx^3-x^2-x%2B1%2C+x%3D-2..2\" target=\"_blank\" rel=\"noopener\">plot y=x^3-x^2-x+1, x=-2..2</a></td>\n<td>作图：plot</td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=plot+xsinx%2Carctanx\" target=\"_blank\" rel=\"noopener\">plot xsinx,arctanx</a></td>\n<td>两条曲线</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>隐函数的图形</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=plot+x^3%2By^3%3D6xy\" target=\"_blank\" rel=\"noopener\">plot x^3+y^3=6xy</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=plot+x^3%2By^3%3D6xy%2C+x%3D-4..4%2C+y%3D-4..4\" target=\"_blank\" rel=\"noopener\">plot x^3+y^3=6xy, x=-4..4, y=-4..4</a></td>\n<td>指定范围</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=+plot+x^2%2By^2%3D2x%2C+x%3Dy^3%2B1\" target=\"_blank\" rel=\"noopener\">plot x^2+y^2=2x, x=y^3+1</a></td>\n<td>两条曲线</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>参数曲线</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=parametric+plot+(t(1-sint)%2Ctcost)+from+t%3D-10+to+10\" target=\"_blank\" rel=\"noopener\">parametric plot (t(1-sint),tcost) from t=-10 to 10</a> parametric plot : 参数方程作图</td>\n<td>参数方程 x=t(1-sint), y=tcost 的图形</td>\n</tr>\n<tr>\n<td><strong>极坐标曲线</strong></td>\n<td><a href=\"http://www.wolframalpha.com/input/?i=polar+plot+1%2Bcost%2C+t%3D0..2pi\" target=\"_blank\" rel=\"noopener\">polar plot 1+cost, t=0..2pi</a>  polar plot: 极坐标作图</td>\n<td>极坐标方程 r=1+cost 的图形</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>曲面作图</strong></th>\n<th>[plot x^2+y^2, -2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"http://www.wolframalpha.com/input/?i=plot++sqrt(2-x^2-3y^2)\" target=\"_blank\" rel=\"noopener\">plot sqrt(2-x^2-3y^2)</a></td>\n<td></td>\n</tr>\n</tbody></table>\n","tags":["资源分享"]}]