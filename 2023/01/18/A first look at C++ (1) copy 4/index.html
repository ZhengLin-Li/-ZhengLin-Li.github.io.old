<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>A first look at C++ (1) copy 4 | 熊儿老猫的博客</title><meta name="description" content="4 程序流程结构C&#x2F;C++支持最基本的三种程序运行结构：&#x3D;&#x3D;顺序结构、选择结构、循环结构&#x3D;&#x3D; 顺序结构：程序按顺序执行，不发生跳转选择结构：依据条件是否满足，有选择的执行相应功能循环结构：依据条件是否满足，循环多次执行某段代码4.1 选择结构4.1.1 if 语句作用：执行满足条件的语句 if 语句的三种形式 单行格式 if 语句 多行格式 if 语句 多条件的 if 语句 单行格式 if 语句："><meta name="author" content="Zhenglin Li"><meta name="copyright" content="Zhenglin Li"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://9pshr3.coding-pages.com/2023/01/18/A%20first%20look%20at%20C++%20(1)%20copy%204/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="A first look at C++ (1) copy 4"><meta property="og:url" content="http://9pshr3.coding-pages.com/2023/01/18/A%20first%20look%20at%20C++%20(1)%20copy%204/"><meta property="og:site_name" content="熊儿老猫的博客"><meta property="og:description" content="4 程序流程结构C&#x2F;C++支持最基本的三种程序运行结构：&#x3D;&#x3D;顺序结构、选择结构、循环结构&#x3D;&#x3D; 顺序结构：程序按顺序执行，不发生跳转选择结构：依据条件是否满足，有选择的执行相应功能循环结构：依据条件是否满足，循环多次执行某段代码4.1 选择结构4.1.1 if 语句作用：执行满足条件的语句 if 语句的三种形式 单行格式 if 语句 多行格式 if 语句 多条件的 if 语句 单行格式 if 语句："><meta property="og:image" content="https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-8.webp"><meta property="article:published_time" content="2023-01-18T12:11:43.003Z"><meta property="article:modified_time" content="2023-01-18T11:55:22.474Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'true'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?0773dcadd0397be86eb74da114bd1757";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: false,
  postUpdate: '2023-01-18 19:55:22'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">42</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-8.webp)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">熊儿老猫的博客</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">A first look at C++ (1) copy 4</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-18T12:11:43.003Z" title="发表于 2023-01-18 20:11:43">2023-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-18T11:55:22.474Z" title="更新于 2023-01-18 19:55:22">2023-01-18</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>4 程序流程结构<br>C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==</p>
<p>顺序结构：程序按顺序执行，不发生跳转<br>选择结构：依据条件是否满足，有选择的执行相应功能<br>循环结构：依据条件是否满足，循环多次执行某段代码<br>4.1 选择结构<br>4.1.1 if 语句<br>作用：执行满足条件的语句</p>
<p>if 语句的三种形式</p>
<p>单行格式 if 语句</p>
<p>多行格式 if 语句</p>
<p>多条件的 if 语句</p>
<p>单行格式 if 语句：if(条件){ 条件满足执行的语句 }</p>
<p>![img](C:\Users\Zhenglin Li\Desktop\assets\clip_image002.png)</p>
<p>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>//选择结构-单行if语句
//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印

int score = 0;
cout &lt;&lt; &quot;请输入一个分数：&quot; &lt;&lt; endl;
cin &gt;&gt; score;

cout &lt;&lt; &quot;您输入的分数为： &quot; &lt;&lt; score &lt;&lt; endl;

//if语句
//注意事项，在if判断语句后面，不要加分号
if (score &gt; 600)
{
    cout &lt;&lt; &quot;我考上了一本大学！！！&quot; &lt;&lt; endl;
}

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>注意：if 条件表达式后不要加分号</p>
<p>多行格式 if 语句：if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };<br>![img](C:\Users\Zhenglin Li\Desktop\assets\clip_image002-1541662519170.png)</p>
<p>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>int score = 0;

cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;

cin &gt;&gt; score;

if (score &gt; 600)
{
    cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;
}
else
{
    cout &lt;&lt; &quot;我未考上一本大学&quot; &lt;&lt; endl;
}

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>多条件的 if 语句：if(条件 1){ 条件 1 满足执行的语句 }else if(条件 2){条件 2 满足执行的语句}… else{ 都不满足执行的语句}<br>![img](C:\Users\Zhenglin Li\Desktop\assets\clip_image002-1541662566808.png)</p>
<p>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>int score = 0;

cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;

cin &gt;&gt; score;

if (score &gt; 600)
{
    cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;
}
else if (score &gt; 500)
{
    cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;
}
else if (score &gt; 400)
{
    cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;
}
else
{
    cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;
}

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>嵌套 if 语句：在 if 语句中，可以嵌套使用 if 语句，达到更精确的条件判断</p>
<p>案例需求：</p>
<p>提示用户输入一个高考考试分数，根据分数做如下判断<br>分数如果大于 600 分视为考上一本，大于 500 分考上二本，大于 400 考上三本，其余视为未考上本科；<br>在一本分数中，如果大于 700 分，考入北大，大于 650 分，考入清华，大于 600 考入人大。<br>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>int score = 0;

cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;

cin &gt;&gt; score;

if (score &gt; 600)
{
    cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;
    if (score &gt; 700)
    {
        cout &lt;&lt; &quot;我考上了北大&quot; &lt;&lt; endl;
    }
    else if (score &gt; 650)
    {
        cout &lt;&lt; &quot;我考上了清华&quot; &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; &quot;我考上了人大&quot; &lt;&lt; endl;
    }

}
else if (score &gt; 500)
{
    cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;
}
else if (score &gt; 400)
{
    cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;
}
else
{
    cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;
}

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>练习案例： 三只小猪称体重</p>
<p>有三只小猪 ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？![三只小猪](C:\Users\Zhenglin Li\Desktop\assets\三只小猪.jpg)</p>
<p>4.1.2 三目运算符<br>作用： 通过三目运算符实现简单的判断</p>
<p>语法：表达式 1 ? 表达式 2 ：表达式 3</p>
<p>解释：</p>
<p>如果表达式 1 的值为真，执行表达式 2，并返回表达式 2 的结果；</p>
<p>如果表达式 1 的值为假，执行表达式 3，并返回表达式 3 的结果。</p>
<p>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>int a = 10;
int b = 20;
int c = 0;

c = a &gt; b ? a : b;
cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;

//C++中三目运算符返回的是变量,可以继续赋值

(a &gt; b ? a : b) = 100;

cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>总结：和 if 语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p>
<p>4.1.3 switch 语句<br>作用：执行多条件分支语句</p>
<p>语法：</p>
<p>C++<br>switch(表达式)</p>
<p>{</p>
<pre><code>case 结果1：执行语句;break;

case 结果2：执行语句;break;

...

default:执行语句;break;</code></pre><p>}<br>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>//请给电影评分
//10 ~ 9   经典
// 8 ~ 7   非常好
// 6 ~ 5   一般
// 5分以下 烂片

int score = 0;
cout &lt;&lt; &quot;请给电影打分&quot; &lt;&lt; endl;
cin &gt;&gt; score;

switch (score)
{
case 10:
case 9:
    cout &lt;&lt; &quot;经典&quot; &lt;&lt; endl;
    break;
case 8:
    cout &lt;&lt; &quot;非常好&quot; &lt;&lt; endl;
    break;
case 7:
case 6:
    cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl;
    break;
default:
    cout &lt;&lt; &quot;烂片&quot; &lt;&lt; endl;
    break;
}

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>注意 1：switch 语句中表达式类型只能是整型或者字符型</p>
<p>注意 2：case 里如果没有 break，那么程序会一直向下执行</p>
<p>总结：与 if 语句比，对于多条件判断时，switch 的结构清晰，执行效率高，缺点是 switch 不可以判断区间</p>
<p>4.2 循环结构<br>4.2.1 while 循环语句<br>作用：满足循环条件，执行循环语句</p>
<p>语法：while(循环条件){ 循环语句 }</p>
<p>解释：==只要循环条件的结果为真，就执行循环语句==</p>
<p>![img](C:\Users\Zhenglin Li\Desktop\assets\clip_image002-1541668640382.png)</p>
<p>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>int num = 0;
while (num &lt; 10)
{
    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;
    num++;
}

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p>
<p>while 循环练习案例：==猜数字==</p>
<p>案例描述：系统随机生成一个 1 到 100 之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。</p>
<p>![猜数字](C:\Users\Zhenglin Li\Desktop\assets\猜数字.jpg)</p>
<p>4.2.2 do…while 循环语句<br>作用： 满足循环条件，执行循环语句</p>
<p>语法： do{ 循环语句 } while(循环条件);</p>
<p>注意：与 while 的区别在于==do…while 会先执行一次循环语句==，再判断循环条件</p>
<p>![img](C:\Users\Zhenglin Li\Desktop\assets\clip_image002-1541671163478.png)</p>
<p>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>int num = 0;

do
{
    cout &lt;&lt; num &lt;&lt; endl;
    num++;

} while (num &lt; 10);


system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>总结：与 while 循环区别在于，do…while 先执行一次循环语句，再判断循环条件</p>
<p>练习案例：水仙花数</p>
<p>案例描述：水仙花数是指一个 3 位数，它的每个位上的数字的 3 次幂之和等于它本身</p>
<p>例如：1^3 + 5^3+ 3^3 = 153</p>
<p>请利用 do…while 语句，求出所有 3 位数中的水仙花数</p>
<p>4.2.3 for 循环语句<br>作用： 满足循环条件，执行循环语句</p>
<p>语法：for(起始表达式;条件表达式;末尾循环体) { 循环语句; }</p>
<p>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>for (int i = 0; i &lt; 10; i++)
{
    cout &lt;&lt; i &lt;&lt; endl;
}

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>详解：</p>
<p>![1541673704101](C:\Users\Zhenglin Li\Desktop\assets\1541673704101.png)</p>
<p>注意：for 循环中的表达式，要用分号进行分隔</p>
<p>总结：while , do…while, for 都是开发中常用的循环语句，for 循环结构比较清晰，比较常用</p>
<p>练习案例：敲桌子</p>
<p>案例描述：从 1 开始数到数字 100， 如果数字个位含有 7，或者数字十位含有 7，或者该数字是 7 的倍数，我们打印敲桌子，其余数字直接打印输出。</p>
<p>![timg](C:\Users\Zhenglin Li\Desktop\assets\timg.gif)</p>
<p>4.2.4 嵌套循环<br>作用： 在循环体中再嵌套一层循环，解决一些实际问题</p>
<p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p>
<p>![1541676003486](C:\Users\Zhenglin Li\Desktop\assets\1541676003486.png)</p>
<p>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>//外层循环执行1次，内层循环执行1轮
for (int i = 0; i &lt; 10; i++)
{
    for (int j = 0; j &lt; 10; j++)
    {
        cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>练习案例：乘法口诀表</p>
<p>案例描述：利用嵌套循环，实现九九乘法表</p>
<p>![0006018857256120_b](C:\Users\Zhenglin Li\Desktop\assets\0006018857256120_b.jpg)</p>
<p>4.3 跳转语句<br>4.3.1 break 语句<br>作用: 用于跳出==选择结构==或者==循环结构==</p>
<p>break 使用的时机：</p>
<p>出现在 switch 条件语句中，作用是终止 case 并跳出 switch<br>出现在循环语句中，作用是跳出当前的循环语句<br>出现在嵌套循环中，跳出最近的内层循环语句<br>示例 1：</p>
<p>C++<br>int main() {<br>//1、在 switch 语句中使用 break<br>cout &lt;&lt; “请选择您挑战副本的难度：” &lt;&lt; endl;<br>cout &lt;&lt; “1、普通” &lt;&lt; endl;<br>cout &lt;&lt; “2、中等” &lt;&lt; endl;<br>cout &lt;&lt; “3、困难” &lt;&lt; endl;</p>
<pre><code>int num = 0;

cin &gt;&gt; num;

switch (num)
{
case 1:
    cout &lt;&lt; &quot;您选择的是普通难度&quot; &lt;&lt; endl;
    break;
case 2:
    cout &lt;&lt; &quot;您选择的是中等难度&quot; &lt;&lt; endl;
    break;
case 3:
    cout &lt;&lt; &quot;您选择的是困难难度&quot; &lt;&lt; endl;
    break;
}

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>示例 2：</p>
<p>C++<br>int main() {<br>//2、在循环语句中用 break<br>for (int i = 0; i &lt; 10; i++)<br>{<br>if (i == 5)<br>{<br>break; //跳出循环语句<br>}<br>cout &lt;&lt; i &lt;&lt; endl;<br>}</p>
<pre><code>system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>示例 3：</p>
<p>C++<br>int main() {<br>//在嵌套循环语句中使用 break，退出内层循环<br>for (int i = 0; i &lt; 10; i++)<br>{<br>for (int j = 0; j &lt; 10; j++)<br>{<br>if (j == 5)<br>{<br>break;<br>}<br>cout &lt;&lt; “*“ &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>}<br>system(“pause”);</p>
<pre><code>return 0;</code></pre><p>}<br>4.3.2 continue 语句<br>作用：在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p>
<p>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>for (int i = 0; i &lt; 100; i++)
{
    if (i % 2 == 0)
    {
        continue;
    }
    cout &lt;&lt; i &lt;&lt; endl;
}

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>注意：continue 并没有使整个循环终止，而 break 会跳出循环</p>
<p>4.3.3 goto 语句<br>作用：可以无条件跳转语句</p>
<p>语法： goto 标记;</p>
<p>解释：如果标记的名称存在，执行到 goto 语句时，会跳转到标记的位置</p>
<p>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;

goto FLAG;

cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;
cout &lt;&lt; &quot;3&quot; &lt;&lt; endl;
cout &lt;&lt; &quot;4&quot; &lt;&lt; endl;

FLAG:

cout &lt;&lt; &quot;5&quot; &lt;&lt; endl;

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>注意：在程序中不建议使用 goto 语句，以免造成程序流程混乱</p>
<p>5 数组<br>5.1 概述<br>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p>
<p>特点 1：数组中的每个==数据元素都是相同的数据类型==</p>
<p>特点 2：数组是由==连续的内存==位置组成的</p>
<p>![1541748375356](C:\Users\Zhenglin Li\Desktop\assets\1541748375356.png)</p>
<p>5.2 一维数组<br>5.2.1 一维数组定义方式<br>一维数组定义的三种方式：</p>
<p>数据类型 数组名[ 数组长度 ];<br>数据类型 数组名[ 数组长度 ] = { 值 1，值 2 …};<br>数据类型 数组名[ ] = { 值 1，值 2 …};<br>示例</p>
<p>C++<br>int main() {</p>
<pre><code>//定义方式1
//数据类型 数组名[元素个数];
int score[10];

//利用下标赋值
score[0] = 100;
score[1] = 99;
score[2] = 85;

//利用下标输出
cout &lt;&lt; score[0] &lt;&lt; endl;
cout &lt;&lt; score[1] &lt;&lt; endl;
cout &lt;&lt; score[2] &lt;&lt; endl;


//第二种定义方式
//数据类型 数组名[元素个数] =  {值1，值2 ，值3 ...};
//如果{}内不足10个数据，剩余数据用0补全
int score2[10] = { 100, 90,80,70,60,50,40,30,20,10 };

//逐个输出
//cout &lt;&lt; score2[0] &lt;&lt; endl;
//cout &lt;&lt; score2[1] &lt;&lt; endl;

//一个一个输出太麻烦，因此可以利用循环进行输出
for (int i = 0; i &lt; 10; i++)
{
    cout &lt;&lt; score2[i] &lt;&lt; endl;
}

//定义方式3
//数据类型 数组名[] =  {值1，值2 ，值3 ...};
int score3[] = { 100,90,80,70,60,50,40,30,20,10 };

for (int i = 0; i &lt; 10; i++)
{
    cout &lt;&lt; score3[i] &lt;&lt; endl;
}

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>总结 1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p>
<p>总结 2：数组中下标是从 0 开始索引</p>
<p>5.2.2 一维数组数组名<br>一维数组名称的用途：</p>
<p>可以统计整个数组在内存中的长度<br>可以获取数组在内存中的首地址<br>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>//数组名用途
//1、可以获取整个数组占用内存空间大小
int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };

cout &lt;&lt; &quot;整个数组所占内存空间为： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;
cout &lt;&lt; &quot;每个元素所占内存空间为： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;
cout &lt;&lt; &quot;数组的元素个数为： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;

//2、可以通过数组名获取到数组首地址
cout &lt;&lt; &quot;数组首地址为： &quot; &lt;&lt; (int)arr &lt;&lt; endl;
cout &lt;&lt; &quot;数组中第一个元素地址为： &quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;
cout &lt;&lt; &quot;数组中第二个元素地址为： &quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;

//arr = 100; 错误，数组名是常量，因此不可以赋值


system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>注意：数组名是常量，不可以赋值</p>
<p>总结 1：直接打印数组名，可以查看数组所占内存的首地址</p>
<p>总结 2：对数组名进行 sizeof，可以获取整个数组占内存空间的大小</p>
<p>练习案例 1：五只小猪称体重</p>
<p>案例描述：</p>
<p>在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};</p>
<p>找出并打印最重的小猪体重。</p>
<p>练习案例 2：数组元素逆置</p>
<p>案例描述：请声明一个 5 个元素的数组，并且将元素逆置.</p>
<p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);</p>
<p>5.2.3 冒泡排序<br>作用： 最常用的排序算法，对数组内元素进行排序</p>
<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。<br>重复以上的步骤，每次比较次数-1，直到不需要比较<br>![1541905327273](C:\Users\Zhenglin Li\Desktop\assets\1541905327273.png)</p>
<p>示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</p>
<p>C++<br>int main() {</p>
<pre><code>int arr[9] = { 4,2,8,0,5,7,1,3,9 };

for (int i = 0; i &lt; 9 - 1; i++)
{
    for (int j = 0; j &lt; 9 - 1 - i; j++)
    {
        if (arr[j] &gt; arr[j + 1])
        {
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}

for (int i = 0; i &lt; 9; i++)
{
    cout &lt;&lt; arr[i] &lt;&lt; endl;
}

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>5.3 二维数组<br>二维数组就是在一维数组上，多加一个维度。</p>
<p>![1541905559138](C:\Users\Zhenglin Li\Desktop\assets\1541905559138.png)</p>
<p>5.3.1 二维数组定义方式<br>二维数组定义的四种方式：</p>
<p>数据类型 数组名[ 行数 ][ 列数 ];<br>数据类型 数组名[ 行数 ][ 列数 ] = { {数据 1，数据 2 } ，{数据 3，数据 4 } };<br>数据类型 数组名[ 行数 ][ 列数 ] = { 数据 1，数据 2，数据 3，数据 4};<br>数据类型 数组名[ ][ 列数 ] = { 数据 1，数据 2，数据 3，数据 4};<br>建议：以上 4 种定义方式，利用==第二种更加直观，提高代码的可读性==</p>
<p>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>//方式1
//数组类型 数组名 [行数][列数]
int arr[2][3];
arr[0][0] = 1;
arr[0][1] = 2;
arr[0][2] = 3;
arr[1][0] = 4;
arr[1][1] = 5;
arr[1][2] = 6;

for (int i = 0; i &lt; 2; i++)
{
    for (int j = 0; j &lt; 3; j++)
    {
        cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}

//方式2
//数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } };
int arr2[2][3] =
{
    {1,2,3},
    {4,5,6}
};

//方式3
//数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4  };
int arr3[2][3] = { 1,2,3,4,5,6 };

//方式4
//数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4  };
int arr4[][3] = { 1,2,3,4,5,6 };

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p>
<p>5.3.2 二维数组数组名<br>查看二维数组所占内存空间<br>获取二维数组首地址<br>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>//二维数组数组名
int arr[2][3] =
{
    {1,2,3},
    {4,5,6}
};

cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;
cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;
cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;

cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;
cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl;

//地址
cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl;
cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl;
cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl;

cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl;
cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl;

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>总结 1：二维数组名就是这个数组的首地址</p>
<p>总结 2：对二维数组名进行 sizeof 时，可以获取整个二维数组占用的内存空间大小</p>
<p>5.3.3 二维数组应用案例<br>考试成绩统计：</p>
<p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩</p>
<p>语文 数学 英语<br>张三 100 100 100<br>李四 90 50 100<br>王五 60 70 80<br>参考答案：</p>
<p>C++<br>int main() {</p>
<pre><code>int scores[3][3] =
{
    {100,100,100},
    {90,50,100},
    {60,70,80},
};

string names[3] = { &quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot; };

for (int i = 0; i &lt; 3; i++)
{
    int sum = 0;
    for (int j = 0; j &lt; 3; j++)
    {
        sum += scores[i][j];
    }
    cout &lt;&lt; names[i] &lt;&lt; &quot;同学总成绩为： &quot; &lt;&lt; sum &lt;&lt; endl;
}

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>6 函数<br>6.1 概述<br>作用：将一段经常使用的代码封装起来，减少重复代码</p>
<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>
<p>6.2 函数的定义<br>函数的定义一般主要有 5 个步骤：</p>
<p>1、返回值类型</p>
<p>2、函数名</p>
<p>3、参数表列</p>
<p>4、函数体语句</p>
<p>5、return 表达式</p>
<p>语法：</p>
<p>C++<br>返回值类型 函数名 （参数列表）<br>{</p>
<pre><code>函数体语句

return表达式</code></pre><p>}<br>返回值类型 ：一个函数可以返回一个值。在函数定义中<br>函数名：给函数起个名称<br>参数列表：使用该函数时，传入的数据<br>函数体语句：花括号内的代码，函数内需要执行的语句<br>return 表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据<br>示例：定义一个加法函数，实现两个数相加</p>
<p>C++<br>//函数定义<br>int add(int num1, int num2)<br>{<br>int sum = num1 + num2;<br>return sum;<br>}<br>6.3 函数的调用<br>功能：使用定义好的函数</p>
<p>语法：函数名（参数）</p>
<p>示例：</p>
<p>C++<br>//函数定义<br>int add(int num1, int num2) //定义中的 num1,num2 称为形式参数，简称形参<br>{<br>int sum = num1 + num2;<br>return sum;<br>}</p>
<p>int main() {</p>
<pre><code>int a = 10;
int b = 10;
//调用add函数
int sum = add(a, b);//调用时的a，b称为实际参数，简称实参
cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;

a = 100;
b = 100;

sum = add(a, b);
cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p>
<p>6.4 值传递<br>所谓值传递，就是函数调用时实参将数值传入给形参<br>值传递时，==如果形参发生，并不会影响实参==<br>示例：</p>
<p>C++<br>void swap(int num1, int num2)<br>{<br>cout &lt;&lt; “交换前：” &lt;&lt; endl;<br>cout &lt;&lt; “num1 = “ &lt;&lt; num1 &lt;&lt; endl;<br>cout &lt;&lt; “num2 = “ &lt;&lt; num2 &lt;&lt; endl;</p>
<pre><code>int temp = num1;
num1 = num2;
num2 = temp;

cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl;
cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;
cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;

//return ; 当函数声明时候，不需要返回值，可以不写return</code></pre><p>}</p>
<p>int main() {</p>
<pre><code>int a = 10;
int b = 20;

swap(a, b);

cout &lt;&lt; &quot;mian中的 a = &quot; &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; &quot;mian中的 b = &quot; &lt;&lt; b &lt;&lt; endl;

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>总结： 值传递时，形参是修饰不了实参的</p>
<p>6.5 函数的常见样式<br>常见的函数样式有 4 种</p>
<p>无参无返<br>有参无返<br>无参有返<br>有参有返<br>示例：</p>
<p>C++<br>//函数常见样式<br>//1、 无参无返<br>void test01()<br>{<br>//void a = 10; //无类型不可以创建变量,原因无法分配内存<br>cout &lt;&lt; “this is test01” &lt;&lt; endl;<br>//test01(); 函数调用<br>}</p>
<p>//2、 有参无返<br>void test02(int a)<br>{<br>cout &lt;&lt; “this is test02” &lt;&lt; endl;<br>cout &lt;&lt; “a = “ &lt;&lt; a &lt;&lt; endl;<br>}</p>
<p>//3、无参有返<br>int test03()<br>{<br>cout &lt;&lt; “this is test03 “ &lt;&lt; endl;<br>return 10;<br>}</p>
<p>//4、有参有返<br>int test04(int a, int b)<br>{<br>cout &lt;&lt; “this is test04 “ &lt;&lt; endl;<br>int sum = a + b;<br>return sum;<br>}<br>6.6 函数的声明<br>作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<p>函数的声明可以多次，但是函数的定义只能有一次<br>示例：</p>
<p>C++<br>//声明可以多次，定义只能一次<br>//声明<br>int max(int a, int b);<br>int max(int a, int b);<br>//定义<br>int max(int a, int b)<br>{<br>return a &gt; b ? a : b;<br>}</p>
<p>int main() {</p>
<pre><code>int a = 100;
int b = 200;

cout &lt;&lt; max(a, b) &lt;&lt; endl;

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>6.7 函数的分文件编写<br>作用：让代码结构更加清晰</p>
<p>函数分文件编写一般有 4 个步骤</p>
<p>创建后缀名为.h 的头文件<br>创建后缀名为.cpp 的源文件<br>在头文件中写函数的声明<br>在源文件中写函数的定义<br>示例：</p>
<p>C++<br>//swap.h 文件<br>#include<iostream><br>using namespace std;</p>
<p>//实现两个数字交换的函数声明<br>void swap(int a, int b);<br>C++<br>//swap.cpp 文件<br>#include “swap.h”</p>
<p>void swap(int a, int b)<br>{<br>int temp = a;<br>a = b;<br>b = temp;</p>
<pre><code>cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</code></pre><p>}<br>C++<br>//main 函数文件<br>#include “swap.h”<br>int main() {</p>
<pre><code>int a = 100;
int b = 200;
swap(a, b);

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>7 指针<br>7.1 指针的基本概念<br>指针的作用： 可以通过指针间接访问内存</p>
<p>内存编号是从 0 开始记录的，一般用十六进制数字表示<br>可以利用指针变量保存地址<br>7.2 指针变量的定义和使用<br>指针变量定义语法： 数据类型 * 变量名；</p>
<p>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>//1、指针的定义
int a = 10; //定义整型变量a

//指针定义语法： 数据类型 * 变量名 ;
int * p;

//指针变量赋值
p = &amp;a; //指针指向变量a的地址
cout &lt;&lt; &amp;a &lt;&lt; endl; //打印数据a的地址
cout &lt;&lt; p &lt;&lt; endl;  //打印指针变量p

//2、指针的使用
//通过*操作指针变量指向的内存
cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>指针变量和普通变量的区别</p>
<p>普通变量存放的是数据,指针变量存放的是地址<br>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用<br>总结 1： 我们可以通过 &amp; 符号 获取变量的地址</p>
<p>总结 2：利用指针可以记录地址</p>
<p>总结 3：对指针变量解引用，可以操作指针指向的内存</p>
<p>7.3 指针所占内存空间<br>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p>
<p>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>int a = 10;

int * p;
p = &amp;a; //指针指向数据a的地址

cout &lt;&lt; *p &lt;&lt; endl; //* 解引用
cout &lt;&lt; sizeof(p) &lt;&lt; endl;
cout &lt;&lt; sizeof(char *) &lt;&lt; endl;
cout &lt;&lt; sizeof(float *) &lt;&lt; endl;
cout &lt;&lt; sizeof(double *) &lt;&lt; endl;

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>总结：所有指针类型在 32 位操作系统下是 4 个字节</p>
<p>7.4 空指针和野指针<br>空指针：指针变量指向内存中编号为 0 的空间</p>
<p>用途：初始化指针变量</p>
<p>注意：空指针指向的内存是不可以访问的</p>
<p>示例 1：空指针</p>
<p>C++<br>int main() {</p>
<pre><code>//指针变量p指向内存地址编号为0的空间
int * p = NULL;

//访问空指针报错
//内存编号0 ~255为系统占用内存，不允许用户访问
cout &lt;&lt; *p &lt;&lt; endl;

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>野指针：指针变量指向非法的内存空间</p>
<p>示例 2：野指针</p>
<p>C++<br>int main() {</p>
<pre><code>//指针变量p指向内存地址编号为0x1100的空间
int * p = (int *)0x1100;

//访问野指针报错
cout &lt;&lt; *p &lt;&lt; endl;

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p>
<p>7.5 const 修饰指针<br>const 修饰指针有三种情况</p>
<p>const 修饰指针 — 常量指针<br>const 修饰常量 — 指针常量<br>const 即修饰指针，又修饰常量<br>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>int a = 10;
int b = 10;

//const修饰的是指针，指针指向可以改，指针指向的值不可以更改
const int * p1 = &amp;a;
p1 = &amp;b; //正确
//*p1 = 100;  报错


//const修饰的是常量，指针指向不可以改，指针指向的值可以更改
int * const p2 = &amp;a;
//p2 = &amp;b; //错误
*p2 = 100; //正确

//const既修饰指针又修饰常量
const int * const p3 = &amp;a;
//p3 = &amp;b; //错误
//*p3 = 100; //错误

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>技巧：看 const 右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p>
<p>7.6 指针和数组<br>作用：利用指针访问数组中元素</p>
<p>示例：</p>
<p>C++<br>int main() {</p>
<pre><code>int arr[] = { 1,2,3,4,5,6,7,8,9,10 };

int * p = arr;  //指向数组的指针

cout &lt;&lt; &quot;第一个元素： &quot; &lt;&lt; arr[0] &lt;&lt; endl;
cout &lt;&lt; &quot;指针访问第一个元素： &quot; &lt;&lt; *p &lt;&lt; endl;

for (int i = 0; i &lt; 10; i++)
{
    //利用指针遍历数组
    cout &lt;&lt; *p &lt;&lt; endl;
    p++;
}

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>7.7 指针和函数<br>作用：利用指针作函数参数，可以修改实参的值</p>
<p>示例：</p>
<p>C++<br>//值传递<br>void swap1(int a ,int b)<br>{<br>int temp = a;<br>a = b;<br>b = temp;<br>}<br>//地址传递<br>void swap2(int * p1, int *p2)<br>{<br>int temp = *p1;<br>*p1 = *p2;<br>*p2 = temp;<br>}</p>
<p>int main() {</p>
<pre><code>int a = 10;
int b = 20;
swap1(a, b); // 值传递不会改变实参

swap2(&amp;a, &amp;b); //地址传递会改变实参

cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>
<p>7.8 指针、数组、函数<br>案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p>
<p>例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };</p>
<p>示例：</p>
<p>C++<br>//冒泡排序函数<br>void bubbleSort(int _ arr, int len) //int _ arr 也可以写为 int arr[]<br>{<br>for (int i = 0; i &lt; len - 1; i++)<br>{<br>for (int j = 0; j &lt; len - 1 - i; j++)<br>{<br>if (arr[j] &gt; arr[j + 1])<br>{<br>int temp = arr[j];<br>arr[j] = arr[j + 1];<br>arr[j + 1] = temp;<br>}<br>}<br>}<br>}</p>
<p>//打印数组函数<br>void printArray(int arr[], int len)<br>{<br>for (int i = 0; i &lt; len; i++)<br>{<br>cout &lt;&lt; arr[i] &lt;&lt; endl;<br>}<br>}</p>
<p>int main() {</p>
<pre><code>int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };
int len = sizeof(arr) / sizeof(int);

bubbleSort(arr, len);

printArray(arr, len);

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p>
<p>8 结构体<br>8.1 结构体基本概念<br>结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型</p>
<p>8.2 结构体定义和使用<br>语法：struct 结构体名 { 结构体成员列表 }；</p>
<p>通过结构体创建变量的方式有三种：</p>
<p>struct 结构体名 变量名<br>struct 结构体名 变量名 = { 成员 1 值 ， 成员 2 值…}<br>定义结构体时顺便创建变量<br>示例：</p>
<p>C++<br>//结构体定义<br>struct student<br>{<br>//成员列表<br>string name; //姓名<br>int age; //年龄<br>int score; //分数<br>}stu3; //结构体变量创建方式 3</p>
<p>int main() {</p>
<pre><code>//结构体变量创建方式1
struct student stu1; //struct 关键字可以省略

stu1.name = &quot;张三&quot;;
stu1.age = 18;
stu1.score = 100;

cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu1.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu1.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu1.score &lt;&lt; endl;

//结构体变量创建方式2
struct student stu2 = { &quot;李四&quot;,19,60 };

cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu2.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu2.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu2.score &lt;&lt; endl;


stu3.name = &quot;王五&quot;;
stu3.age = 18;
stu3.score = 80;


cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu3.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu3.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu3.score &lt;&lt; endl;

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>总结 1：定义结构体时的关键字是 struct，不可省略</p>
<p>总结 2：创建结构体变量时，关键字 struct 可以省略</p>
<p>总结 3：结构体变量利用操作符 ‘’.’’ 访问成员</p>
<p>8.3 结构体数组<br>作用：将自定义的结构体放入到数组中方便维护</p>
<p>语法：struct 结构体名 数组名[元素个数] = { {} , {} , … {} }</p>
<p>示例：</p>
<p>C++<br>//结构体定义<br>struct student<br>{<br>//成员列表<br>string name; //姓名<br>int age; //年龄<br>int score; //分数<br>}</p>
<p>int main() {<br>//结构体数组<br>struct student arr[3]=<br>{<br>{“张三”,18,80 },<br>{“李四”,19,60 },<br>{“王五”,20,70 }<br>};</p>
<pre><code>for (int i = 0; i &lt; 3; i++)
{
    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; arr[i].age &lt;&lt; &quot; 分数：&quot; &lt;&lt; arr[i].score &lt;&lt; endl;
}

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>8.4 结构体指针<br>作用：通过指针访问结构体中的成员</p>
<p>利用操作符 -&gt;可以通过结构体指针访问结构体属性<br>示例：</p>
<p>C++<br>//结构体定义<br>struct student<br>{<br>//成员列表<br>string name; //姓名<br>int age; //年龄<br>int score; //分数<br>};</p>
<p>int main() {<br>struct student stu = { “张三”,18,100, };<br>struct student * p = &stu;<br>p-&gt;score = 80; //指针通过 -&gt; 操作符可以访问成员</p>
<pre><code>cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl;

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p>
<p>8.5 结构体嵌套结构体<br>作用： 结构体中的成员可以是另一个结构体</p>
<p>例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p>
<p>示例：</p>
<p>C++<br>//学生结构体定义<br>struct student<br>{<br>//成员列表<br>string name; //姓名<br>int age; //年龄<br>int score; //分数<br>};</p>
<p>//教师结构体定义<br>struct teacher<br>{<br>//成员列表<br>int id; //职工编号<br>string name; //教师姓名<br>int age; //教师年龄<br>struct student stu; //子结构体 学生<br>};</p>
<p>int main() {</p>
<pre><code>struct teacher t1;
t1.id = 10000;
t1.name = &quot;老王&quot;;
t1.age = 40;

t1.stu.name = &quot;张三&quot;;
t1.stu.age = 18;
t1.stu.score = 100;

cout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl;

cout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl;

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>总结：在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p>
<p>8.6 结构体做函数参数<br>作用：将结构体作为参数向函数中传递</p>
<p>传递方式有两种：</p>
<p>值传递<br>地址传递<br>示例：</p>
<p>C++<br>//学生结构体定义<br>struct student<br>{<br>//成员列表<br>string name; //姓名<br>int age; //年龄<br>int score; //分数<br>};</p>
<p>//值传递<br>void printStudent(student stu )<br>{<br>stu.age = 28;<br>cout &lt;&lt; “子函数中 姓名：” &lt;&lt; stu.name &lt;&lt; “ 年龄： “ &lt;&lt; stu.age &lt;&lt; “ 分数：” &lt;&lt; stu.score &lt;&lt; endl;<br>}</p>
<p>//地址传递<br>void printStudent2(student *stu)<br>{<br>stu-&gt;age = 28;<br>cout &lt;&lt; “子函数中 姓名：” &lt;&lt; stu-&gt;name &lt;&lt; “ 年龄： “ &lt;&lt; stu-&gt;age &lt;&lt; “ 分数：” &lt;&lt; stu-&gt;score &lt;&lt; endl;<br>}</p>
<p>int main() {</p>
<pre><code>student stu = { &quot;张三&quot;,18,100};
//值传递
printStudent(stu);
cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;

cout &lt;&lt; endl;

//地址传递
printStudent2(&amp;stu);
cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p>
<p>8.7 结构体中 const 使用场景<br>作用：用 const 来防止误操作</p>
<p>示例：</p>
<p>C++<br>//学生结构体定义<br>struct student<br>{<br>//成员列表<br>string name; //姓名<br>int age; //年龄<br>int score; //分数<br>};</p>
<p>//const 使用场景<br>void printStudent(const student *stu) //加 const 防止函数体中的误操作<br>{<br>//stu-&gt;age = 100; //操作失败，因为加了 const 修饰<br>cout &lt;&lt; “姓名：” &lt;&lt; stu-&gt;name &lt;&lt; “ 年龄：” &lt;&lt; stu-&gt;age &lt;&lt; “ 分数：” &lt;&lt; stu-&gt;score &lt;&lt; endl;</p>
<p>}</p>
<p>int main() {</p>
<pre><code>student stu = { &quot;张三&quot;,18,100 };

printStudent(&amp;stu);

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>8.8 结构体案例<br>8.8.1 案例 1<br>案例描述：</p>
<p>学校正在做毕设项目，每名老师带领 5 个学生，总共有 3 名老师，需求如下</p>
<p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放 5 名学生的数组作为成员</p>
<p>学生的成员有姓名、考试分数，创建数组存放 3 名老师，通过函数给每个老师及所带的学生赋值</p>
<p>最终打印出老师数据以及老师所带的学生数据。</p>
<p>示例：</p>
<p>C++<br>struct Student<br>{<br>string name;<br>int score;<br>};<br>struct Teacher<br>{<br>string name;<br>Student sArray[5];<br>};</p>
<p>void allocateSpace(Teacher tArray[] , int len)<br>{<br>string tName = “教师”;<br>string sName = “学生”;<br>string nameSeed = “ABCDE”;<br>for (int i = 0; i &lt; len; i++)<br>{<br>tArray[i].name = tName + nameSeed[i];<br>for (int j = 0; j &lt; 5; j++)<br>{<br>tArray[i].sArray[j].name = sName + nameSeed[j];<br>tArray[i].sArray[j].score = rand() % 61 + 40;<br>}<br>}<br>}</p>
<p>void printTeachers(Teacher tArray[], int len)<br>{<br>for (int i = 0; i &lt; len; i++)<br>{<br>cout &lt;&lt; tArray[i].name &lt;&lt; endl;<br>for (int j = 0; j &lt; 5; j++)<br>{<br>cout &lt;&lt; “\t 姓名：” &lt;&lt; tArray[i].sArray[j].name &lt;&lt; “ 分数：” &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;<br>}<br>}<br>}</p>
<p>int main() {</p>
<pre><code>srand((unsigned int)time(NULL)); //随机数种子 头文件 #include &lt;ctime&gt;

Teacher tArray[3]; //老师数组

int len = sizeof(tArray) / sizeof(Teacher);

allocateSpace(tArray, len); //创建数据

printTeachers(tArray, len); //打印数据

system(&quot;pause&quot;);

return 0;</code></pre><p>}<br>8.8.2 案例 2<br>案例描述：</p>
<p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放 5 名英雄。</p>
<p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p>
<p>五名英雄信息如下：</p>
<p>C++<br>{“刘备”,23,”男”},<br>{“关羽”,22,”男”},<br>{“张飞”,20,”男”},<br>{“赵云”,21,”男”},<br>{“貂蝉”,19,”女”},<br>示例：</p>
<p>C++<br>//英雄结构体<br>struct hero<br>{<br>string name;<br>int age;<br>string sex;<br>};<br>//冒泡排序<br>void bubbleSort(hero arr[] , int len)<br>{<br>for (int i = 0; i &lt; len - 1; i++)<br>{<br>for (int j = 0; j &lt; len - 1 - i; j++)<br>{<br>if (arr[j].age &gt; arr[j + 1].age)<br>{<br>hero temp = arr[j];<br>arr[j] = arr[j + 1];<br>arr[j + 1] = temp;<br>}<br>}<br>}<br>}<br>//打印数组<br>void printHeros(hero arr[], int len)<br>{<br>for (int i = 0; i &lt; len; i++)<br>{<br>cout &lt;&lt; “姓名： “ &lt;&lt; arr[i].name &lt;&lt; “ 性别： “ &lt;&lt; arr[i].sex &lt;&lt; “ 年龄： “ &lt;&lt; arr[i].age &lt;&lt; endl;<br>}<br>}</p>
<p>int main() {</p>
<pre><code>struct hero arr[5] =
{
    {&quot;刘备&quot;,23,&quot;男&quot;},
    {&quot;关羽&quot;,22,&quot;男&quot;},
    {&quot;张飞&quot;,20,&quot;男&quot;},
    {&quot;赵云&quot;,21,&quot;男&quot;},
    {&quot;貂蝉&quot;,19,&quot;女&quot;},
};

int len = sizeof(arr) / sizeof(hero); //获取数组元素个数

bubbleSort(arr, len); //排序

printHeros(arr, len); //打印

system(&quot;pause&quot;);

return 0;</code></pre><p>}</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Zhenglin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://9pshr3.coding-pages.com/2023/01/18/A%20first%20look%20at%20C++%20(1)%20copy%204/">http://9pshr3.coding-pages.com/2023/01/18/A%20first%20look%20at%20C++%20(1)%20copy%204/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://9pshr3.coding-pages.com" target="_blank">熊儿老猫的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-8.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="../assets/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/../assets/wechatpay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="../assets/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/../assets/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/18/A%20first%20look%20at%20C++%20(2)%20copy%202/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-7.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">A first look at C++ (2) copy 2</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/18/A%20first%20look%20at%20C++%20(1)%20copy%203/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-7.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">A first look at C++ (1) copy 3</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-8.webp)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Zhenglin Li</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script defer="defer" id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script></div><script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-90},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.3,"opacityOnHover":0.3,"opacity":0.95},"log":false});</script></body></html>