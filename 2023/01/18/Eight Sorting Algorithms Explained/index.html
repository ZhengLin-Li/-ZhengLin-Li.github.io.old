<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Eight Sorting Algorithms Explained | 熊儿老猫的博客</title><meta name="description" content="Eight sorting algorithms in detail (moving picture demonstration idea analysis example code java complexity analysis applicable scenarios) A. Classification 1. internal sorting and external sorting 　I"><meta name="author" content="Zhenglin Li"><meta name="copyright" content="Zhenglin Li"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://9pshr3.coding-pages.com/2023/01/18/Eight%20Sorting%20Algorithms%20Explained/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="Eight Sorting Algorithms Explained"><meta property="og:url" content="http://9pshr3.coding-pages.com/2023/01/18/Eight%20Sorting%20Algorithms%20Explained/"><meta property="og:site_name" content="熊儿老猫的博客"><meta property="og:description" content="Eight sorting algorithms in detail (moving picture demonstration idea analysis example code java complexity analysis applicable scenarios) A. Classification 1. internal sorting and external sorting 　I"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-6.webp"><meta property="article:published_time" content="2023-01-18T12:11:42.957Z"><meta property="article:modified_time" content="2023-01-18T10:49:27.894Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'true'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?0773dcadd0397be86eb74da114bd1757";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2023-01-18 18:49:27'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">42</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#八大排序算法详解（动图演示-思路分析-实例代码-java-复杂度分析-适用场景）"><span class="toc-number">1.</span> <span class="toc-text">八大排序算法详解（动图演示 思路分析 实例代码 java 复杂度分析 适用场景）</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-6.webp)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">熊儿老猫的博客</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Eight Sorting Algorithms Explained</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-18T12:11:42.957Z" title="发表于 2023-01-18 20:11:42">2023-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-18T10:49:27.894Z" title="更新于 2023-01-18 18:49:27">2023-01-18</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>Eight sorting algorithms in detail (moving picture demonstration idea analysis example code java complexity analysis applicable scenarios)</p>
<p>A. Classification 1. internal sorting and external sorting 　<br>Internal sorting: the sorting process of the records to be sorted is stored in the computer’s random memory (to put it simply, it is memory).<br>External sort: sorting process in which the number of records to be sorted is so large that the memory cannot hold all the records at once, so access to the external memory is required in the sorting process.</p>
<ol start="2">
<li>Comparative sorting and non-comparative sorting<br>Comparative sort: The relative order of the elements is determined by comparison, which is also called non-linear time comparative sort because its time complexity cannot exceed O(nlogn).<br>Non-comparative sorting: It does not decide the relative order among elements by comparison, and it can break the lower bound of time based on comparison sorting and run in linear time, so it is also called linear time non-comparative sorting.</li>
</ol>
<p>II. Complexity analysis, algorithm stability and applicable scenarios<br>Stable: If a is in front of b and a=b, a is still in front of b after sorting.<br>Unstable: If a is in front of b and a=b, a may appear after b after sorting.<br>Time complexity: The total number of operations on the sorted data. It reflects what is the pattern of the number of operations when n varies.<br>Space complexity: is a measure of the storage space required to execute the algorithm in the computer, which is also a function of the data size n.</p>
<p>Three, eight sorting algorithms detailed explanation 1.<br>1.1 Moving image demonstration</p>
<p>1.2 Idea analysis</p>
<ol>
<li><p>the first compared with all the numbers behind, if less than (or less than) the first number, the subscript of the smaller number is temporarily stored, after the first trip, the first number, and the temporary storage of the smallest number for exchange, the first number is the smallest (or the largest number)</p>
</li>
<li><p>move the subscript to the second position, the second number compared with all the numbers behind, a trip down, to determine the second smallest (or second largest) number</p>
</li>
</ol>
<p>Repeat the above steps</p>
<p>Until the pointer moves to the penultimate position, determine the penultimate smallest (or penultimate largest) number, then the last number is also determined, the sorting is complete.</p>
<p>1.3 Complexity Analysis</p>
<ol>
<li>regardless of whether the original array is ordered or not, the time complexity is O(n2).</li>
</ol>
<p>Because each number has to be compared with other numbers once, (n-1)2 times, decomposition: n2-2n+1, remove the lower power and constant, leaving n2, so the final time complexity is n2. 2.</p>
<ol start="2">
<li>the space complexity is O(1), because only two auxiliary variables are defined, independent of the size of n, so the space complexity is O(1)</li>
</ol>
<p>1.4 The Java code is as follows.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] n = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">33</span>,<span class="number">27</span>,<span class="number">66</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">88</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> temp,index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="comment">// if greater than, temporarily store the subscript of the smaller number</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(n[index]&gt;n[j])&#123;</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//// takes the smallest number found in one trip down and swaps it with this number</span></span><br><span class="line">            <span class="keyword">if</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                temp = n[i];</span><br><span class="line">                n[i] = n[index];</span><br><span class="line">                n[index] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(n));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>bubble sort<br>2.1 Animations</li>
</ol>
<p>2.2 Idea analysis</p>
<ol>
<li>compare two adjacent numbers, n[i] with n[j+1], if n[i]&gt;n[j+1], then swap even the numbers, **<br>**</li>
</ol>
<p>\2. j++, repeating the above steps, after the first trip, the largest number will be determined in the last place, which is the bubble sort also known as the large (small) number sink</p>
<p>\3. i++, repeat the above steps until the end of i=n-1 and the sorting is completed.</p>
<p>2.3 Complexity Analysis</p>
<ol>
<li>regardless of whether the original array is ordered or not, the time complexity is O(n2).</li>
</ol>
<p>Because each number has to be compared with other numbers once, (n-1)2 times, decomposition: n2+2n-1, remove the low power and constant, leaving n2, so the final time complexity is n2. 2.</p>
<ol start="2">
<li>the space complexity is O(1), because only one auxiliary variable is defined, independent of the size of n, so the space complexity is O(1)</li>
</ol>
<p>2.4 Comparison of selection sort and bubble sort</p>
<p>\1. both have time responsibility of O(n2)</p>
<p>\2. the space complexity is O(1)</p>
<p>\3. The selection sort determines the largest or smallest number from the first one, ensuring that the previous numbers are all ordered and smaller or larger than the following ones.</p>
<p>The bubble sort determines the largest or smallest number from the last, and ensures that the numbers that follow are ordered and are greater or less than the numbers that follow.</p>
<p>2.5 The Java code is as follows</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bubble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] n = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">33</span>,<span class="number">27</span>,<span class="number">66</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">88</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(n[j]&gt;n[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    temp = n[j];</span><br><span class="line">                    n[j] = n[j+<span class="number">1</span>];</span><br><span class="line">                    n[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Direct insertion sort<br>3.1 Action figure demonstration</li>
</ol>
<p>3.2 Idea analysis</p>
<p>For example, to sort from smallest to largest:</p>
<ol>
<li><p>start iterating from the second place.</p>
</li>
<li><p>Compare the current number (the first trip is the second number) with the previous number in order, if the previous number is greater than the current number, then put this number in the position of the current number, the subscript of the current number -1, **<br>**</p>
</li>
<li><p>repeat the above steps until the current number is not greater than a certain number in front of it, at which point, the current number, placed in this position, the</p>
</li>
</ol>
<p>1-3 steps is to ensure that the current number of the preceding numbers are ordered, the purpose of the inner loop is to insert the current number into the preceding ordered sequence</p>
<ol start="4">
<li>repeat the above 3 steps until the last number is traversed, and the last number is inserted into the appropriate position, and the insertion sort is finished.</li>
</ol>
<p>According to the analysis of the idea, the execution flow of each trip is shown in the following figure.</p>
<p>3.3 Complexity Analysis</p>
<ol>
<li>time complexity: the insertion algorithm, which is to ensure that the previous sequence is ordered, only needs to insert the current number into a position in front of it.</li>
</ol>
<p>So if the array is originally ordered, the best-case time complexity of the array is O (n)</p>
<p>If the array happens to be inverted = inverted order, for example, the original array is 5 4 3 2 1, and you want to arrange it from smallest to largest, the number in front of each trip has to be moved backwards, and a total of n-1 + n-2 + … + 2 + 1 = n _ (n-1) / 2 = 0.5 _ n2 - 0.5 * n times, removing the lower powers and coefficients, so the worst-case time complexity is O(n2 )</p>
<p>Average time complexity (n+n2 )/2, so the average time complexity is O(n2)</p>
<ol start="2">
<li>space complexity: insertion sort algorithm, only two variables are needed to temporarily store the current number, and subscript, independent of the size of n, so the space complexity is: O (1)</li>
</ol>
<p>3.4 The Java code is as follows</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] n = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">20</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">49</span>,<span class="number">58</span>,<span class="number">24</span>,<span class="number">578</span>,<span class="number">211</span>,<span class="number">20</span>,<span class="number">214</span>,<span class="number">78</span>,<span class="number">35</span>,<span class="number">125</span>,<span class="number">789</span>,<span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>,j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n.length; i++) &#123;</span><br><span class="line">            temp = n[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">// If the number before the current number is greater than the current number, move the number before it back one position</span></span><br><span class="line">                <span class="keyword">if</span>(n[j-<span class="number">1</span>]&gt;temp)&#123;</span><br><span class="line">                    n[j] = n[j-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// the first number has been moved to the second number, put the current number into the first position, the end of this trip</span></span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">                        n[j-<span class="number">1</span>] = temp;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//If not greater than, put the current number to the position of j, the end of this trip</span></span><br><span class="line"></span><br><span class="line">                    n[j] = temp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(n));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>If the maximum number of digits in the array is n, it is necessary to arrange n times, for example, the maximum number in the array is 3 digits, it is necessary to arrange 3 times.</p>
</li>
<li><p>If there are m numbers in the array, ten m-length arrays tempj (j=0-9) are needed to temporarily store the number of i bits j. For example, the first time, the number of bits 0 will be assigned to the temp0 array, and the number of bits 1 will be assigned to the temp1 array ……</p>
</li>
<li><p>After the allocation, then take out the data from the tempj array in turn, following the first-in-first-out principle, for example, for the array {1, 11, 2, 44, 4}, after the first allocation, temp1={1,11}, temp2={2}, temp4={44, 4}, after taking out the elements in turn {1, 11, 2, 44, 4}, the first trip is over</p>
</li>
<li><p>Loop to n times after the end, sorting is completed</p>
</li>
</ol>
<p>According to the analysis of ideas, the execution flow of each trip is shown as follows.</p>
<p>Sort by base on the array {53, 3, 542, 748, 14, 214, 154, 63, 616}.</p>
<p>6.3 Complexity analysis</p>
<ol>
<li>time complexity: **<br>**</li>
</ol>
<p>Each keyword bucket assignment requires O(n) time complexity, and the new keyword sequence after the assignment requires O(n) time complexity again.</p>
<p>If the data to be sorted can be divided into d keywords, the time complexity of the base sort will be O(d*2n), although d is much smaller than n, so it is still essentially linear.</p>
<p>The coefficient 2 can be omitted, and the time complexity is always O(d*n) because the array needs to be sorted from the individual bits to the maximum number of bits, regardless of whether the array is ordered or not. Where n is the length of the array and d is the maximum number of bits. 2.</p>
<ol start="2">
<li>Space complexity.</li>
</ol>
<p>The space complexity of the base sort is O(n+k), where k is the number of buckets, and n numbers need to be allocated.</p>
<p>6.4 The Java code is as follows</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">33</span>,<span class="number">27</span>,<span class="number">66</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">88</span>&#125;;</span><br><span class="line">        radixSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//find the maximum number of numbers to be ranked</span></span><br><span class="line">        <span class="keyword">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxLength&lt;arr[i])</span><br><span class="line">                maxLength = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find the maximum length based on the maximum number</span></span><br><span class="line">        maxLength = (maxLength+<span class="string">""</span>).length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Array for storing data</span></span><br><span class="line">        <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="comment">// used to record the number of data in each bucket of memory in the temp array</span></span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// used to record the number of i bits of each number</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// used to take the position of the elements to be placed</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//decide the number of times to sort according to the maximum length</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,n=<span class="number">1</span>; i &lt; maxLength; i++,n*=<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                num = arr[j]/n%<span class="number">10</span>;</span><br><span class="line">                temp[num][counts[num]] = arr[j];</span><br><span class="line">                counts[num]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Take the elements from temp and put them back into the arr array</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; counts.length; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">0</span>; j2 &lt; counts[j]; j2++) &#123;</span><br><span class="line">                    arr[index] = temp[j][j2];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                counts[j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>Hill (shell) sorting<br>7.1 Action figure demonstration</li>
</ol>
<p>7.2 Idea Analysis</p>
<p>Hill sort is to group the records by certain increments of the subscript, and use the direct insertion sort algorithm to sort each group; as the increment decreases, each group contains more and more keywords, and when the increment decreases to 1, the whole file is divided into a group, and the algorithm terminates.</p>
<p>The simple insertion sort is very conventional, regardless of the distribution of the array, it still compares, moves and inserts the elements step by step, for example, [5,4,3,2,1,0] is a reverse order sequence, the 0 at the end of the array is very hard to return to the first position, it takes n-1 times to compare and move the elements.</p>
<p>Hill sort uses a jump grouping strategy in the array, dividing the array elements into groups by a certain increment, then grouping them for insertion sorting, and then gradually reducing the increment and continuing insertion sorting by group until the increment is 1. By this strategy, the whole array is basically ordered from the macroscopic point of view in the initial stage, with the smaller ones basically in the front and the larger ones basically in the back. Then the increment is reduced to increment 1, which in most cases requires only fine tuning and does not involve too much data movement.</p>
<p>Coming to the basic steps of Hill sort, here the increment gap=length/2 is chosen and the narrowing increment continues with gap = gap/2. This increment selection can be represented by a sequence, {n/2,(n/2)/2…1}, called increment sequence. The selection and proof of the increment sequence of the Hill sort is a mathematical challenge. This increment sequence chosen is more commonly used and is the increment suggested by Hill, called the Hill increment, but in fact this increment sequence is not optimal. This is done here as an example using the Hill increment.</p>
<p>7.3 Complexity Analysis</p>
<ol>
<li>Time complexity: In the worst case, every two numbers are compared and swapped once, so the time complexity in the worst case is O(n2), and in the best case, the arrays are ordered and do not need to be swapped but only compared, so the time complexity in the best case is O(n).</li>
</ol>
<p>The average time complexity of Hill sort is O(n1.3) after a lot of research (I don’t know how this came about, but it is stated in books and blogs, and I didn’t find a specific basis for it,,).</p>
<ol start="2">
<li>space complexity: Hill sort, only one variable is needed for the exchange of two numbers, independent of the size of n, so the space complexity is: O(1).</li>
</ol>
<p>7.4 The Java code is as follows</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">33</span>,<span class="number">27</span>,<span class="number">66</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">88</span>&#125;;</span><br><span class="line">        shellSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="comment">//control the incremental sequence, the last trip when the incremental sequence is 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length/<span class="number">2</span>; i &gt;<span class="number">0</span>; i/=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//find the position of the last number in each comparison sequence according to the incremental sequence</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">//execute the insertion sort forward in order based on the position of the last number in the comparison sequence</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j-i; k &gt;= <span class="number">0</span>; k-= i) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[k]&gt;arr[k+i])&#123;</span><br><span class="line">                        temp = arr[k];</span><br><span class="line">                        arr[k] = arr[k+i];</span><br><span class="line">                        arr[k+i] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>Heap sort<br>8.1 Action figure demonstration</li>
</ol>
<p>8.2 Idea Analysis</p>
<p>First, let’s understand the concept of heap: a heap is a complete binary tree with the following properties: the value of each node is greater than or equal to the value of its left and right child nodes, called a big top heap; or the value of each node is less than or equal to the value of its left and right child nodes, called a small top heap. The figure below.</p>
<p>Also, we number the nodes in the heap by level, and mapping this logical structure to an array looks like the following</p>
<p>The array is logically a heap structure, and we use a simple formula to describe the definition of a heap as follows</p>
<p>Big top heap: arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</p>
<p>Small top heap: arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</p>
<p>Understand these definitions. Next, look at the basic idea of heap sort and the basic steps.</p>
<p>Heap Sort Basic Idea and Steps</p>
<p>The basic idea of heap sort is that the sequence to be sorted is constructed as a big top heap, at which point the maximum value of the whole sequence is the root node at the top of the heap. It is exchanged with the end element, and the end is the maximum value. Then the remaining n-1 elements are reconstructed into a heap, which gives the next smallest value of n elements. This is repeated to obtain an ordered sequence</p>
<p>Step 1 Construct the initial heap. Construct the given unordered sequence into a big-top heap (generally a big-top heap for ascending order and a small-top heap for descending order).</p>
<p>a. Assume that the structure of the given unordered sequence is as follows</p>
<ol start="2">
<li><p>At this point, we start from the last non-leaf node (leaf node naturally does not need to be adjusted, the first non-leaf node arr.length/2-1=5/2-1=1, which is the following 6 nodes), from left to right, from bottom to top to be adjusted.</p>
</li>
<li><p>Find the second non-leaf node 4. Since the 9 element in [4,9,8] is the largest, 4 and 9 are swapped.</p>
</li>
</ol>
<p>At this point, the swap leads to confusion in the structure of the child root [4,5,6], and continues to adjust, with 6 being the largest in [4,5,6], swapping 4 and 6.</p>
<p>At this point, we have constructed a sequence without a sequence into a big top heap.</p>
<p>Step 2 Swap the top element of the heap with the end element so that the end element is the largest. Then continue adjusting the heap and swap the top element with the end element to get the second largest element. This is repeated for swapping, rebuilding, and swapping.</p>
<p>a. Swap the top element of the heap 9 with the end element 4</p>
<p>b. Restructure so that it continues to satisfy the heap definition</p>
<p>c. Then swap the top element 8 with the end element 5 to get the second largest element 8.</p>
<p>The process continues with the adjustment and exchange, and so on, eventually making the whole sequence ordered.</p>
<p>To briefly summarize the basic idea of heap sort.</p>
<p>a. Build the unordered sequence into a heap, and choose the big top heap or small top heap according to the ascending and descending requirements;</p>
<p>b. Exchange the top element of the heap with the end element, and “sink” the largest element to the end of the array;</p>
<p>c. Re-adjust the structure to meet the definition of the heap, and then continue to exchange the top element of the heap with the current end element, and repeatedly perform the adjustment + exchange steps until the entire sequence is ordered.</p>
<p>8.3 Complexity Analysis</p>
<ol>
<li><p>time complexity: heap sort is a kind of selection sort, and the whole mainly consists of two parts: constructing the initial heap + swapping the top and end elements and rebuilding the heap. The complexity of constructing the initial heap is O(n) by derivation, in the process of swapping and rebuilding the heap, n-1 exchanges are required, and in the process of rebuilding the heap, according to the nature of complete binary trees, [log2(n-1),log2(n-2)…1] decreases gradually and is approximated by nlogn. Therefore, the time complexity of heap sorting is O( nlogn) level. 2.</p>
</li>
<li><p>space complexity: heap sort does not need any auxiliary arrays, but only one auxiliary variable, and the space occupied is a constant independent of n, so the space complexity is O(1).</p>
</li>
</ol>
<p>8.4 The Java code is as follows</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">duipaixu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="comment">// Build the big top heap starting from the last non-leaf node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length/<span class="number">2</span>-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maximumHeap(i,arr,length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// swap with the root node starting from the smallest leaf node and reconstruct the maximum heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="comment">// System.out.println(Arrays.toString(arr));</span></span><br><span class="line">            swap(arr,<span class="number">0</span>,i);</span><br><span class="line">            length--;</span><br><span class="line">            maximumHeap(<span class="number">0</span>,arr,length);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Build the big top heap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maximumHeap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i*<span class="number">2</span>+<span class="number">1</span>; j &lt; length; j=j*<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// if the right child is greater than the do child, then point to the right child</span></span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;length &amp;&amp; arr[j+<span class="number">1</span>]&gt;arr[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If the largest child is greater than the current node, assign the larger child to the current node, modify the current node to be its larger child node, and go down.</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;temp)&#123;</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//put temp in the final position</span></span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//swap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八大排序算法详解（动图演示-思路分析-实例代码-java-复杂度分析-适用场景）"><a href="#八大排序算法详解（动图演示-思路分析-实例代码-java-复杂度分析-适用场景）" class="headerlink" title="八大排序算法详解（动图演示 思路分析 实例代码 java 复杂度分析 适用场景）"></a>八大排序算法详解（动图演示 思路分析 实例代码 java 复杂度分析 适用场景）</h1><p>一、分类 1.内部排序和外部排序　<br>内部排序：待排序记录存放在计算机随机存储器中（说简单点，就是内存）进行的排序过程。<br>外部排序：待排序记录的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中需要对外存进行访问的排序过程。</p>
<p>2.比较类排序和非比较排序<br>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 O(nlogn)，因此也称为非线性时间比较类排序。<br>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p>
<p>二、复杂度分析，算法稳定性和适用场景<br>稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面。<br>不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面。<br>时间复杂度：对排序数据的总的操作次数。反映当 n 变化时，操作次数呈现什么规律。<br>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模 n 的函数。</p>
<p>三、八大排序算法详解 1.选择排序<br>1.1 动图演示</p>
<p>1.2 思路分析</p>
<ol>
<li><p>第一个跟后面的所有数相比，如果小于（或小于）第一个数的时候，暂存较小数的下标，第一趟结束后，将第一个数，与暂存的那个最小数进行交换，第一个数就是最小（或最大的数）</p>
</li>
<li><p>下标移到第二位，第二个数跟后面的所有数相比，一趟下来，确定第二小（或第二大）的数</p>
</li>
</ol>
<p>重复以上步骤</p>
<p>直到指针移到倒数第二位，确定倒数第二小（或倒数第二大）的数，那么最后一位也就确定了，排序完成。</p>
<p>1.3 复杂度分析</p>
<ol>
<li>不管原始数组是否有序，时间复杂度都是 O（n2），</li>
</ol>
<p>因为没一个数都要与其他数比较一次，（n-1）2 次，分解：n2-2n+1, 去掉低次幂和常数，剩下 n2,所以最后的时间复杂度是 n2</p>
<ol start="2">
<li>空间复杂度是 O（1）,因为只定义了两个辅助变量，与 n 的大小无关，所以空间复杂度为 O（1）</li>
</ol>
<p>1.4 Java 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] n = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">33</span>,<span class="number">27</span>,<span class="number">66</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">88</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> temp,index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            index=i;</span><br><span class="line">            <span class="comment">//如果大于，暂存较小的数的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;n.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(n[index]&gt;n[j])&#123;</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">////将一趟下来求出的最小数，与这个数交换</span></span><br><span class="line">            <span class="keyword">if</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                temp = n[i];</span><br><span class="line">                n[i] = n[index];</span><br><span class="line">                n[index] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(n));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>冒泡排序<br>2.1 动图演示</li>
</ol>
<p>2.2 思路分析</p>
<ol>
<li>相邻两个数两两相比，n[i]跟 n[j+1]比，如果 n[i]&gt;n[j+1]，则将连个数进行交换，**<br>**</li>
</ol>
<p>\2. j++, 重复以上步骤，第一趟结束后，最大数就会被确定在最后一位，这就是冒泡排序又称大（小）数沉底，</p>
<p>\3. i++,重复以上步骤，直到 i=n-1 结束，排序完成。</p>
<p>2.3 复杂度分析</p>
<ol>
<li>不管原始数组是否有序，时间复杂度都是 O（n2），</li>
</ol>
<p>因为没一个数都要与其他数比较一次，（n-1）2 次，分解：n2+2n-1, 去掉低次幂和常数，剩下 n2,所以最后的时间复杂度是 n2</p>
<ol start="2">
<li>空间复杂度是 O（1）,因为只定义了一个辅助变量，与 n 的大小无关，所以空间复杂度为 O（1）</li>
</ol>
<p>2.4 选择排序和冒泡排序的比较</p>
<p>\1. 时间负责度都是 O（n2）</p>
<p>\2. 空间复杂度都是 O（1）</p>
<p>\3. 选择排序是从第一位开始确定最大或最小的数，保证前面的数都是有序的，且都比后面的数小或大，</p>
<p>冒泡排序是从最后一位开始确定最大或最小的数，保证后面的数都是有序的且都大于或小于前面的数。</p>
<p>2.5 Java 代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 冒泡 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] n = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">33</span>,<span class="number">27</span>,<span class="number">66</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">88</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;n.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(n[j]&gt;n[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    temp = n[j];</span><br><span class="line">                    n[j] = n[j+<span class="number">1</span>];</span><br><span class="line">                    n[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>直接插入排序<br>3.1 动图演示</li>
</ol>
<p>3.2 思路分析</p>
<p>例如从小到大排序:</p>
<ol>
<li><p>从第二位开始遍历，</p>
</li>
<li><p>当前数（第一趟是第二位数）与前面的数依次比较，如果前面的数大于当前数，则将这个数放在当前数的位置上，当前数的下标-1，**<br>**</p>
</li>
<li><p>重复以上步骤，直到当前数不大于前面的某一个数为止，这时，将当前数，放到这个位置，</p>
</li>
</ol>
<p>1-3 步就是保证当前数的前面的数都是有序的，内层循环的目的就是将当前数插入到前面的有序序列里</p>
<ol start="4">
<li>重复以上 3 步，直到遍历到最后一位数，并将最后一位数插入到合适的位置，插入排序结束。</li>
</ol>
<p>根据思路分析，每一趟的执行流程如下图所示：</p>
<p>3.3 复杂度分析</p>
<ol>
<li>时间复杂度：插入算法，就是保证前面的序列是有序的，只需要把当前数插入前面的某一个位置即可。</li>
</ol>
<p>所以如果数组本来就是有序的，则数组的最好情况下时间复杂度为 O（n）</p>
<p>如果数组恰好是倒=倒序，比如原始数组是 5 4 3 2 1，想要排成从小到大，则每一趟前面的数都要往后移，一共要执行 n-1 + n-2 + … + 2 + 1 = n _ (n-1) / 2 = 0.5 _ n2 - 0.5 * n 次，去掉低次幂及系数，所以最坏情况下时间复杂度为 O（n2）</p>
<p>平均时间复杂度(n+n2 )/2，所以平均时间复杂度为 O（n2）</p>
<ol start="2">
<li>空间复杂度：插入排序算法，只需要两个变量暂存当前数，以及下标，与 n 的大小无关，所以空间复杂度为：O（1）</li>
</ol>
<p>3.4 Java 代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] n = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">20</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">49</span>,<span class="number">58</span>,<span class="number">24</span>,<span class="number">578</span>,<span class="number">211</span>,<span class="number">20</span>,<span class="number">214</span>,<span class="number">78</span>,<span class="number">35</span>,<span class="number">125</span>,<span class="number">789</span>,<span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>,j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n.length; i++) &#123;</span><br><span class="line">            temp = n[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;<span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">//如果当前数前面的数大于当前数，则把前面的数向后移一个位置</span></span><br><span class="line">                <span class="keyword">if</span>(n[j-<span class="number">1</span>]&gt;temp)&#123;</span><br><span class="line">                    n[j] = n[j-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//第一个数已经移到第二个数，将当前数放到第一个位置，这一趟结束</span></span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">                        n[j-<span class="number">1</span>] = temp;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果不大于，将当前数放到j的位置，这一趟结束</span></span><br><span class="line"></span><br><span class="line">                    n[j] = temp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(n));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>快速排序<br>4.1 动图演示</li>
</ol>
<p>4.2 思路分析</p>
<p>快速排序的思想就是，选一个数作为基数（这里我选的是第一个数），大于这个基数的放到右边，小于这个基数的放到左边，等于这个基数的数可以放到左边或右边，看自己习惯，这里我是放到了左边，</p>
<p>一趟结束后，将基数放到中间分隔的位置，第二趟将数组从基数的位置分成两半，分割后的两个的数组继续重复以上步骤，选基数，将小数放在基数左边，将大数放到基数的右边，在分割数组，，，直到数组不能再分为止，排序结束。</p>
<p>例如从小到大排序:</p>
<ol>
<li>第一趟，第一个数为基数 temp，设置两个指针 left = 0，right = n.length，</li>
</ol>
<p>① 从 right 开始与基数 temp 比较，如果 n[right]&gt;基数 temp，则 right 指针向前移一位，继续与基数 temp 比较，直到不满足 n[right]&gt;基数 temp</p>
<p>② 将 n[right]赋给 n[left]</p>
<p>③ 从 left 开始与基数 temp 比较，如果 n[left]&lt;=基数 temp，则 left 指针向后移一位，继续与基数 temp 比较，直到不满足 n[left]&lt;=基数 temp</p>
<p>④ 将 n[left]赋给 n[rigth]</p>
<p>⑤ 重复 ①-④ 步，直到 left==right 结束，将基数 temp 赋给 n[left]</p>
<ol start="2">
<li><p>第二趟，将数组从中间分隔，每个数组再进行第 1 步的操作，然后再将分隔后的数组进行分隔再快排，</p>
</li>
<li><p>递归重复分隔快排，直到数组不能再分，也就是只剩下一个元素的时候，结束递归，排序完成</p>
</li>
</ol>
<p>根据思路分析，第一趟的执行流程如下图所示：</p>
<p>4.3 复杂度分析</p>
<ol>
<li>时间复杂度：</li>
</ol>
<p>最坏情况就是每一次取到的元素就是数组中最小/最大的，这种情况其实就是冒泡排序了(每一次都排好一个元素的顺序)</p>
<p>这种情况时间复杂度就好计算了，就是冒泡排序的时间复杂度：T[n] = n * (n-1) = n^2 + n;</p>
<p>最好情况下是 O(nlog2n)，推导过程如下：</p>
<p>（递归算法的时间复杂度公式：T[n] = aT[n/b] + f(n) ）</p>
<p>所以平均时间复杂度为 O（nlog2n）</p>
<ol start="2">
<li>空间复杂度：</li>
</ol>
<p>快速排序使用的空间是 O(1)的，也就是个常数级；而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据：</p>
<p>最优的情况下空间复杂度为:O(log2n)；每一次都平分数组的情况</p>
<p>最差的情况下空间复杂度为：O( n )；退化为冒泡排序的情况</p>
<p>所以平均空间复杂度为 O（log2n）</p>
<p>4.4 Java 代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">quick</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">33</span>,<span class="number">27</span>,<span class="number">66</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">88</span>&#125;;</span><br><span class="line"><span class="comment">//        int[] arr = new int[]&#123;1,3,2&#125;;</span></span><br><span class="line">        f(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//直到start&gt;=end时结束递归</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = start;</span><br><span class="line">            <span class="keyword">int</span> right = end;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[start];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//右面的数字大于标准数时，右边的数的位置不变，指针向左移一个位置</span></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[right]&gt;temp)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//右边的数字及下标小于或等于基本数，将右边的数放到左边</span></span><br><span class="line">                <span class="keyword">if</span>(left&lt;right) &#123;</span><br><span class="line">                     arr[left] = arr[right];</span><br><span class="line">                     left++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">////左边的数字小于或等于标准数时，左边的数的位置不变，指针向右移一个位置</span></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[left]&lt;=temp)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//左边的数字大于基本数，将左边的数放到右边</span></span><br><span class="line">                arr[right] = arr[left];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一趟循环结束，此时left=right，将基数放到这个重合的位置，</span></span><br><span class="line">            arr[left] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将数组从left位置分为两半，继续递归下去进行排序</span></span><br><span class="line">            f(arr,start,left);</span><br><span class="line">            f(arr,left+<span class="number">1</span>,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>归并排序<br>5.1 动图演示</li>
</ol>
<p>5.2 思路分析</p>
<p>归并排序就是递归得将原始数组递归对半分隔，直到不能再分（只剩下一个元素）后，开始从最小的数组向上归并排序</p>
<p>\1. 向上归并排序的时候，需要一个暂存数组用来排序，</p>
<p>\2. 将待合并的两个数组，从第一位开始比较，小的放到暂存数组，指针向后移，</p>
<p>\3. 直到一个数组空，这时，不用判断哪个数组空了，直接将两个数组剩下的元素追加到暂存数组里，</p>
<p>\4. 再将暂存数组排序后的元素放到原数组里，两个数组合成一个，这一趟结束。</p>
<p>根据思路分析，每一趟的执行流程如下图所示：</p>
<p>5.3 复杂度分析</p>
<ol>
<li>时间复杂度：递归算法的时间复杂度公式：T[n] = aT[n/b] + f(n) **<br>**</li>
</ol>
<p>无论原始数组是否是有序的，都要递归分隔并向上归并排序，所以时间复杂度始终是 O（nlog2n）</p>
<ol start="2">
<li>空间复杂度：</li>
</ol>
<p>每次两个数组进行归并排序的时候，都会利用一个长度为 n 的数组作为辅助数组用于保存合并序列，所以空间复杂度为 O（n）</p>
<p>5.4 Java 代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        merge(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> center = (high+low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="comment">//递归，直到low==high，也就是数组已不能再分了，</span></span><br><span class="line">            merge(arr,low,center);</span><br><span class="line">            merge(arr,center+<span class="number">1</span>,high);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当数组不能再分，开始归并排序</span></span><br><span class="line">            mergeSort(arr,low,center,high);</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> low,<span class="keyword">int</span> center,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="comment">//用于暂存排序后的数组的临时数组</span></span><br><span class="line">        <span class="keyword">int</span>[] tempArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">int</span> i = low,j = center+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//临时数组的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环遍历两个数组的数字，将小的插入到临时数组里</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=center &amp;&amp; j&lt;= high)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//左边数组的数小，插入到新数组</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;arr[j])&#123;</span><br><span class="line">                tempArr[index] = arr[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//右边数组的数小，插入到新数组</span></span><br><span class="line">                tempArr[index] = arr[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理左半边数组多余的数据，将左半边多余的数据直接追加的临时数组的后面</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=center)&#123;</span><br><span class="line">            tempArr[index] = arr[i];</span><br><span class="line">            i++;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理右半边数组多余的数据，将右半边多余的数据直接追加的临时数组的后面</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;= high)&#123;</span><br><span class="line">            tempArr[index] = arr[j];</span><br><span class="line">            j++;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将临时数组中的数据重新放进原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; index; k++) &#123;</span><br><span class="line">            arr[k+low] = tempArr[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>基数排序<br>6.1 动图演示</li>
</ol>
<p>6.2 思路分析</p>
<p>基数排序第 i 趟将待排数组里的每个数的 i 位数放到 tempj（j=1-10）队列中，然后再从这十个队列中取出数据，重新放到原数组里，直到 i 大于待排数的最大位数。</p>
<p>1.数组里的数最大位数是 n 位，就需要排 n 趟，例如数组里最大的数是 3 位数，则需要排 3 趟。</p>
<p>2.若数组里共有 m 个数，则需要十个长度为 m 的数组 tempj（j=0-9）用来暂存 i 位上数为 j 的数，例如，第 1 趟，各位数为 0 的会被分配到 temp0 数组里，各位数为 1 的会被分配到 temp1 数组里……</p>
<p>3.分配结束后，再依次从 tempj 数组中取出数据，遵循先进先进原则，例如对数组{1，11，2，44，4}，进行第 1 趟分配后，temp1={1,11}，temp2={2}，temp4={44，4}，依次取出元素后{1，11，2，44，4}，第一趟结束</p>
<p>4.循环到 n 趟后结束，排序完成</p>
<p>根据思路分析，每一趟的执行流程如下图所示：</p>
<p>通过基数排序对数组{53, 3, 542, 748, 14, 214, 154, 63, 616}：</p>
<p>6.3 复杂度分析</p>
<ol>
<li>时间复杂度：**<br>**</li>
</ol>
<p>每一次关键字的桶分配都需要 O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要 O(n)的时间复杂度。</p>
<p>假如待排数据可以分为 d 个关键字，则基数排序的时间复杂度将是 O(d*2n) ，当然 d 要远远小于 n，因此基本上还是线性级别的。</p>
<p>系数 2 可以省略，且无论数组是否有序，都需要从个位排到最大位数，所以时间复杂度始终为 O(d*n) 。其中，n 是数组长度，d 是最大位数。</p>
<ol start="2">
<li>空间复杂度：</li>
</ol>
<p>基数排序的空间复杂度为 O(n+k)，其中 k 为桶的数量，需要分配 n 个数。</p>
<p>6.4 Java 代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">33</span>,<span class="number">27</span>,<span class="number">66</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">88</span>&#125;;</span><br><span class="line">        radixSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//求出待排数的最大数</span></span><br><span class="line">        <span class="keyword">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxLength&lt;arr[i])</span><br><span class="line">                maxLength = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据最大数求最大长度</span></span><br><span class="line">        maxLength = (maxLength+<span class="string">""</span>).length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用于暂存数据的数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="comment">//用于记录temp数组中每个桶内存的数据的数量</span></span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//用于记录每个数的i位数</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//用于取的元素需要放的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据最大长度决定排序的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,n=<span class="number">1</span>; i &lt; maxLength; i++,n*=<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                num = arr[j]/n%<span class="number">10</span>;</span><br><span class="line">                temp[num][counts[num]] = arr[j];</span><br><span class="line">                counts[num]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从temp中取元素重新放到arr数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; counts.length; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">0</span>; j2 &lt; counts[j]; j2++) &#123;</span><br><span class="line">                    arr[index] = temp[j][j2];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                counts[j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>希尔（shell）排序<br>7.1 动图演示</li>
</ol>
<p>7.2 思路分析</p>
<p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。</p>
<p>简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的 0 要回到首位置很是费劲，比较和移动元素均需 n-1 次。</p>
<p>而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为 1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为 1 时，其实多数情况下只需微调即可，不会涉及过多的数据移动。</p>
<p>来看下希尔排序的基本步骤，在此选择增量 gap=length/2，缩小增量继续以 gap = gap/2 的方式，这种增量选择可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处做示例使用希尔增量。</p>
<p>7.3 复杂度分析</p>
<ol>
<li>时间复杂度：最坏情况下，每两个数都要比较并交换一次，则最坏情况下的时间复杂度为 O（n2）, 最好情况下，数组是有序的，不需要交换，只需要比较，则最好情况下的时间复杂度为 O（n）。</li>
</ol>
<p>经大量人研究，希尔排序的平均时间复杂度为 O（n1.3）（这个我也不知道咋来的，书上和博客上都这样说，也没找到个具体的依据，，，）。</p>
<ol start="2">
<li>空间复杂度：希尔排序，只需要一个变量用于两数交换，与 n 的大小无关，所以空间复杂度为：O（1）。</li>
</ol>
<p>7.4 Java 代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">33</span>,<span class="number">27</span>,<span class="number">66</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">88</span>&#125;;</span><br><span class="line">        shellSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="comment">//控制增量序列,增量序列为1的时候为最后一趟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length/<span class="number">2</span>; i &gt;<span class="number">0</span>; i/=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//根据增量序列，找到每组比较序列的最后一个数的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">//根据该比较序列的最后一个数的位置，依次向前执行插入排序</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j-i; k &gt;=<span class="number">0</span>; k-=i) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[k]&gt;arr[k+i])&#123;</span><br><span class="line">                        temp = arr[k];</span><br><span class="line">                        arr[k]  = arr[k+i];</span><br><span class="line">                        arr[k+i] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>堆排序<br>8.1 动图演示</li>
</ol>
<p>8.2 思路分析</p>
<p>先来了解下堆的相关概念：堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</p>
<p>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p>
<p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p>
<p>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</p>
<p>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</p>
<p>了解了这些定义。接下来看看堆排序的基本思想及基本步骤：</p>
<p>堆排序基本思想及步骤</p>
<p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了</p>
<p>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</p>
<p>a.假设给定无序序列结构如下</p>
<p>2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。</p>
<p>4.找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换。</p>
<p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6。</p>
<p>此时，我们就将一个无需序列构造成了一个大顶堆。</p>
<p>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</p>
<p>a.将堆顶元素 9 和末尾元素 4 进行交换</p>
<p>b.重新调整结构，使其继续满足堆定义</p>
<p>c.再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.</p>
<p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p>
<p>再简单总结下堆排序的基本思路：</p>
<p>a.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p>
<p>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</p>
<p>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p>
<p>8.3 复杂度分析</p>
<ol>
<li><p>时间复杂度：堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为 O(n)，在交换并重建堆的过程中，需交换 n-1 次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为 nlogn。所以堆排序时间复杂度最好和最坏情况下都是 O(nlogn)级。</p>
</li>
<li><p>空间复杂度：堆排序不要任何辅助数组，只需要一个辅助变量，所占空间是常数与 n 无关，所以空间复杂度为 O(1)。</p>
</li>
</ol>
<p>8.4 Java 代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">duipaixu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="comment">//从最后一个非叶节点开始构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length/<span class="number">2</span>-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            maximumHeap(i,arr,length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从最小的叶子节点开始与根节点进行交换并重新构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">            swap(arr,<span class="number">0</span>,i);</span><br><span class="line">            length--;</span><br><span class="line">            maximumHeap(<span class="number">0</span>,arr,length);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maximumHeap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i*<span class="number">2</span>+<span class="number">1</span>; j &lt; length; j=j*<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果右孩子大于做孩子，则指向右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;length &amp;&amp; arr[j+<span class="number">1</span>]&gt;arr[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果最大的孩子大于当前节点，则将大孩子赋给当前节点，修改当前节点为其大孩子节点，再向下走。</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;temp)&#123;</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将temp放到最终位置</span></span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Zhenglin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://9pshr3.coding-pages.com/2023/01/18/Eight%20Sorting%20Algorithms%20Explained/">http://9pshr3.coding-pages.com/2023/01/18/Eight%20Sorting%20Algorithms%20Explained/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://9pshr3.coding-pages.com" target="_blank">熊儿老猫的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-6.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="../assets/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/../assets/wechatpay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="../assets/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/../assets/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/18/HTTP123/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-6.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HTTP123</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/18/A%20first%20look%20at%20C++%20(9)/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-6.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">A first look at C++ (9)</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-6.webp)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Zhenglin Li</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script defer="defer" id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script></div><script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-90},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.3,"opacityOnHover":0.3,"opacity":0.95},"log":false});</script></body></html>