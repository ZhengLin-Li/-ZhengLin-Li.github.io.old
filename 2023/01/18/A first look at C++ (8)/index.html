<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>A first look at C++ (8) | 熊儿老猫的博客</title><meta name="description" content="c++ first lookC++ operator overloading (easy to understand)Operator overloading is the process of redefining existing operators and giving them another function to suit different data types. You can r"><meta name="author" content="Zhenglin Li"><meta name="copyright" content="Zhenglin Li"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://9pshr3.coding-pages.com/2023/01/18/A%20first%20look%20at%20C++%20(8)/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="A first look at C++ (8)"><meta property="og:url" content="http://9pshr3.coding-pages.com/2023/01/18/A%20first%20look%20at%20C++%20(8)/"><meta property="og:site_name" content="熊儿老猫的博客"><meta property="og:description" content="c++ first lookC++ operator overloading (easy to understand)Operator overloading is the process of redefining existing operators and giving them another function to suit different data types. You can r"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-6.webp"><meta property="article:published_time" content="2023-01-18T12:11:43.031Z"><meta property="article:modified_time" content="2023-01-18T11:10:50.749Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'true'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?0773dcadd0397be86eb74da114bd1757";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2023-01-18 19:10:50'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">42</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#c-first-look"><span class="toc-number">1.</span> <span class="toc-text">c++ first look</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-operator-overloading-easy-to-understand"><span class="toc-number">2.</span> <span class="toc-text">C++ operator overloading (easy to understand)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#The-difference-between-new-delete-and-malloc-free-in-C"><span class="toc-number">3.</span> <span class="toc-text">The difference between new&#x2F;delete and malloc&#x2F;free in C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Explanation-of-iostream-and-using-namespace-std"><span class="toc-number">4.</span> <span class="toc-text">Explanation of iostream and using namespace std</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Synchronous-and-Asynchronous"><span class="toc-number">5.</span> <span class="toc-text">Synchronous and Asynchronous</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Classes-and-objects"><span class="toc-number">6.</span> <span class="toc-text">Classes and objects</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#A-different-experience-writing-C-programs-with-plain-text-command-line"><span class="toc-number">7.</span> <span class="toc-text">A different experience, writing C++ programs with plain text command line</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#New-features-of-c"><span class="toc-number">8.</span> <span class="toc-text">New features of c++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Generics-and-templates"><span class="toc-number">9.</span> <span class="toc-text">Generics and templates</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-language-operators-and-amp-operators"><span class="toc-number">10.</span> <span class="toc-text">C language * operators and &amp; operators</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Understand-Encapsulation"><span class="toc-number">11.</span> <span class="toc-text">Understand Encapsulation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Use-of-classes-and-objects"><span class="toc-number">12.</span> <span class="toc-text">Use of classes and objects</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Code-Reuse"><span class="toc-number">13.</span> <span class="toc-text">Code Reuse</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Off-topic"><span class="toc-number">14.</span> <span class="toc-text">Off-topic</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Template"><span class="toc-number">15.</span> <span class="toc-text">Template</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-初探"><span class="toc-number">16.</span> <span class="toc-text">c++初探</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-运算符重载-简单易懂"><span class="toc-number">17.</span> <span class="toc-text">C++运算符重载(简单易懂)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-中-new-delete-和-malloc-free-的区别"><span class="toc-number">18.</span> <span class="toc-text">C++中 new&#x2F;delete 和 malloc&#x2F;free 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关于-iostream-与-using-namespace-std-的解析"><span class="toc-number">19.</span> <span class="toc-text">关于 iostream 与 using namespace std 的解析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-定义结构体"><span class="toc-number">20.</span> <span class="toc-text">c++定义结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#同步与异步"><span class="toc-number">21.</span> <span class="toc-text">同步与异步</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类和对象"><span class="toc-number">22.</span> <span class="toc-text">类和对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不一样的体验，用纯文本命令行写-C-程序"><span class="toc-number">23.</span> <span class="toc-text">不一样的体验，用纯文本命令行写 C++程序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-的新特性"><span class="toc-number">24.</span> <span class="toc-text">c++的新特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型和模板"><span class="toc-number">25.</span> <span class="toc-text">泛型和模板</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-语言-运算符和-amp-运算符"><span class="toc-number">26.</span> <span class="toc-text">C 语言*运算符和&amp;运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#理解封装"><span class="toc-number">27.</span> <span class="toc-text">理解封装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用类和对象"><span class="toc-number">28.</span> <span class="toc-text">使用类和对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#代码复用"><span class="toc-number">29.</span> <span class="toc-text">代码复用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#题外话"><span class="toc-number">30.</span> <span class="toc-text">题外话</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#模板（Template）"><span class="toc-number">31.</span> <span class="toc-text">模板（Template）</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-6.webp)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">熊儿老猫的博客</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">A first look at C++ (8)</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-18T12:11:43.031Z" title="发表于 2023-01-18 20:11:43">2023-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-18T11:10:50.749Z" title="更新于 2023-01-18 19:10:50">2023-01-18</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>85分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="c-first-look"><a href="#c-first-look" class="headerlink" title="c++ first look"></a>c++ first look</h1><h1 id="C-operator-overloading-easy-to-understand"><a href="#C-operator-overloading-easy-to-understand" class="headerlink" title="C++ operator overloading (easy to understand)"></a>C++ operator overloading (easy to understand)</h1><p>Operator overloading is the process of redefining existing operators and giving them another function to suit different data types.</p>
<p>You can redefine or overload most of C++’s built-in operators. For example, +, -, *, /, and</p>
<p>++, -, &gt;&gt;, &lt;&lt;, and so on, so that you can use custom types of operators.</p>
<p>Basic format of operator overloading<br>An overloaded operator is a function with a special name, and the function name is defined by the keyword operator and</p>
<p>followed by the operator symbol to be overloaded. Like other functions, overloaded operators have a</p>
<p>return type and a list of arguments.</p>
<p>Point operator+(const Point &amp;);</p>
<p>There are two types of operator overloading: in-class overloading (operator overloaded functions as members of the class) and out-of-class overloading (operator overloaded functions as friend functions of the class)</p>
<p>In-class overloading</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point()&#123;&#125;;</span><br><span class="line">    Point (<span class="keyword">int</span> x, <span class="keyword">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;a)&#123; <span class="comment">//in-class overloading, operator overloading function as a member of the class</span></span><br><span class="line">        Point ret;</span><br><span class="line">        ret.x = <span class="keyword">this</span>-&gt;x + a.x;</span><br><span class="line">        ret.y = <span class="keyword">this</span>-&gt;y + a.y;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point a(2,4),b(5,3);</span><br><span class="line">    Point c = a + b;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; <span class="string">"x :"</span> &lt;&lt; c.x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"y :"</span> &lt;&lt; c.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When the above code is compiled and executed, it produces the following results.</p>
<p>x : 7</p>
<p>y: 7</p>
<p>When operator overloading is intra-class overloading, the operator overloaded function is used as a member function of the class, in the case of the above code a + b is equivalent to a object calling the + method and passing in the arguments when b object</p>
<p>Out-of-class overloading</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point()&#123;&#125;;</span><br><span class="line">    Point (<span class="keyword">int</span> x, <span class="keyword">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;, <span class="keyword">const</span> Point &amp;);</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;a,<span class="keyword">const</span> Point &amp;b)&#123;<span class="comment">//extra class overload, operator overload function as friend function of class</span></span><br><span class="line">    Point ret;</span><br><span class="line">    ret.x = a.x + b.x;</span><br><span class="line">    ret.y = a.y + b.y;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Point a(2,4),b(5,3);</span><br><span class="line">    Point c = a + b;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; <span class="string">"x :"</span> &lt;&lt; c.x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"y :"</span> &lt;&lt; c.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When the above code is compiled and executed, it produces the same result as above</p>
<p>Examples of various operator overloads<br>The following code demonstration of various operator overloading examples will demonstrate several basic operator overloading.</p>
<p>Insertion operator overloading &gt;&gt; and Extraction operator overloading &lt;&lt;<br>Take the example of the extract operator overload &lt;&lt;. cout is an object of the ostream class. ostream class and cout are both declared in the header file <iostream>. ostream class overloads &lt;&lt; as a member function.</p>
<p>Here we overload &lt;&lt; to output a object using cout</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point()&#123;&#125;;</span><br><span class="line">    Point (<span class="keyword">int</span> x, <span class="keyword">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;, <span class="keyword">const</span> Point &amp;);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out , <span class="keyword">const</span> Point &amp;a);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;a,<span class="keyword">const</span> Point &amp;b)&#123;</span><br><span class="line">    Point ret;</span><br><span class="line">    ret.x = a.x + b.x;</span><br><span class="line">    ret.y = a.y + b.y;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out , <span class="keyword">const</span> Point &amp;a)&#123;</span><br><span class="line">    out &lt;&lt; &lt; <span class="string">"&lt;Point&gt;( "</span> &lt;&lt; a.x &lt;&lt; <span class="string">", "</span> &lt;&lt; a.y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point a(2,4),b(5,3);</span><br><span class="line">    Point c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When the above code is compiled and executed, it produces the following results.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; Point&gt;( <span class="number">7</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p>Note: When overloading <code>&lt;&lt;</code>, it is an out-of-class overload, and it is customary to use <code>cin&gt;&gt;</code> and <code>cout&lt;&lt;</code>. You have to use a friend function to overload the operator, and if you use a member function to overload it, you will get <code>c&lt;&lt;cout;</code> which is unnatural code.</p>
<p>Also there should be some confusion about the <code>ostream &amp;operator&lt;&lt;(ostream &amp;out , const Point &amp;a)</code> function, first of all when overloading &lt;&lt;, the return value type is <code>ostream&amp;</code> and the first argument is also <code>ostream&amp;</code>. That is, the return value of the expression <code>cout&lt;&lt;c</code> is still <code>cout</code>, so <code>cout&lt;&lt;c&lt;&lt;endl;</code> can hold</p>
<p>Pre-operator overload ++ and post-operator overload ++</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point()&#123;&#125;;</span><br><span class="line">    Point (<span class="keyword">int</span> x, <span class="keyword">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;, <span class="keyword">const</span> Point &amp;);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out , <span class="keyword">const</span> Point &amp;a);</span><br><span class="line">    Point&amp; <span class="keyword">operator</span>++()&#123; <span class="comment">// Preceding operator, requires reference return, no arguments. Returns the value after self-incrementing, and returns a left value</span></span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Point <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;<span class="comment">//Post++, no reference return, parameter differentiation required. Returns the value before the self-increment and returns a right value</span></span><br><span class="line">        <span class="function">Point <span class="title">temp</span><span class="params">(x,y)</span></span>;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;a,<span class="keyword">const</span> Point &amp;b)&#123;</span><br><span class="line">    Point ret;</span><br><span class="line">    ret.x = a.x + b.x;</span><br><span class="line">    ret.y = a.y + b.y;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out , <span class="keyword">const</span> Point &amp;a)&#123;</span><br><span class="line">    out &lt;&lt; &lt; <span class="string">"&lt;Point&gt;("</span> &lt;&lt; a.x &lt;&lt; <span class="string">" , "</span> &lt;&lt; a.y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point a(2,4),b(5,3);</span><br><span class="line">    Point c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    c++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When the above code is compiled and executed, it produces the following results.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(7 , 7)</span><br><span class="line">&lt; Point&gt;(8 , 8)</span><br><span class="line">&lt; Point&gt;(9 , 9)</span><br></pre></td></tr></table></figure>

<p>1&gt; In order to distinguish between the preceding and the following operators, it is necessary to add the parameter “int” to the latter operator overload function, although this type does not represent any real meaning here except to show the difference.</p>
<p>2&gt; The predecessor returns a reference to a variable, the posterior returns a constant. So ++++c is legal, but c++++ is not;</p>
<p>3&gt;Why not let c++++ be legal too? If you want to make c++++ legal, you must make the posterior return a variable or a reference to a variable. c++ returns the value of c before +1, so it is impossible to return c. Then you can only create a local variable to save the initial value of c, and then return the local variable (local variables are not allowed to return references), but after returning the local variable, if you do the next ++ operation in a row, the one that participates in the operation is the value of this So at this point, c++++ is actually equivalent to c++, and there is no point of existence.</p>
<h1 id="The-difference-between-new-delete-and-malloc-free-in-C"><a href="#The-difference-between-new-delete-and-malloc-free-in-C" class="headerlink" title="The difference between new/delete and malloc/free in C++"></a>The difference between new/delete and malloc/free in C++</h1><p>1、new and delete are operators in C++, while malloc and free are standard library functions.</p>
<p>2, for non-internal data objects, only use malloc is unable to complete the dynamic object requirements, generally in the creation of objects need to call the constructor, object extinction, the automatic call destructor. The malloc free is a library function instead of an operator, which is not under the compiler’s control and cannot automatically call the constructor and destructor. NEW, on the other hand, can automatically call the constructor when requesting memory space for an object, and can also complete the initialization of the object. Similarly, delete can also automatically call destructors. And mallloc just does one thing, it just allocates memory for the variable, and by the same token, free just releases the memory of the variable.</p>
<ol start="3">
<li>new returns a pointer of the specified type and can automatically calculate the size of the requested memory. malloc, on the other hand, requires us to calculate the size of the requested memory and forcibly convert it to a pointer of the actual type upon return.</li>
</ol>
<p>What exactly are new and delete?<br>If you are looking for a job and read some interview books, I believe you will encounter the question: sizeof is not a function, and then you will give a bunch of reasons to prove that sizeof is not a function. Here, similar to sizeof, new and delete are also not functions, they are keywords defined by C++ and can be composed into expressions by a specific syntax. Unlike sizeof, which determines its return value at compile time, the mechanism behind new and delete is more complex.<br>Before you go any further, think about what you think new should do. Perhaps your first response is that new is not the same as the malloc function in C, which is used to dynamically request space. You’re half right. Look at the following statement.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure>

<p>You can see that new and malloc are still a bit different. malloc doesn’t do the necessary initialization of memory after requesting space, while new does. So what goes on behind the scenes of the new expression is not as simple as you might think. Before I explain the mechanism behind new with an example, you need to know what operator new and operator delete are.</p>
<p>operator new and operator delete<br>are actually library functions of the C++ language standard library, with the following prototypes.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>; <span class="comment">//allocate an object</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *)</span></span>; <span class="comment">//free an object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>); <span class="comment">//allocate an array</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *); <span class="comment">//free an array</span></span><br></pre></td></tr></table></figure>

<p>You can leave the last two alone for now, they will be described later. The first two are C++ standard library functions, you may think this is a function? The C++ Primer book says that this is not an overloading of the new and delete expressions (as operator= is an overloading of the = operator), because new and delete are not allowed to be overloaded. But I haven’t figured out why operator new and operator delete are named, which is rather confusing. We just need to know what they mean. These two functions are a bit like the malloc and free functions in C. They are both used to request and release memory, and operator new does not initialize the memory after requesting it, but directly returns a pointer to the requested memory.</p>
<p>We can use these functions directly in our programs.</p>
<p>The mechanism behind new and delete<br>Once we know the above two functions, let’s explain the mechanism behind new and delete with an example.</p>
<p>Instead of using a simple C++ built-in type as an example, let’s use a more complex class type and define a class A.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> v) : var(v)</span><br><span class="line">    &#123;</span><br><span class="line">        fopen_s(&amp;file, <span class="string">"test"</span>, <span class="string">"r"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    FILE *file;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The constructor initializes the private variable var and opens a file, and the destructor closes the open file.</p>
<p>We use</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> *<span class="title">pA</span> = <span class="title">new</span> <span class="title">A</span>(10);</span></span><br></pre></td></tr></table></figure>

<p>The following diagram shows the work done behind new.</p>
<p>To summarize briefly.</p>
<p>First, you need to call the operator new standard library function mentioned above, and pass in the parameter for the size of class A. Here it is 8 bytes, as to why it is 8 bytes, you can take a look at the book “Deeper into C++ Object Model”, not much explanation here. This function returns the starting address of the allocated memory, which is assumed to be 0x007da290.<br>The memory allocated above is uninitialized and untyped. The second step is to initialize the class object on this piece of raw memory, calling the corresponding constructor, here is a call to A:A(10); This function, as you can see from the diagram, also initializes this piece of applied memory, var=10, file points to the open file.<br>The last step is to return a pointer to the newly allocated and constructed object, here pA points to the 0x007da290 block of memory, and pA is of type pointer to the class A object.<br>You can find the assembly code for all three of these steps by disassembling, so I won’t list them here.</p>
<p>Okay, so what does delete do? To continue with the above example, what if we want to release the object of the requested class at this point? Of course we can use the following statement to do that.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pA;</span><br></pre></td></tr></table></figure>

<p>What delete does is shown in the following figure.</p>
<p>img<br>img</p>
<p>delete then does two things.</p>
<p>Call the destructor function of the object pointed to by pA to close the open file.<br>The object’s memory is freed by the standard library function operator delete mentioned above, and the argument passed to the function is the value of pA, which is 0x007d290.<br>Well, after explaining what is done behind new and delete, don’t you think it is very simple? It’s just one more call to the constructor and destructor.</p>
<p>How to request and release an array?<br>We often need to dynamically allocate an array, perhaps like this.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *psa = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>]; <span class="comment">//array of 10 empty strings</span></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//array of 10 uninitialized ints</span></span><br></pre></td></tr></table></figure>

<p>The above is done by using the new [] expression when requesting an array. According to our knowledge of new and delete mentioned above, the first array is of type string, and after allocating the memory space to store the objects, the default constructor of type string will be called to initialize each element of the array in turn; the second is to request an array with built-in types, and allocate the memory space to store 10 int objects. The second is an application for an array with built-in types, which allocates memory space to store 10 int objects, but does not initialize them.</p>
<p>If we want to free up the space, we can use the following two statements.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] psa;</span><br><span class="line"><span class="keyword">delete</span> [] pia;</span><br></pre></td></tr></table></figure>

<p>Both use the delete [] expression, and note that the [] in this place cannot be left out in general! We can also imagine what these two statements do: the first one calls the destructor on each of the 10 string objects, and then frees all the memory space allocated for the object; the second one frees all the memory space allocated for the 10 int types directly because there is no destructor for the built-in types.</p>
<p>Here is a question for the first case: how do we know the size of the array that psa refers to? How do we know how many times to call the destructor?</p>
<p>This problem directly leads to the need to save the dimension of the array when we new [] an array of objects. The C++ approach is to allocate an extra 4 bytes of array space, specifically to save the size of the array.</p>
<p>We define a class A, but do not describe the contents of the class specifically, this class has a display of the constructor, destructor and so on. So when we call</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> \*<span class="title">pAa</span> = <span class="title">new</span> <span class="title">A</span>[3];</span></span><br></pre></td></tr></table></figure>

<p>what needs to be done when we call class A is as follows.</p>
<p>img<br>img</p>
<p>From this diagram we can see that the application allocates an additional 4 bytes on top of the array object to preserve the size of the array, but the final return is a pointer to the object array, not the starting address of all the allocated space.</p>
<p>In this case, the release is simple.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] pAa;</span><br></pre></td></tr></table></figure>

<p>img<br>img</p>
<p>The two points to note here are.</p>
<p>the number of calls to the destructor function is taken from the 4 bytes preceding the pointer to the array object.<br>The argument passed to the operator delete[] function is not the pointer to the array object, pAa, but the value of pAa minus 4.<br>Why do new/delete and new []/delete[] need to be used in pairs?<br>Actually, after all this, I haven’t gotten to the original intention of writing this article. From the above explanation, you should understand how new/delete and new[]/delete[] work, because there are differences between them, so they need to be used in pairs. But the problem is not that simple, and that is the problem I encountered with the following code.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> \*pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> []pia;</span><br></pre></td></tr></table></figure>

<p>This is certainly fine, but if we replace delete []pia; with delete pia;, will something go wrong?</p>
<p>This brings us to the question that was not mentioned in the section above. I mentioned above the reason for allocating 4 extra bytes in new [], because we need to know the size of the array when destructing it, but what if we don’t call the destructor (as in the case of built-in types, in this case int arrays)? We don’t need to allocate those 4 extra bytes in new [], and when we delete [] we go directly to the second step to free the space allocated for the int array. If we use delete pia here; then the operator delete function will be called, and the argument passed in is the starting address of the allocated array, and all it does is free up that memory space. There is no problem.</p>
<p>The requirement for using new [] to free an object with delete is that the object is of a built-in type or a class type without a custom destructor!</p>
<p>Let’s see what happens if we use new [] to create an array of class objects and delete to free them for a class type with a custom destructor. To illustrate with the above example.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> \*<span class="title">pAa</span> = <span class="title">new</span> <span class="title">class</span> <span class="title">A</span>[3];</span></span><br><span class="line"><span class="keyword">delete</span> pAa;</span><br></pre></td></tr></table></figure>

<p>Then delete pAa; does two things.</p>
<p>calls once the destructor of the object pointed to by pAa.<br>Call operator delete(pAa); to free memory.<br>Obviously, the destructor is called only for the first class object of the array, and not for the next two objects. If a large amount of memory is requested in the class object and needs to be freed in the destructor, and you undercall the destructor when destroying the array object, this will cause a memory leak.</p>
<p>If you say it’s okay for the above problem, then the second point is fatal! Freeing the memory space pointed to by pAa directly will always cause a serious segment error and the program will surely crash! Because the starting address of the allocated space is the place where pAa points minus 4 bytes. You should pass in the parameter set to that address!</p>
<p>Similarly, you can analyze what will happen if you use new to allocate and delete [] to free? Does it always lead to program errors?</p>
<p>In general, just remember one thing: new/delete, new[]/delete[] should always be used together!</p>
<h1 id="Explanation-of-iostream-and-using-namespace-std"><a href="#Explanation-of-iostream-and-using-namespace-std" class="headerlink" title="Explanation of iostream and using namespace std"></a>Explanation of iostream and using namespace std</h1><p>When we practice programming with C++ syntax, we often write the first two lines of the code like this</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include&lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>

<p>Do you have any doubts when you are learning C++?</p>
<p>When you practice C programming, you only need to declare one header file: #include&lt;stdio.h&gt;. But in C++, why do we need to write two lines of code, include and using namespace std;?</p>
<p>The first line, include, is barely understandable, as it is similar to #include&lt;stdio.h&gt; in C, i.e., declaring the standard input and output header files. But what exactly does using namespace std do?</p>
<p>There are a lot of professional arguments on the web for this question, but the long and complicated content is too much of a headache for beginners to read, so I hope to explain clearly the role of using namespace std in concise language. I think the correct order of study is</p>
<p>I think the correct order of learning is: we must first learn to define, use and understand namespace (namespace), and then go back to study the role of using namespace std; this can play a half-hearted effect, then the next focus will come.</p>
<p>Defining namespaces<br>(1) Simple namespace</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. Define namespace A</span></span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;<span class="comment">//define variable a in namespace A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Defining a namespace is as simple as this: in this namespace A, there is an int-type variable with the name “a”. So let’s go straight to the hard part! Define a complex namespace.</p>
<p>(2) Complex namespaces</p>
<p>Requirement: Define namespace B, and define namespace C in namespace B, and define the structure Teacher in namespace C</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. Complex namespaces</span></span><br><span class="line"><span class="keyword">namespace</span> B <span class="comment">//define namespace B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;<span class="comment">//you can also define the variable a in namespace B, because they are not in the same namespace</span></span><br><span class="line"><span class="keyword">namespace</span> C <span class="comment">//You can also define another namespace C in namespace B</span></span><br><span class="line"><span class="keyword">namespace</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span>//<span class="title">define</span> <span class="title">the</span> <span class="title">structure</span> <span class="title">Teacher</span> <span class="title">in</span> <span class="title">namespace</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">32</span>];<span class="comment">//The variable a can also be defined in the structure, because the three "a "s are not in the same namespace</span></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Using namespaces<br>(1) The basic method of using namespaces</p>
<p>We have defined namespaces A, B and C, and the same variable “a” is defined in all three namespaces, so let’s use them.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//The basic way to use namespaces 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;<span class="comment">//Tell the compiler that I want to use the functions in namespace A</span></span><br><span class="line">a=<span class="number">10</span>; <span class="comment">//Change variable "a" in namespace A from 0 to 10</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//check if the change is done, the screen should output "10</span></span><br></pre></td></tr></table></figure>

<p>Note: At this time, only namespace A is used, so only the variable a in namespace A will be accessed, but not the variables a in namespace B and C.</p>
<p>In fact, for the above three lines of code, as long as the variable “a” is clearly pointed out in the third line of code, the first line “using namespace A” can be omitted, as follows.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The basic method of using namespaces 2</span></span><br><span class="line"><span class="comment">// Since it is sufficient to use one of these two methods in the code, I added the "//" comment notation here for the second method, as follows two lines of code.</span></span><br><span class="line"><span class="comment">// a=10;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;A::a&lt;endl; // "A::a" explicitly points to variable a in namespace A (with a double colon::)</span></span><br></pre></td></tr></table></figure>

<p>The above two ways of using namespaces are for you to pick and choose ^_^</p>
<p>(2) Using complex namespaces</p>
<p>The use of namespace A is relatively simple, but there is a namespace C nested in namespace B, and there is a structure Teacher nested in namespace C. So how do we use namespace B and namespace C?</p>
<p>Next, if we use namespace B in addition to namespace A, the statement “a=10;” is not clear: there is a variable a in namespace B, so there are now two “a “s that can be accessed so there are now two “a “s that can be accessed. So: if you want to access a specific variable a, you need to point explicitly!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line"><span class="comment">// If you want to access a specific variable a, you need to point to it explicitly! as follows.</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;A::a&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//explicitly points to the "namespace A"</span></span><br><span class="line"><span class="comment">//Although there are two namespaces, A and B, and the variable "a" is in both namespaces, by pointing explicitly, we can specify whether the variable we are accessing is "a" in namespace A or "a" in namespace B "a" in namespace B</span></span><br></pre></td></tr></table></figure>

<p>(3) Using the variables in the structure Teacher</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//How to use Teacher</span></span><br><span class="line"><span class="comment">//Method 1: This method requires for each structure defined: "B::C::Teacher structure name"</span></span><br><span class="line"><span class="comment">//B::C::Teacher t1;// Define the structure t1 using the structure template (Teacher) from namespace C in namespace B</span></span><br><span class="line"><span class="comment">//t1.b=33;//Note: t1.a is syntactically incorrect! It is because a is a pointer (address), which cannot be modified, otherwise the memory cannot be freed later</span></span><br><span class="line"> <span class="comment">//Method 2: Define the "structure type" data type directly in one breath, and then use the structure in the same way as you define variables by data type</span></span><br><span class="line"><span class="keyword">using</span> B::C::Teacher;</span><br><span class="line">Teacher t2;</span><br><span class="line">t2.b=<span class="number">22</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ðŸ™' ðŸ™'</span><br><span class="line"></span><br><span class="line">The analysis of iostream <span class="keyword">and</span> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> \*\*\\*\*\*</span><br><span class="line">(1) Through the above introduction on the definition and use of namespaces, we can easily find that different namespaces are independent of each other, although the variable names attached to them may be the same (for example, the namespaces A, B and C mentioned above all contain the variable a), but it doesn't matter: the "namespace" This "barrier" separates these identical variable names, so that they have the same name, but do not affect each other.</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) It seems that the introduction of namespaces is very convenient, so we don<span class="number">'</span>t have to worry about renaming variables. However, in the old days, there was no <span class="keyword">concept</span> of namespaces, but the standard library functions were defined in the global space <span class="keyword">and</span> declared in &lt;iostream.h&gt; (an early C++ header file). But since the standard library is very large, then there is a high chance that the programmer will choose a <span class="class"><span class="keyword">class</span> <span class="title">name</span> <span class="title">or</span> <span class="title">function</span> <span class="title">name</span> <span class="title">that</span> <span class="title">is</span> <span class="title">the</span> <span class="title">same</span> <span class="title">as</span> <span class="title">one</span> <span class="title">of</span> <span class="title">the</span> <span class="title">names</span> <span class="title">in</span> <span class="title">the</span> <span class="title">standard</span> <span class="title">library</span>. <span class="title">So</span> <span class="title">to</span> <span class="title">avoid</span> <span class="title">name</span> <span class="title">conflicts</span> <span class="title">caused</span> <span class="title">by</span> <span class="title">this</span> <span class="title">situation</span>, <span class="title">everything</span> <span class="title">in</span> <span class="title">the</span> <span class="title">standard</span> <span class="title">library</span> <span class="title">was</span> <span class="title">put</span> <span class="title">in</span> <span class="title">a</span> <span class="title">namespace</span> <span class="title">called</span> <span class="title">std</span>. <span class="title">Later</span> <span class="title">the</span> <span class="title">C</span>++ <span class="title">standard</span>, <span class="title">in</span> <span class="title">order</span> <span class="title">to</span> <span class="title">distinguish</span> <span class="title">it</span> <span class="title">from</span> <span class="title">C</span> <span class="title">and</span> <span class="title">to</span> <span class="title">use</span> <span class="title">the</span> <span class="title">namespace</span> <span class="title">correctly</span>, <span class="title">specified</span> <span class="title">that</span> <span class="title">the</span> <span class="title">header</span> <span class="title">files</span> <span class="title">do</span> <span class="title">not</span> <span class="title">use</span> <span class="title">the</span> <span class="title">suffix</span> .<span class="title">h</span>, <span class="title">i</span>.<span class="title">e</span>., <span class="title">the</span> <span class="title">current</span> <span class="title">header</span> <span class="title">files</span> <span class="title">appeared</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(3) <span class="title">When</span> <span class="title">used</span>, <span class="title">the</span> <span class="title">header</span> <span class="title">file</span> <span class="title">does</span> <span class="title">not</span> <span class="title">define</span> <span class="title">the</span> <span class="title">global</span> <span class="title">namespace</span>, <span class="title">and</span> <span class="title">must</span> <span class="title">use</span> <span class="title">the</span> <span class="title">standard</span> <span class="title">namespace</span> <span class="title">specified</span> <span class="title">by</span> <span class="title">C</span>++ (<span class="title">i</span>.<span class="title">e</span>.:</span> <span class="keyword">namespace</span> <span class="built_in">std</span>), so that it can correctly use <span class="built_in">cout</span>, <span class="built_in">endl</span>, <span class="keyword">and</span> other functions.</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>) Finally: If you want to know more about <span class="keyword">this</span>, please refer to: Click to open the link Thanks.</span><br><span class="line"></span><br><span class="line"><span class="meta"># c++ Defining Structs</span></span><br><span class="line"></span><br><span class="line">Define the structure type first <span class="keyword">and</span> then define the variables separately</span><br><span class="line"></span><br><span class="line">````Cpp</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ```cpp;</span><br><span class="line"><span class="keyword">char</span> Name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> Sex;</span><br><span class="line"><span class="keyword">int</span> Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">Stu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">Stu</span>[10];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> \*<span class="title">pStru</span>;</span></span><br></pre></td></tr></table></figure>

<p>The structure type is struct Student, so neither struct nor Student can be omitted. But actually, when I run with ``cppblocks, the following variables are defined without the struct.</p>
<p>The definition follows immediately after the struct type description</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ```cpp;</span><br><span class="line"><span class="keyword">char</span> Name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> Sex;</span><br><span class="line"><span class="keyword">int</span> Age;</span><br><span class="line">&#125;Stu,Stu[<span class="number">10</span>],\*pStu;</span><br></pre></td></tr></table></figure>

<p>In this case, the structure variable can be defined again later.</p>
<p>The definition is done directly while stating an unnamed structure variable</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ```cpp;</span><br><span class="line"><span class="keyword">char</span> Name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> Sex;</span><br><span class="line"><span class="keyword">int</span> Age;</span><br><span class="line">&#125;Stu,Stu[<span class="number">10</span>],\*pStu;</span><br></pre></td></tr></table></figure>

<p>In this case, no other variables can be defined afterwards.</p>
<p>Use typedef to describe a structure variable and then define the variable with the new class name</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ```cpp;</span><br><span class="line"><span class="keyword">char</span> Name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> Sex;</span><br><span class="line"><span class="keyword">int</span> Age;</span><br><span class="line">&#125;student;</span><br></pre></td></tr></table></figure>

<p>Student Stu,Stu[10],*pStu;<br>Student is a concrete structure type, uniquely identified. There is no need to add struct</p>
<h1 id="Synchronous-and-Asynchronous"><a href="#Synchronous-and-Asynchronous" class="headerlink" title="Synchronous and Asynchronous"></a>Synchronous and Asynchronous</h1><p>What is synchronous and asynchronous?<br>Definition: Synchronous and asynchronous are concerned with <em>message communication mechanisms</em> (synchronous communication/ asynchronous communication). Synchronous means that when something is called, the caller has to wait for the result of the call to be returned before proceeding further. Asynchronous, in contrast to synchronous, the caller does not understand the result, but after the call is made the caller can continue to perform subsequent operations, and the called party notifies the caller through the form, or by dropping back the function to handle the call <em>\</em></p>
<p>Let’s say: you go to the mall to buy something, you look at a cell phone, can and the shopkeeper said you a this phone, he went to the warehouse to get the goods, you have to wait in the store, can not leave, this is called synchronization. Now you buy a cell phone to catch up with the fashion directly to Jingdong order, after the completion of the order you can do other time (catching up on drama, playing king, lol) and so the goods arrived to sign for it ok. This is called asynchronous.</p>
<p>Take a method call as an example<br>Once a synchronous method call starts, the caller must wait until the method call returns before continuing the subsequent behavior.<br>An asynchronous method call is more like a message pass, once it starts, the method call returns immediately and the caller can continue with the subsequent actions. The asynchronous method is usually executed in another thread, “for real”. The whole process, without impeding the caller’s work<br>Two more diagrams for better understanding<br>Synchronous execution of</p>
<p>img<br>img</p>
<p>Synchronous execution is executed when the method is called and the result is returned before the subsequent code is executed</p>
<p>Asynchronous execution</p>
<p>img<br>img</p>
<p>Asynchronous calls can be referred to as ajax, where the method is called without waiting for the sum method to complete, and the subsequent code is executed directly. sum method notifies the main thread of the completion of execution, mainly through status, or through a callback that handles the results of the asynchronous method execution.</p>
<p>Synchronous asynchronous is not to be confused with non-blocking<br>After reading the above explanation, you may say that this is not a blocking mechanism? No, no, no, synchronous asynchronous is not to be confused with blocking or non-blocking.</p>
<p>Blocking and non-blocking emphasize the state of the program while waiting for the result of the call (message, return value). A blocking call means that the current thread is hung until the result of the call is returned. The calling thread will return only after the result is obtained. A non-blocking call is one that does not block the current thread until the result is immediately available. For synchronous calls, many times the current thread is still active, but logically the current function does not return, i.e. it does nothing while synchronously waiting, taking up resources for nothing.</p>
<p>Synchronous and asynchronous emphasize the message communication mechanism (synchronous communication/ asynchronous communication). Synchronous means that when a “call” is made, the “call” does not return until the result is obtained. But once the call returns, the return value is obtained. In other words, the “caller” is actively waiting for the result of the “call”. Asynchronous, on the other hand, is the opposite: after the “call” is made, the call returns directly, so no result is returned. In other words, when an asynchronous procedure call is issued, the caller does not get the result immediately. Instead, after the “call” is made, the “callee” notifies the caller through status, notification, or a callback function that handles the call.</p>
<p>Reference blog: <a href="https://blog.csdn.net/huangqiang1363/article/details/79508852" target="_blank" rel="noopener">https://blog.csdn.net/huangqiang1363/article/details/79508852</a></p>
<p>c language partitions<br>Stack Stack (large address, used from high to low)<br>Heap (used from low to high)<br>Global or static constants area<br>Text and code area (small address)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>; <span class="comment">//global or static constants area</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hehe</span><span class="params">()</span> </span>&#123; <span class="comment">//function, in stack</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> he = <span class="number">0</span>; <span class="comment">//global or static constant area, because static will only be created once</span></span><br><span class="line">he++;</span><br><span class="line">total++;</span><br><span class="line">total++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">3</span>; <span class="comment">//internal variable of the function, in the stack, but 3 is in the code area</span></span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">"Hello, world!"</span>; <span class="comment">// internal variable in str function, in stack, "hello world" is in constant area</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// p in stack, malloc dynamically allocated memory in heap</span></span><br><span class="line">hehe();</span><br><span class="line">hehe();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d%s%d"</span>, k, str, *p);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//stack memory free</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Classes-and-objects"><a href="#Classes-and-objects" class="headerlink" title="Classes and objects"></a>Classes and objects</h1><p>Classes: A class is a template that describes the behavior and state of a class of objects.<br>Object: An object is an instance of a class<br>How c handles classes and objects.</p>
<p>There are no “classes”, only “types”.</p>
<p>There are no “objects”, only “variables”</p>
<p>Structured variables + functions</p>
<p>The c language uses struct variables + functions to achieve similar functionality, as follows</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printID</span><span class="params">(struct Student \*in)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"My id is %d.\n"</span>,in-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">one</span>;</span></span><br><span class="line">one.id=<span class="number">999</span>;</span><br><span class="line">printID(&amp;one);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, we found that the properties of Student and the operations added to the properties are separated, we can solve this problem by using the function pointer class</p>
<p>function pointer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">void</span> (*printID)(struct Student *in);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printID</span><span class="params">(struct Student \*in)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"My id is %d.\n"</span>,in-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">one</span>;</span></span><br><span class="line">one.id=<span class="number">999</span>;</span><br><span class="line">one.printID=printID;</span><br><span class="line">one.printID(&amp;one);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="A-different-experience-writing-C-programs-with-plain-text-command-line"><a href="#A-different-experience-writing-C-programs-with-plain-text-command-line" class="headerlink" title="A different experience, writing C++ programs with plain text command line"></a>A different experience, writing C++ programs with plain text command line</h1><p>Open vmware and run ubuntu<br>Right-click on the desktop to open a terminal<br>Enter the command ls to see where you are<br>Enter the command cd desktop to enter the desktop folder<br>Enter the command touch test.cpp to create the test.cpp file<br>Open the test.cpp file, enter the following code and save it to insert the image description here<br>Insert the image description here<br>Enter the command g++ test.cpp to compile the test.cpp file, we find that a new file a.out is created on the desktop, this is the compiled executable file, next we run it<br>Next, we run it by entering the command . /a.out to run it and find the following output: Insert image description here<br>Insert the image description here</p>
<h1 id="New-features-of-c"><a href="#New-features-of-c" class="headerlink" title="New features of c++"></a>New features of c++</h1><p>Classes<br>As mentioned before</p>
<p>bool type and auto type<br>bool, in c, true or false is replaced by a shape, 0 –&gt; False &amp;&amp; !0 –&gt; True &amp;&amp; True –&gt; &amp;&amp; False –&gt; 0</p>
<p>In c++, you can true, false, and also use 0 and 1</p>
<p>auto, let the compiler infer what type it is, but it must be assigned at initialization, otherwise the compiler reports an error</p>
<p>cout, which prints floating point numbers with the latter part omitted</p>
<p>References<br>C<br>int a = 3; //defines the variable a and initializes it with 3, = is not the operator = means initialize<br>int b; //defines variable b, not initialized<br>b = 3; //assigns 3 to b, = is an operator</p>
<p>int array[10]={1,2,3}; //defines the array array and initializes it with {1,2,3}<br>array={1,2,3}; //error<br>array[10]={1,2,3}; //error<br>C<br>int _p; // _ means that p is a pointer, not a fetch operator, and p is a pointer to an int type<br>int a = 3;<br>p = &a;<br>_p = 6; // _ is the value taking operator<br>C<br>int b = 6;<br>int &amp;r = b; // &amp; means r is a reference type, not a take address operator, r is a reference of int type, = means initialize r with b, let r become a reference of b, not an assignment, can be understood as a nickname for b, from then on r is b, b is r<br>r = 123;<br>cout &lt;&lt; r &lt;&lt; endl; // 123<br>cout &lt;&lt; b &lt;&lt; endl; // 123<br>Parameter passing of functions in C++.</p>
<p>Pass by value (pass by value)<br>Pass by address (pass by pointer)<br>Pass by reference<br>The reference must be initialized at definition time, and once created, the referenced object cannot be replaced</p>
<p>C<br>int b = 6;<br>int &r; //error: ‘r’ declared as reference but not initialized<br>r = b; //assign the value of b to r, but at this point r does not have any reference<br>About the assignment<br>C<br>int a, b, c;<br>(a = b = c = 3) = 666;<br>cout &lt;&lt; a &lt;&lt; endl; //666<br>cout &lt;&lt; b &lt;&lt; endl; //3<br>cout &lt;&lt; c &lt;&lt; endl; //3<br>The reference returned after the assignment is the left value</p>
<p>New syntax for initialization</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a&#123;<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">and</span> <span class="keyword">delete</span></span><br></pre></td></tr></table></figure>

<p>int _p;<br>p = (int _) malloc(sizeof(int));<br>free(p);<br>p = new int;<br>delete p;<br>deleete[] p; //complex types should be written like this</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> sid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Student one, two;</span><br><span class="line">one.sid = <span class="number">1</span>;</span><br><span class="line">two.sid = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;one &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;two &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">one = two;</span><br><span class="line">two.sid = <span class="number">999</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;one &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;two &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> sid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Student *one = <span class="keyword">new</span> Student();</span><br><span class="line">Student *two = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">// Student *one, *two;</span></span><br><span class="line"><span class="comment">// one = new Student();</span></span><br><span class="line"><span class="comment">// two = new Student();</span></span><br><span class="line">one-&gt;sid = <span class="number">1</span>;</span><br><span class="line">two-&gt;sid = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;one &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0x63fde8</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;two &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0x63fde0</span></span><br><span class="line">one = two; <span class="comment">//memory leak</span></span><br><span class="line">two-&gt;sid = <span class="number">999</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0x1c1770</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; two &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0x1c1770</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Further understanding of Java references, equivalent to pointers in c++, java references are not the same as c++ references</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> sid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">Student one = <span class="keyword">new</span> Student(); <span class="comment">// create object must need new</span></span><br><span class="line">Student two = <span class="keyword">new</span> Student();</span><br><span class="line"> one.sid = <span class="number">1</span>;</span><br><span class="line">two.sid = <span class="number">2</span>;</span><br><span class="line">System.out.println(<span class="string">"one: "</span> + one); <span class="comment">//one: Student@7291c18f</span></span><br><span class="line">System.out.println(<span class="string">"two: "</span> + two); <span class="comment">//two: Student@34a245ab</span></span><br><span class="line">one = two;</span><br><span class="line">two.sid = <span class="number">999</span>;</span><br><span class="line">System.out.println(<span class="string">"one: "</span> + one); <span class="comment">//one: Student@34a245ab</span></span><br><span class="line">System.out.println(<span class="string">"two: "</span> + two); <span class="comment">//two: Student@34a245ab</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The new for loop<br>for-each is not repeated, you can use auto, each is the value taken out of the container, &amp;each can modify the original value of the container</p>
<p>Insert the image description here<br>Insert image description here</p>
<p>Insert image description here<br>Insert image description here</p>
<p>Overloading<br>C++ allows to specify multiple definitions of a function and operator in the same scope, called function overloading and operator overloading, respectively.</p>
<p>Several functions with the same name can be declared in the same scope, but the formal parameters (meaning the number, type or order of the arguments) of these functions with the same name must be different. It is not possible to overload a function simply by having a different return type.</p>
<p>We can redefine or overload most of the C++ built-in operators. This way, you can use operators of custom types.</p>
<p>Overloaded operators are functions with special names, where the function name is formed by the keyword operator followed by the operator symbol to be overloaded. Like other functions, overloaded operators have a return type and a list of arguments.</p>
<p>Note: In a function declaration, const can modify the formal parameter to indicate that it is an input parameter whose value cannot be changed inside the function.</p>
<p>lambda</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) -&gt; <span class="keyword">auto</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f(<span class="number">3.1</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8.1</span></span><br></pre></td></tr></table></figure>

<h1 id="Generics-and-templates"><a href="#Generics-and-templates" class="headerlink" title="Generics and templates"></a>Generics and templates</h1><p>Generics are concepts, templates are implementations of generics<br>Generic programming lets you write fully generalized and reusable algorithms that are as efficient as those designed for a particular data type. STL, a representative work of generic programming, is an efficient, generic, and interactive software component. It is large and extensible, contains many basic computer algorithms and data structures, and completely separates algorithms from data structures, where algorithms are generic and not tied to any particular data structure or object type. STL is based on Iterators and Containers, a library of Generic Algorithms, and the presence of Containers gives these algorithms something to manipulate. STL is not just a collection of useful components, it is a formal and structured architecture for describing the abstract requirements of software components.</p>
<h1 id="C-language-operators-and-amp-operators"><a href="#C-language-operators-and-amp-operators" class="headerlink" title="C language * operators and &amp; operators"></a>C language * operators and &amp; operators</h1><p>The &amp; address operator is used to obtain the address of its operand. If the operand x is of type T, the expression &amp;x is of type T pointer (a pointer to T).</p>
<p>The operand of the addressing operator must be an address that is addressable in memory. In other words, the operator can only be used on functions or objects (e.g., left-valued), not on bit fields, and those that have not yet been declared by the storage class modifier register.</p>
<p>When a pointer needs to be initialized to point to certain objects or functions, the address of those objects or functions needs to be obtained.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> x, _ptr;ptr = &amp;x; <span class="comment">// legal: make pointer ptr point to xptr = &amp;(x+1); // wrong: (x+1) is not a left value</span></span><br></pre></td></tr></table></figure>

<p>Instead, when you already have a pointer and want to get the object it references, use the indirection operator _, which is sometimes called the dereferencing operator. Its operand must be of type pointer. If ptr is a pointer, then <em>ptr is the object or function pointed to by ptr. If ptr is a pointer to an object, then *ptr is a left value that can be treated as an operand to the left of the assignment operator (i.e. \</em>ptr).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> x, *ptr = &amp;x;*ptr = <span class="number">1.7</span>; <span class="comment">// assign 1.7 to the variable x++(\*ptr); // and add 1 to the value of the variable x</span></span><br></pre></td></tr></table></figure>

<p>In the last statement of this example, the value of ptr remains the same, but the value of x becomes 2.7.</p>
<p>If the value of a pointer operand is not the address of some object or function, the result of the operation of the indirect operator * cannot be determined.</p>
<p>Like other unary operands, the operators &amp; and * have a high priority. Operators are combined in a right-to-left manner. Therefore, the parentheses in the expression ++ (*ptr) are not necessary.</p>
<p>The operators &amp; and * are complementary: if x is an expression that specifies an object or a function, then the expression &amp;x is equal to x. Conversely, in an expression shaped like &amp;ptr, these operators cancel each other out, and the type and value of the expression are equivalent to ptr. However, whether ptr is left-valued or not, &amp;*ptr must not be left-valued.</p>
<h1 id="Understand-Encapsulation"><a href="#Understand-Encapsulation" class="headerlink" title="Understand Encapsulation"></a>Understand Encapsulation</h1><p>What’s in a class<br>Data (properties)<br>Operations (functions, methods)<br>Access control (public/private)<br>Static/non-static<br>Using classes directly: Static<br>Use of objects: static and non-static<br>Static cannot access non-static</p>
<h1 id="Use-of-classes-and-objects"><a href="#Use-of-classes-and-objects" class="headerlink" title="Use of classes and objects"></a>Use of classes and objects</h1><p>Defining classes and objects</p>
<h1 id="Code-Reuse"><a href="#Code-Reuse" class="headerlink" title="Code Reuse"></a>Code Reuse</h1><p>Means of code reuse<br>Function overloading<br>Class inheritance, dynamic<br>excuses</p>
<h1 id="Off-topic"><a href="#Off-topic" class="headerlink" title="Off-topic"></a>Off-topic</h1><p>Constructors use initialization lists to initialize fields</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Line::Line( <span class="keyword">double</span> len): length(len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created, length = "</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The above syntax is equivalent to the following syntax.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line::Line( <span class="keyword">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">length = len;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created, length = "</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Use commas to separate the different fields as follows.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C::C( <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c): X(a), Y(b), Z(c)</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h1><p>Function Templates</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Zhenglin Li on 2020/9/23.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">T s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">s += <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a1[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> a2[<span class="number">3</span>] = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(a1, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(a2, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(a2, <span class="number">1</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Overloading of function templates</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Zhenglin Li on 2020/9/23.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">T s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">s += <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T <span class="built_in">array</span>[], <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">T s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = from - <span class="number">1</span>; i &lt;= to - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">s += <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a1[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> a2[<span class="number">3</span>] = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(a1, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(a2, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(a2, <span class="number">1</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Class templates</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Zhenglin Li on 2020/9/23.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// Template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T x;</span><br><span class="line">T y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Vector(T x = <span class="number">0</span>, T y = <span class="number">0</span>) : x(x), y(y) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;o, <span class="keyword">const</span> Vector&lt;T&gt; &amp;v) &#123;</span><br><span class="line">        o &lt;&lt; <span class="string">"&lt;"</span> &lt;&lt; v.x &lt;&lt; <span class="string">", "</span> &lt;&lt; v.y &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// the real class, to &lt;&gt;</span></span><br><span class="line"><span class="function">Vector&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">Vector&lt;<span class="keyword">double</span>&gt; *p = <span class="keyword">new</span> Vector&lt;<span class="keyword">double</span>&gt;(<span class="number">1.1</span>,<span class="number">2.2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Standard Template Library (STL)<br>Standard Template Library<br>Lots of containers<br>Many algorithms</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="c-初探"><a href="#c-初探" class="headerlink" title="c++初探"></a>c++初探</h1><h1 id="C-运算符重载-简单易懂"><a href="#C-运算符重载-简单易懂" class="headerlink" title="C++运算符重载(简单易懂)"></a>C++运算符重载(简单易懂)</h1><p>运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。</p>
<p>你可以重定义或重载大部分 C++ 内置的运算符。例如 + 、 - 、 * 、 / 、</p>
<p>++、–、&gt;&gt;、&lt;&lt;等，这样，你就能使用自定义类型的运算符。</p>
<p>运算符重载的基本格式<br>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和</p>
<p>其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个</p>
<p>返回类型和一个参数列表。</p>
<p>Point operator+(const Point &amp;);</p>
<p>运算符重载有两种方式：一种是类内重载（运算符重载函数作为类的成员函数），另一种是类外重载（运算符重载函数作为类的友元函数）</p>
<p>类内重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point()&#123;&#125;;</span><br><span class="line">    Point (<span class="keyword">int</span> x, <span class="keyword">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;a)&#123; <span class="comment">//类内重载，运算符重载函数作为类的成员函数</span></span><br><span class="line">        Point ret;</span><br><span class="line">        ret.x = <span class="keyword">this</span>-&gt;x + a.x;</span><br><span class="line">        ret.y = <span class="keyword">this</span>-&gt;y + a.y;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point a(2,4),b(5,3);</span><br><span class="line">    Point c = a + b;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; <span class="string">"x :"</span> &lt;&lt; c.x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"y :"</span> &lt;&lt; c.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<p>x : 7</p>
<p>y: 7</p>
<p>运算符重载是类内重载时，运算符重载函数作为类的成员函数，以上述代码为例 a + b 相当于 a 对象调用+方法并且传入参数时 b 对象</p>
<p>类外重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point()&#123;&#125;;</span><br><span class="line">    Point (<span class="keyword">int</span> x, <span class="keyword">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;, <span class="keyword">const</span> Point &amp;);</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;a,<span class="keyword">const</span> Point &amp;b)&#123;<span class="comment">//类外重载,运算符重载函数作为类的友元函数</span></span><br><span class="line">    Point ret;</span><br><span class="line">    ret.x = a.x + b.x;</span><br><span class="line">    ret.y = a.y + b.y;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Point a(2,4),b(5,3);</span><br><span class="line">    Point c = a + b;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; <span class="string">"x :"</span> &lt;&lt; c.x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"y :"</span> &lt;&lt; c.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生和上面一样的结果</p>
<p>各种运算符重载实例<br>下面将进行各种运算符重载实例的代码演示，演示几种基本的运算符重载。</p>
<p>插入运算符重载&gt;&gt; and 提取运算符重载&lt;&lt;<br>以提取运算符重载&lt;&lt;为例，cout 是 ostream 类的对象。ostream 类和 cout 都是在头文件 <iostream>中声明的。ostream 类将&lt;&lt;重载为成员函数。</p>
<p>下面我们重载&lt;&lt;使用 cout 输出 a 对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point()&#123;&#125;;</span><br><span class="line">    Point (<span class="keyword">int</span> x, <span class="keyword">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;, <span class="keyword">const</span> Point &amp;);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out , <span class="keyword">const</span> Point &amp;a);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;a,<span class="keyword">const</span> Point &amp;b)&#123;</span><br><span class="line">    Point ret;</span><br><span class="line">    ret.x = a.x + b.x;</span><br><span class="line">    ret.y = a.y + b.y;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out , <span class="keyword">const</span> Point &amp;a)&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">"&lt;Point&gt;( "</span> &lt;&lt; a.x &lt;&lt; <span class="string">", "</span> &lt;&lt; a.y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point a(2,4),b(5,3);</span><br><span class="line">    Point c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; Point&gt;( <span class="number">7</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p>注意：重载<code>&lt;&lt;</code>时，是类外重载，习惯上人们是使用 <code>cin&gt;&gt;</code> 和 <code>cout&lt;&lt;</code> 的，得使用友元函数来重载运算符，如果使用成员函数来重载会出现 <code>c&lt;&lt;cout;</code> 这种不自然的代码。</p>
<p>另外应该会有人对 <code>ostream &amp;operator&lt;&lt;(ostream &amp;out , const Point &amp;a)</code>函数感到疑惑，首先在重载&lt;&lt;时，返回值类型是 <code>ostream&amp;</code>, 第一个参数也是 <code>ostream&amp;</code>。也就是说，表达式 <code>cout&lt;&lt;c</code> 的返回值仍是 <code>cout</code>，所以 <code>cout&lt;&lt;c&lt;&lt;endl;</code>才能成立</p>
<p>前置运算符重载++ and 后置运算符重载++</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point()&#123;&#125;;</span><br><span class="line">    Point (<span class="keyword">int</span> x, <span class="keyword">int</span> y): x(x),y(y) &#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;, <span class="keyword">const</span> Point &amp;);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out , <span class="keyword">const</span> Point &amp;a);</span><br><span class="line">    Point&amp; <span class="keyword">operator</span>++()&#123; <span class="comment">//前置运算符，需要引用返回，不需要参数。返回自增后的值，且返回的是一个左值</span></span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Point <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;<span class="comment">//后置++，不需要引用返回，需要参数区分。返回自增前的值，且返回的是一个右值</span></span><br><span class="line">        <span class="function">Point <span class="title">temp</span><span class="params">(x,y)</span></span>;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;a,<span class="keyword">const</span> Point &amp;b)&#123;</span><br><span class="line">    Point ret;</span><br><span class="line">    ret.x = a.x + b.x;</span><br><span class="line">    ret.y = a.y + b.y;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out , <span class="keyword">const</span> Point &amp;a)&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">"&lt;Point&gt;("</span> &lt;&lt; a.x &lt;&lt; <span class="string">" , "</span> &lt;&lt; a.y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point a(2,4),b(5,3);</span><br><span class="line">    Point c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    c++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(7 , 7)</span><br><span class="line">&lt; Point&gt;(8 , 8)</span><br><span class="line">&lt; Point&gt;(9 , 9)</span><br></pre></td></tr></table></figure>

<p>1&gt;为区别前置和后置运算符，需要在后置运算符重载函数中加参数“int”，虽然这个类型在此除了以示区别之外并不代表任何实际含义；</p>
<p>2&gt;前置返回的是变量的引用，后置返回的是常量。所以++++c 合法，而 c++++不合法;</p>
<p>3&gt;为什么不让 c++++也合法呢？如果要实现 c++++合法，必须使后置返回变量或变量的引用。c++是先返回 c 值再+1，所以不可能返回 c，那就只能先建立局部变量来保存 c 的初值，然后再返回局部变量（局部变量不允许返回引用），但返回了局部变量之后，如果再连着进行下一次++运算，参与运算的就是这个局部变量的值了，所以此时 c++++其实等效与 c++，也就没有存在的意义了。</p>
<h1 id="C-中-new-delete-和-malloc-free-的区别"><a href="#C-中-new-delete-和-malloc-free-的区别" class="headerlink" title="C++中 new/delete 和 malloc/free 的区别"></a>C++中 new/delete 和 malloc/free 的区别</h1><p>1、new、delete 是 C++中的操作符，而 malloc 和 free 是标准库函数。</p>
<p>2、对于非内部数据对象来说，只使用 malloc 是无法完成动态对象要求的，一般在创建对象时需要调用构造函数，对象消亡时，自动的调用析构函数。而 malloc free 是库函数而不是运算符，不在编译器控制范围之内，不能够自动调用构造函数和析构函数。而 NEW 在为对象申请分配内存空间时，可以自动调用构造函数，同时也可以完成对对象的初始化。同理，delete 也可以自动调用析构函数。而 mallloc 只是做一件事，只是为变量分配了内存，同理，free 也只是释放变量的内存。</p>
<p>3、new 返回的是指定类型的指针，并且可以自动计算所申请内存的大小。而 malloc 需要我们计算申请内存的大小，并且在返回时强行转换为实际类型的指针。</p>
<p>new 和 delete 到底是什么？<br>如果找工作的同学看一些面试的书，我相信都会遇到这样的题：sizeof 不是函数，然后举出一堆的理由来证明 sizeof 不是函数。在这里，和 sizeof 类似，new 和 delete 也不是函数，它们都是 C++ 定义的关键字，通过特定的语法可以组成表达式。和 sizeof 不同的是，sizeof 在编译时候就可以确定其返回值，new 和 delete 背后的机制则比较复杂。<br>继续往下之前，请你想想你认为 new 应该要做些什么？也许你第一反应是，new 不就和 C 语言中的 malloc 函数一样嘛，就用来动态申请空间的。你答对了一半，看看下面语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure>

<p>你就可以看出 new 和 malloc 还是有点不同的，malloc 申请完空间之后不会对内存进行必要的初始化，而 new 可以。所以 new expression 背后要做的事情不是你想象的那么简单。在我用实例来解释 new 背后的机制之前，你需要知道 operator new 和 operator delete 是什么玩意。</p>
<p>operator new 和 operator delete<br>这两个其实是 C++ 语言标准库的库函数，原型分别如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;     <span class="comment">//allocate an object</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *)</span></span>;    <span class="comment">//free an object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>);     <span class="comment">//allocate an array</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *);    <span class="comment">//free an array</span></span><br></pre></td></tr></table></figure>

<p>后面两个你可以先不看，后面再介绍。前面两个均是 C++ 标准库函数，你可能会觉得这是函数吗？请不要怀疑，这就是函数！C++ Primer 一书上说这不是重载 new 和 delete 表达式（如 operator= 就是重载 = 操作符），因为 new 和 delete 是不允许重载的。但我还没搞清楚为什么要用 operator new 和 operator delete 来命名，比较费解。我们只要知道它们的意思就可以了，这两个函数和 C 语言中的 malloc 和 free 函数有点像了，都是用来申请和释放内存的，并且 operator new 申请内存之后不对内存进行初始化，直接返回申请内存的指针。</p>
<p>我们可以直接在我们的程序中使用这几个函数。</p>
<p>new 和 delete 背后机制<br>知道上面两个函数之后，我们用一个实例来解释 new 和 delete 背后的机制：</p>
<p>我们不用简单的 C++ 内置类型来举例，使用复杂一点的类类型，定义一个类 A：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> v) : var(v)</span><br><span class="line">    &#123;</span><br><span class="line">        fopen_s(&amp;file, <span class="string">"test"</span>, <span class="string">"r"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    FILE *file;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很简单，类 A 中有两个私有成员，有一个构造函数和一个析构函数，构造函数中初始化私有变量 var 以及打开一个文件，析构函数关闭打开的文件。</p>
<p>我们使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> *<span class="title">pA</span> = <span class="title">new</span> <span class="title">A</span>(10);</span></span><br></pre></td></tr></table></figure>

<p>来创建一个类的对象，返回其指针 pA。如下图所示 new 背后完成的工作：</p>
<p>简单总结一下：</p>
<p>首先需要调用上面提到的 operator new 标准库函数，传入的参数为 class A 的大小，这里为 8 个字节，至于为什么是 8 个字节，你可以看看《深入 C++ 对象模型》一书，这里不做多解释。这样函数返回的是分配内存的起始地址，这里假设是 0x007da290。<br>上面分配的内存是未初始化的，也是未类型化的，第二步就在这一块原始的内存上对类对象进行初始化，调用的是相应的构造函数，这里是调用 A:A(10); 这个函数，从图中也可以看到对这块申请的内存进行了初始化，var=10, file 指向打开的文件。<br>最后一步就是返回新分配并构造好的对象的指针，这里 pA 就指向 0x007da290 这块内存，pA 的类型为类 A 对象的指针。<br>所有这三步，你都可以通过反汇编找到相应的汇编代码，在这里我就不列出了。</p>
<p>好了，那么 delete 都干了什么呢？还是接着上面的例子，如果这时想释放掉申请的类的对象怎么办？当然我们可以使用下面的语句来完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pA;</span><br></pre></td></tr></table></figure>

<p>delete 所做的事情如下图所示：</p>
<p>img<br>img</p>
<p>delete 就做了两件事情：</p>
<p>调用 pA 指向对象的析构函数，对打开的文件进行关闭。<br>通过上面提到的标准库函数 operator delete 来释放该对象的内存，传入函数的参数为 pA 的值，也就是 0x007d290。<br>好了，解释完了 new 和 delete 背后所做的事情了，是不是觉得也很简单？不就多了一个构造函数和析构函数的调用嘛。</p>
<p>如何申请和释放一个数组？<br>我们经常要用到动态分配一个数组，也许是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *psa = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>]; <span class="comment">//array of 10 empty strings</span></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//array of 10 uninitialized ints</span></span><br></pre></td></tr></table></figure>

<p>上面在申请一个数组时都用到了 new [] 这个表达式来完成，按照我们上面讲到的 new 和 delete 知识，第一个数组是 string 类型，分配了保存对象的内存空间之后，将调用 string 类型的默认构造函数依次初始化数组中每个元素；第二个是申请具有内置类型的数组，分配了存储 10 个 int 对象的内存空间，但并没有初始化。</p>
<p>如果我们想释放空间了，可以用下面两条语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] psa;</span><br><span class="line"><span class="keyword">delete</span> [] pia;</span><br></pre></td></tr></table></figure>

<p>都用到 delete [] 表达式，注意这地方的 [] 一般情况下不能漏掉！我们也可以想象这两个语句分别干了什么：第一个对 10 个 string 对象分别调用析构函数，然后再释放掉为对象分配的所有内存空间；第二个因为是内置类型不存在析构函数，直接释放为 10 个 int 型分配的所有内存空间。</p>
<p>这里对于第一种情况就有一个问题了：我们如何知道 psa 指向对象的数组的大小？怎么知道调用几次析构函数？</p>
<p>这个问题直接导致我们需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。</p>
<p>还是用图来说明比较清楚，我们定义了一个类 A，但不具体描述类的内容，这个类中有显示的构造函数、析构函数等。那么 当我们调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> \*<span class="title">pAa</span> = <span class="title">new</span> <span class="title">A</span>[3];</span></span><br></pre></td></tr></table></figure>

<p>时需要做的事情如下：</p>
<p>img<br>img</p>
<p>从这个图中我们可以看到申请时在数组对象的上面还多分配了 4 个字节用来保存数组的大小，但是最终返回的是对象数组的指针，而不是所有分配空间的起始地址。</p>
<p>这样的话，释放就很简单了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] pAa;</span><br></pre></td></tr></table></figure>

<p>img<br>img</p>
<p>这里要注意的两点是：</p>
<p>调用析构函数的次数是从数组对象指针前面的 4 个字节中取出；<br>传入 operator delete[] 函数的参数不是数组对象的指针 pAa，而是 pAa 的值减 4。<br>为什么 new/delete 、new []/delete[] 要配对使用？<br>其实说了这么多，还没到我写这篇文章的最原始意图。从上面解释的你应该懂了 new/delete、new[]/delete[] 的工作原理了，因为它们之间有差别，所以需要配对使用。但偏偏问题不是这么简单，这也是我遇到的问题，如下这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> \*pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> []pia;</span><br></pre></td></tr></table></figure>

<p>这肯定是没问题的，但如果把 delete []pia; 换成 delete pia; 的话，会出问题吗？</p>
<p>这就涉及到上面一节没提到的问题了。上面我提到了在 new [] 时多分配 4 个字节的缘由，因为析构时需要知道数组的大小，但如果不调用析构函数呢（如内置类型，这里的 int 数组）？我们在 new [] 时就没必要多分配那 4 个字节， delete [] 时直接到第二步释放为 int 数组分配的空间。如果这里使用 delete pia;那么将会调用 operator delete 函数，传入的参数是分配给数组的起始地址，所做的事情就是释放掉这块内存空间。不存在问题的。</p>
<p>这里说的使用 new [] 用 delete 来释放对象的提前是：对象的类型是内置类型或者是无自定义的析构函数的类类型！</p>
<p>我们看看如果是带有自定义析构函数的类类型，用 new [] 来创建类对象数组，而用 delete 来释放会发生什么？用上面的例子来说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> \*<span class="title">pAa</span> = <span class="title">new</span> <span class="title">class</span> <span class="title">A</span>[3];</span></span><br><span class="line"><span class="keyword">delete</span> pAa;</span><br></pre></td></tr></table></figure>

<p>那么 delete pAa; 做了两件事：</p>
<p>调用一次 pAa 指向的对象的析构函数；<br>调用 operator delete(pAa); 释放内存。<br>显然，这里只对数组的第一个类对象调用了析构函数，后面的两个对象均没调用析构函数，如果类对象中申请了大量的内存需要在析构函数中释放，而你却在销毁数组对象时少调用了析构函数，这会造成内存泄漏。</p>
<p>上面的问题你如果说没关系的话，那么第二点就是致命的了！直接释放 pAa 指向的内存空间，这个总是会造成严重的段错误，程序必然会奔溃！因为分配的空间的起始地址是 pAa 指向的地方减去 4 个字节的地方。你应该传入参数设为那个地址！</p>
<p>同理，你可以分析如果使用 new 来分配，用 delete [] 来释放会出现什么问题？是不是总会导致程序错误？</p>
<p>总的来说，记住一点即可：new/delete、new[]/delete[] 要配套使用总是没错的！</p>
<h1 id="关于-iostream-与-using-namespace-std-的解析"><a href="#关于-iostream-与-using-namespace-std-的解析" class="headerlink" title="关于 iostream 与 using namespace std 的解析"></a>关于 iostream 与 using namespace std 的解析</h1><p>当我们在使用 C++语法进行编程练习的时候，往往在代码的前两行会这样来写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include&lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>

<p>学过 C 语言的同学在学习 C++的时候是否会产生这样的疑惑呢：</p>
<p>练习 C 语言编程的时候，只需要声明一个头文件：#include&lt;stdio.h&gt;.而为什么在 C++中，却需要写出 include 和 using namespace std;这两行代码呢？</p>
<p>其中第一行 include 我们还勉强可以理解，它其实类似于 C 语言中的#include&lt;stdio.h&gt;，即：声明标准的输入输出头文件。然而 using namespace std 究竟起到了什么作用呢？</p>
<p>针对这个问题，网络上有很多专业的说法，但是长篇大论的内容，对于初学者来说实在头疼，根本看不进去，所以接下来我希望可以用简练的语言来解释清楚 using namespace std 的作用，以下的内容虽可能有些许冗余，但我相信是通俗易懂的，您只要能够一行行的看下去，一定能够完全看懂！</p>
<p>本人认为正确的学习顺序是：我们要做到先学会定义、使用和理解命名空间(namespace)，再回过头去研究 using namespace std;的作用，这样可以起到事半功倍的效果，那么接下来重点就来了。</p>
<p>定义命名空间<br>（1）简单的命名空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、定义命名空间 A</span></span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;<span class="comment">//在命名空间 A 中定义变量 a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个命名空间就是这样简单：在这个命名空间 A 中，有一个 int 型的变量，他的名字是“a”。那么我们接下来直接上难度！定义一个复杂的命名空间。</p>
<p>（2）复杂的命名空间</p>
<p>要求：定义命名空间 B，并在命名空间 B 中定义命名空间 C，并在命名空间 C 中定义结构体 Teacher</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、复杂的命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> B <span class="comment">//定义命名空间 B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;<span class="comment">//在命名空间 B 中也可以定义变量 a，因为他们不在同一个命名空间中</span></span><br><span class="line"><span class="keyword">namespace</span> C<span class="comment">//还可以在命名空间 B 中再定义一个命名空间 C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span>//在命名空间 <span class="title">C</span> 中定义结构体 <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">32</span>];<span class="comment">//结构体中还可以定义变量 a，因为这三个“a”都不在同一个命名空间中</span></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用命名空间<br>（1）使用命名空间的基本方法</p>
<p>前面已经定义好了命名空间 A、B、C，且在这三个命名空间中都定义相同的变量“a”，接下来我们就来使用这三个命名空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用命名空间的基本方法 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;<span class="comment">//告诉编译器我要使用命名空间 A 中的功能了</span></span><br><span class="line">a=<span class="number">10</span>; <span class="comment">//将命名空间 A 中的变量“a”由 0 更改为 10</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//查看是否完成了更改，此时屏幕上应该输出“10</span></span><br></pre></td></tr></table></figure>

<p>注：此时只使用了命名空间 A，所以只会对命名空间 A 中的变量 a 进行访问，而不会对命名空间 B、C 中的变量 a 进行访问。</p>
<p>而实际上，针对上面这三行代码，只要第三行代码中变量“a”的指向明确，便可以省去第一行“using namespace A”，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用命名空间的基本方法 2</span></span><br><span class="line"><span class="comment">//由于在代码中只要使用这两种方法中的其中一种即可，所以我在第二种方法这里加上的“//”注释符号，如下两行代码：</span></span><br><span class="line"><span class="comment">// a=10;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;A::a&lt;&lt;endl; //“A::a”明确指向了命名空间 A 中的变量 a（用双冒号::）</span></span><br></pre></td></tr></table></figure>

<p>以上两种使用命名空间的方法供君随意挑选^_^</p>
<p>（2）使用复杂的命名空间</p>
<p>命名空间 A 的使用相对简单，但是在命名空间 B 中嵌套着命名空间 C，并且命名空间 C 中又嵌套着结构体 Teacher，那么我们又该如何去使用命名空间 B 和命名空间 C 呢？</p>
<p>接下来，除了使用命名空间 A 以外，如果我们还使用了命名空间 B 的话，” a=10; “ 这条语句的指向就不明确了：因为命名空间 B 中也有个变量 a，于是现在有两个”a”可以被访问。故：若想访问某一个特定的变量 a 就需要指向明确！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line"><span class="comment">//如果想访问某一个特定的变量 a，就需要指向明确！如下：</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;A::a&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//明确指向了“命名空间 A”</span></span><br><span class="line"><span class="comment">//虽然现在有 A、B 两个命名空间，且两个命名空间中都有变量“a”，但只要指向明确，就能指定我们所访问的变量究竟是命名空间 A 中的“a”还是命名空间 B 中的“a”</span></span><br></pre></td></tr></table></figure>

<p>（3）使用结构体 Teacher 中的变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何使用 Teacher</span></span><br><span class="line"><span class="comment">//方法 1：这种方法每定义一个结构体就需要：“B::C::Teacher 结构体名称”</span></span><br><span class="line"><span class="comment">//B::C::Teacher t1;//用命名空间 B 中的命名空间 C 中的结构体模板（Teacher）来定义结构体 t1</span></span><br><span class="line"><span class="comment">//t1.b=33;//注意：t1.a 语法错误！是因为 a 是一个指针（地址），这个指针是无法被修改的，否则以后无法释放内存</span></span><br><span class="line"> <span class="comment">//方法 2：先一口气直接定义好“结构体型”数据类型，然后按照根据数据类型定义变量的方法来使用结构体</span></span><br><span class="line"><span class="keyword">using</span> B::C::Teacher;</span><br><span class="line">Teacher t2;</span><br><span class="line">t2.b=<span class="number">22</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 iostream 与 using namespace std 的解析****<br>（1）通过以上关于命名空间的定义及使用的介绍，我们不难发现：不同的命名空间之间是相互独立的个体，虽然附加在其中的变量名可能是相同的（比如上面所提到的命名空间 A、B、C 中都包含有变量 a），但是没关系：“命名空间” 这层 “屏障”将这些相同的变量名分隔开来，让他们虽然拥有相同的名字，但是互不影响。</p>
<p>（2）看起来命名空间的引入十分方便，让我们不必再因为变量重名而烦恼。但是在以前，并没有命名空间这个概念，而是将标准库功能定义在全局空间里，并声明在&lt;iostream.h&gt;（早期的 C++头文件）中。但是由于标准库非常的庞大，那么程序员在选择的类的名称或函数名时，就很有可能和标准库中的某个名字相同。所以为了避免这种情况所造成的名字冲突，就把标准库中的一切都放在一个名为 std 的命名空间中。后来 C++标准为了和 C 区别开，也为了正确使用命名空间，规定头文件不使用后缀.h，即出现了现在的头文件。</p>
<p>（3）当使用的时候，该头文件没有定义全局命名空间，必须使用 C++所规定的标准的命名空间（即：namespace std），这样才能正确使用 cout、endl 等功能。</p>
<p>（4）最后：如果大家想进一步了解相关内容，请参考：点击打开链接 谢谢。</p>
<h1 id="c-定义结构体"><a href="#c-定义结构体" class="headerlink" title="c++定义结构体"></a>c++定义结构体</h1><p>先定义结构体类型再单独进行变量定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ```cpp;</span><br><span class="line"><span class="keyword">char</span> Name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> Sex;</span><br><span class="line"><span class="keyword">int</span> Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">Stu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">Stu</span>[10];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> \*<span class="title">pStru</span>;</span></span><br></pre></td></tr></table></figure>

<p>结构体类型是 struct Student，因此，struct 和 Student 都不能省略。但实际上，我用 ```cppblocks 运行时，下面变量的定义，不加 struct 也是可以的。</p>
<p>紧跟在结构体类型说明之后进行定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ```cpp;</span><br><span class="line"><span class="keyword">char</span> Name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> Sex;</span><br><span class="line"><span class="keyword">int</span> Age;</span><br><span class="line">&#125;Stu,Stu[<span class="number">10</span>],\*pStu;</span><br></pre></td></tr></table></figure>

<p>这种情况时，后面还可以再定义结构体变量。</p>
<p>在说明一个无名结构体变量的同时直接进行定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ```cpp;</span><br><span class="line"><span class="keyword">char</span> Name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> Sex;</span><br><span class="line"><span class="keyword">int</span> Age;</span><br><span class="line">&#125;Stu,Stu[<span class="number">10</span>],\*pStu;</span><br></pre></td></tr></table></figure>

<p>这种情况下，之后不能再定义其他变量。</p>
<p>使用 typedef 说明一个结构体变量之后再用新类名来定义变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ```cpp;</span><br><span class="line"><span class="keyword">char</span> Name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> Sex;</span><br><span class="line"><span class="keyword">int</span> Age;</span><br><span class="line">&#125;student;</span><br></pre></td></tr></table></figure>

<p>Student Stu,Stu[10],*pStu;<br>Student 是一个具体的结构体类型，唯一标识。这里不用再加 struct</p>
<h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p>什么是同步与异步<br>定义：同步和异步关注的是<em>消息通信机制</em> (synchronous communication/ asynchronous communication)。同步，就是调用某个东西是，调用方得等待这个调用返回结果才能继续往后执行。异步，和同步相反 调用方不会理解得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状体来通知调用者，或者通过回掉函数来处理这个调用**</p>
<p>比方说：你去商城买东西，你看上了一款手机，能和店家说你一个这款手机，他就去仓库拿货，你得在店里等着，不能离开，这叫做同步。现在你买手机赶时髦直接去京东下单，下单完成后你就可用做其他时间（追剧、打王者、lol）等货到了去签收就 ok 了.这就叫异步。</p>
<p>以方法调用为例<br>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。<br>异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作<br>加两张图更好理解<br>同步执行</p>
<p>img<br>img</p>
<p>同步执行当调用方法执行完成后并返回结果，才能执行后续代码</p>
<p>异步执行</p>
<p>img<br>img</p>
<p>异步调用的话可用参考 ajax，调用方法后不会等到 sum 方法执行完成，而是直接执行后续代码。sum 方法执行完成后主要通过状态通知主线程，或者通过回调处理这次异步方法执行的结果</p>
<p>同步异步于阻塞非阻塞不能混为一谈<br>看了上面的讲解，你可能会说这不就是阻塞机制吗？不不不，同步异步不能和阻塞非阻塞混为一谈。</p>
<p>阻塞和非阻塞 强调的是程序在等待调用结果（消息，返回值）时的状态. 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 对于同步调用来说，很多时候当前线程还是激活的状态，只是从逻辑上当前函数没有返回而已，即同步等待时什么都不干，白白占用着资源。</p>
<p>同步和异步强调的是消息通信机制 (synchronous communication/ asynchronous communication)。所谓同步，就是在发出一个”调用”时，在没有得到结果之前，该“调用”就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由“调用者”主动等待这个“调用”的结果。而异步则是相反，”调用”在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在”调用”发出后，”被调用者”通过状态、通知来通知调用者，或通过回调函数处理这个调用</p>
<p>参考博客：<a href="https://blog.csdn.net/huangqiang1363/article/details/79508852" target="_blank" rel="noopener">https://blog.csdn.net/huangqiang1363/article/details/79508852</a></p>
<p>c 语言分区<br>栈 Stack（大地址，由高向低使用）<br>堆 Heap（由低向高使用）<br>全局 or 静态常量区<br>文本 and 代码区（小地址）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>; <span class="comment">//全局 or 静态常量区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hehe</span><span class="params">()</span> </span>&#123; <span class="comment">//函数,在 stack 中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> he = <span class="number">0</span>; <span class="comment">//全局 or 静态常量区，因为 static 只会创建一次</span></span><br><span class="line">he++;</span><br><span class="line">total++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">3</span>; <span class="comment">//函数的内部变量，在 stack 中，但 3 在代码区</span></span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">"Hello, world!"</span>; <span class="comment">// str 函数中内部变量，在 stack 中，“hello world”在常量区</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// p 在 stack 中，malloc 动态分配的内存在堆中</span></span><br><span class="line">hehe();</span><br><span class="line">hehe();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d%s%d"</span>, k, str, *p);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//stack 中内存释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：类是一个模板，它描述一类对象的行为和状态。<br>对象：对象是类的一个实例<br>c 语言如何处理类和对象：</p>
<p>没有“类”，只有“类型”</p>
<p>没有“对象”，只有“变量”</p>
<p>结构体变量+函数</p>
<p>c 语言采用结构体变量+函数的方式来实现类似功能，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printID</span><span class="params">(struct Student \*in)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"My id is %d.\n"</span>,in-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">one</span>;</span></span><br><span class="line">one.id=<span class="number">999</span>;</span><br><span class="line">printID(&amp;one);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但我们发现，Student 的属性和加在属性上的操作是割裂开的，我们可以使用函数指针类解决此问题</p>
<p>函数指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">void</span> (*printID)(struct Student *in);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printID</span><span class="params">(struct Student \*in)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"My id is %d.\n"</span>,in-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">one</span>;</span></span><br><span class="line">one.id=<span class="number">999</span>;</span><br><span class="line">one.printID=printID;</span><br><span class="line">one.printID(&amp;one);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="不一样的体验，用纯文本命令行写-C-程序"><a href="#不一样的体验，用纯文本命令行写-C-程序" class="headerlink" title="不一样的体验，用纯文本命令行写 C++程序"></a>不一样的体验，用纯文本命令行写 C++程序</h1><p>打开 vmware 运行 ubuntu<br>桌面右键打开终端<br>输入命令 ls 查看当前所在位置<br>输入命令 cd 桌面进入桌面这个文件夹<br>输入命令 touch test.cpp 创建 test.cpp 文件<br>打开 test.cpp 文件，输入以下代码并保存在这里插入图片描述<br>在这里插入图片描述<br>输入命令 g++ test.cpp 编译 test.cpp 文件，我们发现桌面上产生了一个新的文件 a.out，这就是编译产生的可执行文件，接下来我们运行之<br>输入命令./a.out 运行，发现如下输出：在这里插入图片描述<br>在这里插入图片描述</p>
<h1 id="c-的新特性"><a href="#c-的新特性" class="headerlink" title="c++的新特性"></a>c++的新特性</h1><p>类（class)<br>之前说过了</p>
<p>bool 类型和 auto 类型<br>bool，c 语言中，真假用整形来代替，0 –&gt;False &amp;&amp; !0–&gt;True &amp;&amp; True–&gt; &amp;&amp; False–&gt;0</p>
<p>c++中，可以 true，false，也可以用 0 和 1</p>
<p>auto，让编译器推断是什么类型，但必须在初始化时赋值，否则编译报错</p>
<p>cout，在打印浮点数是会省略后面的部分</p>
<p>引用<br>C<br>int a = 3; //定义了变量 a，并用 3 使其初始化，=不是运算符=含义是初始化<br>int b; //定义了变量 b，没有初始化<br>b = 3; //把 3 赋值给 b，=是运算符</p>
<p>int array[10]={1,2,3}; //定义了数组 array，并用{1,2,3}使其初始化<br>array={1,2,3}; //错误<br>array[10]={1,2,3}; //错误<br>C<br>int *p; // *的含义是 p 是一个指针，不是取值运算符，p 是指向 int 类型的指针<br>int a = 3;<br>p = &a;<br>*p = 6; // *的是取值运算符<br>C<br>int b = 6;<br>int &amp;r = b; // &amp;的含义是 r 是一个引用类型，不是取地址运算符，r 是 int 类型的引用，=表示用 b 来初始化 r，让 r 成为 b 的引用，不是赋值，可以理解为给 b 起个外号，自此之后 r 就是 b，b 就是 r<br>r = 123;<br>cout &lt;&lt; r &lt;&lt; endl; // 123<br>cout &lt;&lt; b &lt;&lt; endl; // 123<br>在 C++中函数的参数传递：</p>
<p>按值传递(pass by value)<br>地址传递(pass by pointer)<br>引用传递(pass by reference)<br>引用必须在定义时初始化，一旦创建就不可更换引用的对象</p>
<p>C<br>int b = 6;<br>int &r; //error: ‘r’ declared as reference but not initialized<br>r = b; //把 b 的值赋值给 r，但此时 r 并没有任何的引用<br>关于赋值<br>C<br>int a, b, c;<br>(a = b = c = 3) = 666;<br>cout &lt;&lt; a &lt;&lt; endl; //666<br>cout &lt;&lt; b &lt;&lt; endl; //3<br>cout &lt;&lt; c &lt;&lt; endl; //3<br>赋值之后返回的是左值的引用</p>
<p>初始化的新语法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a&#123;<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">new</span> 和 <span class="keyword">delete</span></span><br></pre></td></tr></table></figure>

<p>int _p;<br>p = (int _) malloc(sizeof(int));<br>free(p);<br>p = new int;<br>delete p;<br>deleete[] p; //复杂类型应该这样写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> sid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Student one, two;</span><br><span class="line">one.sid = <span class="number">1</span>;</span><br><span class="line">two.sid = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;one &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;two &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">one = two;</span><br><span class="line">two.sid = <span class="number">999</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;one &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;two &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> sid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Student *one = <span class="keyword">new</span> Student();</span><br><span class="line">Student *two = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">// Student *one, *two;</span></span><br><span class="line"><span class="comment">// one = new Student();</span></span><br><span class="line"><span class="comment">// two = new Student();</span></span><br><span class="line">one-&gt;sid = <span class="number">1</span>;</span><br><span class="line">two-&gt;sid = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;one &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0x63fde8</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;two &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0x63fde0</span></span><br><span class="line">one = two; <span class="comment">//内存泄漏</span></span><br><span class="line">two-&gt;sid = <span class="number">999</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0x1c1770</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; two &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0x1c1770</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步理解 Java 的引用，相当于 c++中的指针，java 的引用和 c++的引用是不一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> sid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">Student one = <span class="keyword">new</span> Student(); <span class="comment">//创建对象一定需要 new</span></span><br><span class="line">Student two = <span class="keyword">new</span> Student();</span><br><span class="line"> one.sid = <span class="number">1</span>;</span><br><span class="line">two.sid = <span class="number">2</span>;</span><br><span class="line">System.out.println(<span class="string">"one: "</span> + one); <span class="comment">//one: Student@7291c18f</span></span><br><span class="line">System.out.println(<span class="string">"two: "</span> + two); <span class="comment">//two: Student@34a245ab</span></span><br><span class="line">one = two;</span><br><span class="line">two.sid = <span class="number">999</span>;</span><br><span class="line">System.out.println(<span class="string">"one: "</span> + one); <span class="comment">//one: Student@34a245ab</span></span><br><span class="line">System.out.println(<span class="string">"two: "</span> + two); <span class="comment">//two: Student@34a245ab</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新的 for 循环<br>for-each 不再赘述，可以使用 auto，each 是取出来的容器里的值，&amp;each 可以修改容器里本来的值</p>
<p>在这里插入图片描述<br>在这里插入图片描述</p>
<p>在这里插入图片描述<br>在这里插入图片描述</p>
<p>重载<br>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p>
<p>在同一个作用域内，可以声明几个同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。不能仅通过返回类型的不同来重载函数。</p>
<p>我们可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<p>注：在一个函数声明中，const 可以修饰形参表明他是一个输入参数，在函数内部不可以改变其值；</p>
<p>lambda</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) -&gt; <span class="keyword">auto</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f(<span class="number">3.1</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8.1</span></span><br></pre></td></tr></table></figure>

<h1 id="泛型和模板"><a href="#泛型和模板" class="headerlink" title="泛型和模板"></a>泛型和模板</h1><p>泛型是概念, 模板是泛型的实现<br>泛型编程让你编写完全一般化并可重复使用的算法，其效率与针对某特定数据类型而设计的算法相同。泛型编程的代表作品 STL 是一种高效、泛型、可交互操作的软件组件。所谓泛型(Genericity)，是指具有在多种数据类型上皆可操作的含意，与模板有些相似。STL 巨大，而且可以扩充，它包含很多计算机基本算法和数据结构，而且将算法与数据结构完全分离，其中算法是泛型的，不与任何特定数据结构或对象类型系在一起。STL 以迭代器(Iterators)和容器(Containers)为基础，是一种泛型算法(Generic Algorithms)库，容器的存在使这些算法有东西可以操作。STL 包含各种泛型算法(algorithms)、泛型指针(iterators)、泛型容器(containers)以及函数对象(function objects)。STL 并非只是一些有用组件的集合，它是描述软件组件抽象需求条件的一个正规而有条理的架构。</p>
<h1 id="C-语言-运算符和-amp-运算符"><a href="#C-语言-运算符和-amp-运算符" class="headerlink" title="C 语言*运算符和&amp;运算符"></a>C 语言*运算符和&amp;运算符</h1><p>取址运算符&amp;用来取得其操作数的地址。如果操作数 x 的类型为 T，则表达式 &amp;x 的类型是 T 类型指针（指向 T 的指针）。</p>
<p>取址运算符的操作数必须是在内存中可寻址到的地址。换句话说，该运算符只能用于函数或对象（例如左值），而不可以用于位字段，以及那些还未被存储类修饰符 register 声明的内容。</p>
<p>当需要初始化指针，以指向某些对象或函数时，需要获得这些对象或函数的地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> x, _ptr;ptr = &amp;x; <span class="comment">// 合法：使得指针 ptr 指向 xptr = &amp;(x+1); // 错误： (x+1) 不是一个左值</span></span><br></pre></td></tr></table></figure>

<p>相反地，当已具有一个指针，并且希望获取它所引用的对象时，使用间接运算符 _（indirection operator），有时候这会被称为解引用运算符（dereferencing operator）。它的操作数必须是指针类型。如果 ptr 是指针，那么 <em>ptr 就是 ptr 所指向的对象或函数。如果 ptr 是一个对象指针，那么 *ptr 就是一个左值，可以把它（即 \</em>ptr）当作赋值运算符左边的操作数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> x, *ptr = &amp;x;*ptr = <span class="number">1.7</span>; <span class="comment">// 将 1.7 赋值给变量 x++(\*ptr); // 并将变量 x 的值加 1</span></span><br></pre></td></tr></table></figure>

<p>在这个示例最后的语句中，ptr 的值保持不变，但 x 的值变成 2.7。</p>
<p>如果指针操作数的值不是某个对象或函数的地址，则间接运算符*的操作结果无法确定。</p>
<p>像其他一元操作数一样，运算符 &amp; 和 * 具有很高的优先级。操作数的组合方式是从右到左。因此，表达式 ++（*ptr）中的括号是没有必要的。</p>
<p>运算符 &amp; 和 * 是互补的：如果 x 是一个表达式，用于指定一个对象或一个函数，那么表达式 &amp;x 就等于 x。相反地，在形如 &amp;ptr 的表达式中，这些运算符会互相抵消，表达式的类型与值等效于 ptr。然而，不管 ptr 是不是左值，&amp;*ptr 都一定不会是左值。</p>
<h1 id="理解封装"><a href="#理解封装" class="headerlink" title="理解封装"></a>理解封装</h1><p>类里有什么<br>数据（属性）<br>操作（函数、方法）<br>访问控制（公有/私有）<br>静态/非静态<br>直接使用类：静态<br>使用对象：静态和非静态<br>静态不能访问非静态</p>
<h1 id="使用类和对象"><a href="#使用类和对象" class="headerlink" title="使用类和对象"></a>使用类和对象</h1><p>定义类和对象</p>
<h1 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h1><p>代码复用的手段<br>函数重载<br>类的继承，动态<br>借口</p>
<h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>构造函数使用初始化列表来初始化字段</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Line::Line( <span class="keyword">double</span> len): length(len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created, length = "</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的语法等同于如下语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line::Line( <span class="keyword">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">length = len;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created, length = "</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在不同的字段使用逗号进行分隔，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C::C( <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c): X(a), Y(b), Z(c)</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="模板（Template）"><a href="#模板（Template）" class="headerlink" title="模板（Template）"></a>模板（Template）</h1><p>函数模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Zhenglin Li on 2020/9/23.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">T s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">s += <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a1[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> a2[<span class="number">3</span>] = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(a1, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(a2, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(a2, <span class="number">1</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数模板的重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Zhenglin Li on 2020/9/23.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">T s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">s += <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T <span class="built_in">array</span>[], <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">T s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = from - <span class="number">1</span>; i &lt;= to - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">s += <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a1[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> a2[<span class="number">3</span>] = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(a1, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(a2, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(a2, <span class="number">1</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Zhenglin Li on 2020/9/23.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T x;</span><br><span class="line">T y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Vector(T x = <span class="number">0</span>, T y = <span class="number">0</span>) : x(x), y(y) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;o, <span class="keyword">const</span> Vector&lt;T&gt; &amp;v) &#123;</span><br><span class="line">        o &lt;&lt; <span class="string">"&lt;"</span> &lt;&lt; v.x &lt;&lt; <span class="string">", "</span> &lt;&lt; v.y &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//真正的类，要&lt;&gt;</span></span><br><span class="line"><span class="function">Vector&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">Vector&lt;<span class="keyword">double</span>&gt; *p = <span class="keyword">new</span> Vector&lt;<span class="keyword">double</span>&gt;(<span class="number">1.1</span>,<span class="number">2.2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准模板库（STL）<br>Standard Template Library<br>很多容器<br>很多算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Zhenglin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://9pshr3.coding-pages.com/2023/01/18/A%20first%20look%20at%20C++%20(8)/">http://9pshr3.coding-pages.com/2023/01/18/A%20first%20look%20at%20C++%20(8)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://9pshr3.coding-pages.com" target="_blank">熊儿老猫的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-6.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="../assets/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/../assets/wechatpay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="../assets/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/../assets/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/01/18/A%20first%20look%20at%20C++%20(7)/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-8.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">A first look at C++ (7)</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-6.webp)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Zhenglin Li</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script defer="defer" id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script></div><script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-90},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.3,"opacityOnHover":0.3,"opacity":0.95},"log":false});</script></body></html>