<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>八大排序算法详解 | 熊儿老猫的博客</title><meta name="description" content="八大排序算法详解（动图演示 思路分析 实例代码java 复杂度分析 适用场景） 一、分类1.内部排序和外部排序　 内部排序：待排序记录存放在计算机随机存储器中（说简单点，就是内存）进行的排序过程。 外部排序：待排序记录的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中需要对外存进行访问的排序过程。   2.比较类排序和非比较排序 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂"><meta name="author" content="Zhenglin Li"><meta name="copyright" content="Zhenglin Li"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://9pshr3.coding-pages.com/2020/09/16/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="八大排序算法详解"><meta property="og:url" content="http://9pshr3.coding-pages.com/2020/09/16/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"><meta property="og:site_name" content="熊儿老猫的博客"><meta property="og:description" content="八大排序算法详解（动图演示 思路分析 实例代码java 复杂度分析 适用场景） 一、分类1.内部排序和外部排序　 内部排序：待排序记录存放在计算机随机存储器中（说简单点，就是内存）进行的排序过程。 外部排序：待排序记录的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中需要对外存进行访问的排序过程。   2.比较类排序和非比较排序 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-2.webp"><meta property="article:published_time" content="2020-09-15T16:12:20.000Z"><meta property="article:modified_time" content="2020-09-16T01:21:56.788Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'true'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?0773dcadd0397be86eb74da114bd1757";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-16 09:21:56'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、分类"><span class="toc-number">1.</span> <span class="toc-text">一、分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-内部排序和外部排序"><span class="toc-number">1.1.</span> <span class="toc-text">1.内部排序和外部排序　</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-比较类排序和非比较排序"><span class="toc-number">1.2.</span> <span class="toc-text">2.比较类排序和非比较排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、复杂度分析，算法稳定性和适用场景"><span class="toc-number">2.</span> <span class="toc-text">二、复杂度分析，算法稳定性和适用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、八大排序算法详解"><span class="toc-number">3.</span> <span class="toc-text">三、八大排序算法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-选择排序"><span class="toc-number">3.1.</span> <span class="toc-text">1.选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-冒泡排序"><span class="toc-number">3.2.</span> <span class="toc-text">2. 冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-直接插入排序"><span class="toc-number">3.3.</span> <span class="toc-text">3. 直接插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-快速排序"><span class="toc-number">3.4.</span> <span class="toc-text">4. 快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-归并排序"><span class="toc-number">3.5.</span> <span class="toc-text">5. 归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-基数排序"><span class="toc-number">3.6.</span> <span class="toc-text">6. 基数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-希尔（shell）排序"><span class="toc-number">3.7.</span> <span class="toc-text">7. 希尔（shell）排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-堆排序"><span class="toc-number">3.8.</span> <span class="toc-text">8. 堆排序</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-2.webp)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">熊儿老猫的博客</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">八大排序算法详解</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-15T16:12:20.000Z" title="发表于 2020-09-16 00:12:20">2020-09-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-16T01:21:56.788Z" title="更新于 2020-09-16 09:21:56">2020-09-16</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><a href="https://www.cnblogs.com/l199616j/p/10742603.html" target="_blank" rel="noopener">八大排序算法详解（动图演示 思路分析 实例代码java 复杂度分析 适用场景）</a></p>
<h1 id="一、分类"><a href="#一、分类" class="headerlink" title="一、分类"></a><strong>一、分类</strong></h1><h2 id="1-内部排序和外部排序"><a href="#1-内部排序和外部排序" class="headerlink" title="1.内部排序和外部排序　"></a><strong>1.内部排序和外部排序</strong>　</h2><ul>
<li><strong>内部排序</strong>：待排序记录存放在计算机随机存储器中（说简单点，就是内存）进行的排序过程。</li>
<li><strong>外部排序</strong>：待排序记录的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中需要对外存进行访问的排序过程。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190420100103564-1484547501.png" alt=""></p>
<h2 id="2-比较类排序和非比较排序"><a href="#2-比较类排序和非比较排序" class="headerlink" title="2.比较类排序和非比较排序"></a><strong>2.比较类排序和非比较排序</strong></h2><ul>
<li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li>
<li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。<br><img src= "/img/loading.gif" data-lazy-src="https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190420193244916-2091485181.png" alt=""></li>
</ul>
<h1 id="二、复杂度分析，算法稳定性和适用场景"><a href="#二、复杂度分析，算法稳定性和适用场景" class="headerlink" title="二、复杂度分析，算法稳定性和适用场景"></a><strong>二、复杂度分析，算法稳定性和适用场景</strong></h1><ul>
<li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 </li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190420193530213-2111577377.png" alt=""></p>
<h1 id="三、八大排序算法详解"><a href="#三、八大排序算法详解" class="headerlink" title="三、八大排序算法详解"></a><strong>三、八大排序算法详解</strong></h1><h2 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1.选择排序"></a><strong>1.选择排序</strong></h2><p><strong>1.1 动图演示</strong></p>
<iframe height=100 width=100 src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190325085919297-1818609484.gif">





<p><strong>1.2 思路分析</strong></p>
<p><strong>1.</strong> <strong>第一个跟后面的所有数相比，</strong>如果小于（或小于）第一个数的时候，暂存较小数的下标，第一趟结束后，将第一个数，与暂存的那个最小数进行交换，第一个数就是最小（或最大的数）</p>
<p><strong>2.</strong> 下标移到第二位，第二个数跟后面的所有数相比，一趟下来，确定第二小（或第二大）的数</p>
<p>重复以上步骤</p>
<p>直到指针移到倒数第二位，确定倒数第二小（或倒数第二大）的数，那么最后一位也就确定了，排序完成。</p>
<p><strong>1.3 复杂度分析</strong></p>
<p><strong>1.</strong> 不管原始数组是否有序，<strong>时间复杂度都是O（n2）</strong>，</p>
<p>因为没一个数都要与其他数比较一次，（n-1）2次，分解：n2-2n+1, 去掉低次幂和常数，剩下n2,所以最后的时间复杂度是n2</p>
<p><strong>2. 空间复杂度是O（1）</strong>,因为只定义了两个辅助变量，与n的大小无关，所以空间复杂度为O（1）</p>
<p> <strong>1.4 Java 代码如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] n &#x3D; new int[]&#123;1,6,3,8,33,27,66,9,7,88&#125;;</span><br><span class="line">        int temp,index &#x3D; -1;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n.length-1; i++) &#123;</span><br><span class="line">            index&#x3D;i;</span><br><span class="line">            &#x2F;&#x2F;如果大于，暂存较小的数的下标</span><br><span class="line">            for (int j &#x3D; i+1; j &lt;n.length; j++) &#123;</span><br><span class="line">                if(n[index]&gt;n[j])&#123;</span><br><span class="line">                    index &#x3D; j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;&#x2F;&#x2F;将一趟下来求出的最小数，与这个数交换</span><br><span class="line">            if(index&gt;0)&#123;</span><br><span class="line">                temp &#x3D; n[i];</span><br><span class="line">                n[i] &#x3D; n[index];</span><br><span class="line">                n[index] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(n));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a><strong>2. 冒泡排序</strong></h2><p><strong>2.1 动图演示</strong></p>
<iframe height=100 width=100 src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190325093445247-432584102.gif">



<p><strong>2.2 思路分析</strong></p>
<p><strong>1.</strong> <strong>相邻两个数两两相比</strong>，n[i]跟n[j+1]比，如果n[i]&gt;n[j+1]，则将连个数进行交换，**<br>**</p>
<p>\2. j++, 重复以上步骤，第一趟结束后，最大数就会被确定在最后一位，这就是冒泡排序又称大（小）数沉底，</p>
<p>\3. i++,重复以上步骤，直到i=n-1结束，排序完成。</p>
<p><strong>2.3 复杂度分析</strong></p>
<p><strong>1.</strong> 不管原始数组是否有序，<strong>时间复杂度都是O（n2）</strong>，</p>
<p>因为没一个数都要与其他数比较一次，（n-1）2次，分解：n2+2n-1, 去掉低次幂和常数，剩下n2,所以最后的时间复杂度是n2</p>
<p><strong>2. 空间复杂度是O（1）</strong>,因为只定义了一个辅助变量，与n的大小无关，所以空间复杂度为O（1）</p>
<p><strong>2.4 选择排序和冒泡排序的比较</strong></p>
<p>\1. 时间负责度都是O（n2）</p>
<p>\2. 空间复杂度都是O（1）</p>
<p>\3. 选择排序是从第一位开始确定最大或最小的数，保证前面的数都是有序的，且都比后面的数小或大，</p>
<p>　 冒泡排序是从最后一位开始确定最大或最小的数，保证后面的数都是有序的且都大于或小于前面的数。</p>
<p><strong>2.5 Java 代码如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class 冒泡 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] n &#x3D; new int[]&#123;1,6,3,8,33,27,66,9,7,88&#125;;</span><br><span class="line">        int temp;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n.length-1; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt;n.length-1; j++) &#123;</span><br><span class="line">                if(n[j]&gt;n[j+1])&#123;</span><br><span class="line">                    temp &#x3D; n[j];</span><br><span class="line">                    n[j] &#x3D; n[j+1];</span><br><span class="line">                    n[j+1] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3. 直接插入排序"></a><strong>3. 直接插入排序</strong></h2><p><strong>3.1 动图演示</strong></p>
<iframe height=100 width=100 src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190325144034879-1237555952.gif">





<p><strong>3.2 思路分析</strong></p>
<p>例如从<strong>小到大</strong>排序:</p>
<p><strong>1.</strong> 从第二位开始遍历，</p>
<p><strong>2.</strong> 当前数（第一趟是第二位数）<strong>与前面的数依次比较，如果前面的数大于当前数，则将这个数放在当前数的位置上，当前数的下标-1</strong>，**<br>**</p>
<p><strong>3. 重复以上步骤，直到当前数不大于前面的某一个数为止，这时，将当前数，放到这个位置，</strong></p>
<p>　　1-3步就是保证当前数的前面的数都是有序的，内层循环的目的就是将当前数插入到前面的有序序列里</p>
<p><strong>4.</strong> 重复以上3步，直到遍历到最后一位数，并将最后一位数插入到合适的位置，插入排序结束。</p>
<p>根据思路分析，每一趟的执行流程如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190325151805019-1065720478.png" alt=""></p>
<p><strong>3.3 复杂度分析</strong></p>
<p><strong>1. 时间复杂度：</strong>插入算法，就是保证前面的序列是有序的，只需要把当前数插入前面的某一个位置即可。</p>
<p>   所以如果数组本来就是有序的，则数组的<strong>最好情况下时间复杂度为O（n）</strong></p>
<p>   如果数组恰好是倒=倒序，比如原始数组是5 4 3 2 1，想要排成从小到大，则每一趟前面的数都要往后移，一共要执行n-1 + n-2 + … + 2 + 1 = n * (n-1) / 2 = <strong>0.5 * n2 - 0.5 * n</strong>次，去掉低次幂及系数，所以<strong>最坏情况下时间复杂度为O（n2）</strong></p>
<p>  平均时间复杂度(n+n2 )/2，所以<strong>平均时间复杂度为O（n2）</strong></p>
<p><strong>2. 空间复杂度：</strong>插入排序算法，只需要两个变量暂存当前数，以及下标，与n的大小无关，所以<strong>空间复杂度为：O（1）</strong></p>
<p><strong>3.4 Java 代码如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class insertSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] n &#x3D; new int[]&#123;20,12,15,1,5,49,58,24,578,211,20,214,78,35,125,789,11&#125;;</span><br><span class="line">        int temp &#x3D; 0,j;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n.length; i++) &#123;</span><br><span class="line">            temp &#x3D; n[i];</span><br><span class="line">            for (j &#x3D; i; j &gt;0; j--) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果当前数前面的数大于当前数，则把前面的数向后移一个位置</span><br><span class="line">                if(n[j-1]&gt;temp)&#123;</span><br><span class="line">                    n[j] &#x3D; n[j-1];</span><br><span class="line">                    </span><br><span class="line">                    &#x2F;&#x2F;第一个数已经移到第二个数，将当前数放到第一个位置，这一趟结束</span><br><span class="line">                    if(j&#x3D;&#x3D;1)&#123;</span><br><span class="line">                        n[j-1] &#x3D; temp;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;else&#123;&#x2F;&#x2F;如果不大于，将当前数放到j的位置，这一趟结束</span><br><span class="line">                </span><br><span class="line">                    n[j] &#x3D; temp;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(n));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a><strong>4. 快速排序</strong></h2><p><strong>4.1 动图演示</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190325195811497-310078615.jpg" alt=""></p>
<p><strong>4.2 思路分析</strong></p>
<p>快速排序的思想就是，选一个数作为基数（这里我选的是第一个数），大于这个基数的放到右边，小于这个基数的放到左边，等于这个基数的数可以放到左边或右边，看自己习惯，这里我是放到了左边，</p>
<p>一趟结束后，将基数放到中间分隔的位置，第二趟将数组从基数的位置分成两半，分割后的两个的数组继续重复以上步骤，选基数，将小数放在基数左边，将大数放到基数的右边，在分割数组，，，直到数组不能再分为止，排序结束。</p>
<p>例如从<strong>小到大</strong>排序:</p>
<p><strong>1.</strong> 第一趟，第一个数为基数temp，设置两个指针left = 0，right = n.length，</p>
<p>　　①从right开始与基数temp比较，如果n[right]&gt;基数temp，则right指针向前移一位，继续与基数temp比较，直到不满足n[right]&gt;基数temp</p>
<p>　　②将n[right]赋给n[left]</p>
<p>　　③从left开始与基数temp比较，如果n[left]&lt;=基数temp，则left指针向后移一位，继续与基数temp比较，直到不满足n[left]&lt;=基数temp</p>
<p>　　④将n[left]赋给n[rigth]</p>
<p>　　⑤重复①-④步，直到left==right结束，将基数temp赋给n[left]</p>
<p><strong>2.</strong> 第二趟，将数组从中间分隔，每个数组再进行第1步的操作，然后再将分隔后的数组进行分隔再快排，</p>
<p><strong>3.</strong> 递归重复分隔快排，直到数组不能再分，也就是只剩下一个元素的时候，结束递归，排序完成</p>
<p>根据思路分析，第一趟的执行流程如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190325222933746-500131356.png" alt=""></p>
<p><strong>4.3 复杂度分析</strong></p>
<p><strong>1. 时间复杂度：</strong></p>
<p>最坏情况就是每一次取到的元素就是数组中最小/最大的，这种情况其实就是冒泡排序了(每一次都排好一个元素的顺序)</p>
<p>这种情况时间复杂度就好计算了，就是冒泡排序的时间复杂度：T[n] = n * (n-1) = n^2 + n;</p>
<p><strong>最好情况下是O(nlog2n)，推导过程如下：</strong></p>
<p><strong>（</strong>递归算法的时间复杂度公式：<strong>T[n] = aT[n/b] + f(n)</strong> <strong>）</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190326191158640-601403776.png" alt=""></p>
<p>所以<strong>平均时间复杂度为O（nlog2n）</strong></p>
<p><strong>2. 空间复杂度：</strong></p>
<p>　　快速排序使用的空间是O(1)的，也就是个常数级；而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据：</p>
<p>　　最优的情况下空间复杂度为:<strong>O(log2n)</strong>；每一次都平分数组的情况</p>
<p>　　最差的情况下空间复杂度为：<strong>O( n )</strong>；退化为冒泡排序的情况</p>
<p>所以<strong>平均空间复杂度为O（log2n）</strong></p>
<p> <strong>4.4 Java 代码如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class quick&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[]&#123;10,6,3,8,33,27,66,9,7,88&#125;;</span><br><span class="line">&#x2F;&#x2F;        int[] arr &#x3D; new int[]&#123;1,3,2&#125;;</span><br><span class="line">        f(arr,0,arr.length-1);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    public static void f(int[] arr,int start,int end)&#123;</span><br><span class="line">        &#x2F;&#x2F;直到start&gt;&#x3D;end时结束递归</span><br><span class="line">        if(start&lt;end)&#123;</span><br><span class="line">            int left &#x3D; start;</span><br><span class="line">            int right &#x3D; end;</span><br><span class="line">            int temp &#x3D; arr[start];</span><br><span class="line">            </span><br><span class="line">            while(left&lt;right)&#123;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F;右面的数字大于标准数时，右边的数的位置不变，指针向左移一个位置</span><br><span class="line">                while(left&lt;right &amp;&amp; arr[right]&gt;temp)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F;右边的数字及下标小于或等于基本数，将右边的数放到左边</span><br><span class="line">                if(left&lt;right) &#123;</span><br><span class="line">                     arr[left] &#x3D; arr[right];</span><br><span class="line">                     left++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F;&#x2F;&#x2F;左边的数字小于或等于标准数时，左边的数的位置不变，指针向右移一个位置</span><br><span class="line">                while(left&lt;right &amp;&amp; arr[left]&lt;&#x3D;temp)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F;左边的数字大于基本数，将左边的数放到右边</span><br><span class="line">                arr[right] &#x3D; arr[left];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;一趟循环结束，此时left&#x3D;right，将基数放到这个重合的位置，</span><br><span class="line">            arr[left] &#x3D; temp;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;将数组从left位置分为两半，继续递归下去进行排序</span><br><span class="line">            f(arr,start,left);</span><br><span class="line">            f(arr,left+1,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a><strong>5. 归并排序</strong></h2><p><strong>5.1 动图演示</strong></p>
<iframe height=100 width=100 src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190326201207440-689679432.gif">





<p><strong>5.2 思路分析</strong></p>
<p>归并排序就是递归得将原始数组递归对半分隔，直到不能再分（只剩下一个元素）后，开始从最小的数组向上归并排序</p>
<p>\1. 向上归并排序的时候，需要一个暂存数组用来排序，</p>
<p>\2. 将待合并的两个数组，从第一位开始比较，小的放到暂存数组，指针向后移，</p>
<p>\3. 直到一个数组空，这时，不用判断哪个数组空了，直接将两个数组剩下的元素追加到暂存数组里，</p>
<p>\4. 再将暂存数组排序后的元素放到原数组里，两个数组合成一个，这一趟结束。</p>
<p><strong>根据思路分析，每一趟的执行流程如下图所示：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190326213950253-1393118004.png" alt=""></p>
<p><strong>5.3 复杂度分析</strong></p>
<p><strong>1. 时间复杂度：</strong>递归算法的时间复杂度公式：<strong>T[n] = aT[n/b] + f(n)</strong> **<br>**</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190326191158640-601403776.png" alt=""></p>
<p>无论原始数组是否是有序的，都要递归分隔并向上归并排序，所以<strong>时间复杂度始终是O（nlog2n）</strong></p>
<p><strong>2. 空间复杂度：</strong></p>
<p>　　每次两个数组进行归并排序的时候，都会利用一个长度为n的数组作为辅助数组用于保存合并序列，所以<strong>空间复杂度为O（n）</strong></p>
<p> <strong>5.4 Java 代码如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[]&#123;3,6,4,7,5,2&#125;;</span><br><span class="line">        merge(arr,0,arr.length-1);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;归并</span><br><span class="line">    public static void merge(int[] arr,int low,int high)&#123;</span><br><span class="line">        int center &#x3D; (high+low)&#x2F;2;</span><br><span class="line">        if(low&lt;high)&#123;</span><br><span class="line">            &#x2F;&#x2F;递归，直到low&#x3D;&#x3D;high，也就是数组已不能再分了，</span><br><span class="line">            merge(arr,low,center);</span><br><span class="line">            merge(arr,center+1,high);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;当数组不能再分，开始归并排序</span><br><span class="line">            mergeSort(arr,low,center,high);</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;排序</span><br><span class="line">    public static void mergeSort(int[] arr,int low,int center,int high)&#123;</span><br><span class="line">        &#x2F;&#x2F;用于暂存排序后的数组的临时数组</span><br><span class="line">        int[] tempArr &#x3D; new int[arr.length];</span><br><span class="line">        int i &#x3D; low,j &#x3D; center+1;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;临时数组的下标</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;循环遍历两个数组的数字，将小的插入到临时数组里</span><br><span class="line">        while(i&lt;&#x3D;center &amp;&amp; j&lt;&#x3D; high)&#123;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;左边数组的数小，插入到新数组</span><br><span class="line">            if(arr[i]&lt;arr[j])&#123;</span><br><span class="line">                tempArr[index] &#x3D; arr[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;else&#123;&#x2F;&#x2F;右边数组的数小，插入到新数组</span><br><span class="line">                tempArr[index] &#x3D; arr[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;处理左半边数组多余的数据，将左半边多余的数据直接追加的临时数组的后面</span><br><span class="line">        while(i&lt;&#x3D;center)&#123;</span><br><span class="line">            tempArr[index] &#x3D; arr[i];</span><br><span class="line">            i++;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;处理右半边数组多余的数据，将右半边多余的数据直接追加的临时数组的后面</span><br><span class="line">        while(j&lt;&#x3D; high)&#123;</span><br><span class="line">            tempArr[index] &#x3D; arr[j];</span><br><span class="line">            j++;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;将临时数组中的数据重新放进原数组</span><br><span class="line">        for (int k &#x3D; 0; k &lt; index; k++) &#123;</span><br><span class="line">            arr[k+low] &#x3D; tempArr[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="6-基数排序"><a href="#6-基数排序" class="headerlink" title="6. 基数排序"></a><strong>6. 基数排序</strong></h2><p><strong>6.1 动图演示</strong></p>
<iframe height=100 width=100 src="https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190418104853042-13278997.gif">



<p><strong>6.2 思路分析</strong></p>
<p>基数排序第i趟将待排数组里的每个数的i位数放到tempj（j=1-10）队列中，然后再从这十个队列中取出数据，重新放到原数组里，直到i大于待排数的最大位数。</p>
<p>1.数组里的数最大位数是n位，就需要排n趟，例如数组里最大的数是3位数，则需要排3趟。</p>
<p>2.若数组里共有m个数，则需要十个长度为m的数组tempj（j=0-9）用来暂存i位上数为j的数，例如，第1趟，各位数为0的会被分配到temp0数组里，各位数为1的会被分配到temp1数组里……</p>
<p>3.分配结束后，再依次从tempj数组中取出数据，遵循先进先进原则，例如对数组{1，11，2，44，4}，进行第1趟分配后，temp1={1,11}，temp2={2}，temp4={44，4}，依次取出元素后{1，11，2，44，4}，第一趟结束</p>
<p>4.循环到n趟后结束，排序完成</p>
<p><strong>根据思路分析，每一趟的执行流程如下图所示：</strong></p>
<p>通过基数排序对数组{53, 3, 542, 748, 14, 214, 154, 63, 616}：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190418154706937-1683821955.png" alt=""></p>
<p><strong>6.3 复杂度分析</strong></p>
<p><strong>1. 时间复杂度：**</strong><br>**</p>
<p>每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。</p>
<p>假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p>
<p>系数2可以省略，且无论数组是否有序，都需要从个位排到最大位数，所以<strong>时间复杂度始终为O(d*n)</strong> 。其中，n是数组长度，d是最大位数。</p>
<p><strong>2. 空间复杂度：</strong> </p>
<p>　　基数排序的<strong>空间复杂度为O(n+k)</strong>，其中k为桶的数量，需要分配n个数。</p>
<p><strong>6.4 Java 代码如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[]&#123;10,6,3,8,33,27,66,9,7,88&#125;;</span><br><span class="line">        radixSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void radixSort(int[] arr) &#123;</span><br><span class="line">        &#x2F;&#x2F;求出待排数的最大数</span><br><span class="line">        int maxLength&#x3D;0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if(maxLength&lt;arr[i])</span><br><span class="line">                maxLength &#x3D; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;根据最大数求最大长度</span><br><span class="line">        maxLength &#x3D; (maxLength+&quot;&quot;).length();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;用于暂存数据的数组</span><br><span class="line">        int[][] temp &#x3D; new int[10][arr.length];</span><br><span class="line">        &#x2F;&#x2F;用于记录temp数组中每个桶内存的数据的数量</span><br><span class="line">        int[] counts &#x3D; new int[10];</span><br><span class="line">        &#x2F;&#x2F;用于记录每个数的i位数</span><br><span class="line">        int num &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;用于取的元素需要放的位置</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;根据最大长度决定排序的次数</span><br><span class="line">        for (int i &#x3D; 0,n&#x3D;1; i &lt; maxLength; i++,n*&#x3D;10) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">                num &#x3D; arr[j]&#x2F;n%10;</span><br><span class="line">                temp[num][counts[num]] &#x3D; arr[j];</span><br><span class="line">                counts[num]++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;从temp中取元素重新放到arr数组中</span><br><span class="line">            for (int j &#x3D; 0; j &lt; counts.length; j++) &#123;</span><br><span class="line">                for (int j2 &#x3D; 0; j2 &lt; counts[j]; j2++) &#123;</span><br><span class="line">                    arr[index] &#x3D; temp[j][j2];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                counts[j]&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">            index&#x3D;0;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="7-希尔（shell）排序"><a href="#7-希尔（shell）排序" class="headerlink" title="7. 希尔（shell）排序"></a><strong>7. 希尔（shell）排序</strong></h2><p><strong>7.1 动图演示</strong></p>
<iframe height=100 width=100 src="https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190420100142756-421005088.gif">





<p><strong>7.2 思路分析</strong></p>
<blockquote>
<p><strong>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</strong></p>
</blockquote>
<p>　　简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。</p>
<p>　　而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。</p>
<p>　　来看下希尔排序的基本步骤，在此选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择可以用一个序列来表示，{n/2,(n/2)/2…1}，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处做示例使用希尔增量。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161128110416068-1421707828.png" alt=""></p>
<p><strong>7.3 复杂度分析</strong></p>
<p><strong>1. 时间复杂度：</strong>最坏情况下，每两个数都要比较并交换一次，则<strong>最坏情况下的时间复杂度为O（n2）</strong>, 最好情况下，数组是有序的，不需要交换，只需要比较，则<strong>最好情况下的时间复杂度为O（n）。</strong></p>
<p>经大量人研究，希尔排序的<strong>平均时间复杂度为O（n1.3）</strong>（这个我也不知道咋来的，书上和博客上都这样说，也没找到个具体的依据，，，）。</p>
<p><strong>2. 空间复杂度：</strong>希尔排序，只需要一个变量用于两数交换，与n的大小无关，所以<strong>空间复杂度为：O（1）。</strong></p>
<p><strong>7.4 Java 代码如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class shell &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[]&#123;10,6,3,8,33,27,66,9,7,88&#125;;</span><br><span class="line">        shellSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    private static void shellSort(int[] arr) &#123;</span><br><span class="line">        int temp;</span><br><span class="line">        &#x2F;&#x2F;控制增量序列,增量序列为1的时候为最后一趟</span><br><span class="line">        for (int i &#x3D; arr.length&#x2F;2; i &gt;0; i&#x2F;&#x3D;2) &#123;</span><br><span class="line">            &#x2F;&#x2F;根据增量序列，找到每组比较序列的最后一个数的位置</span><br><span class="line">            for (int j &#x3D; i; j &lt; arr.length; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F;根据该比较序列的最后一个数的位置，依次向前执行插入排序</span><br><span class="line">                for (int k &#x3D; j-i; k &gt;&#x3D;0; k-&#x3D;i) &#123;</span><br><span class="line">                    if(arr[k]&gt;arr[k+i])&#123;</span><br><span class="line">                        temp &#x3D; arr[k];</span><br><span class="line">                        arr[k]  &#x3D; arr[k+i];</span><br><span class="line">                        arr[k+i] &#x3D; temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="8. 堆排序"></a><strong>8. 堆排序</strong></h2><p><strong>8.1 动图演示</strong></p>
<iframe height=100 width=100 src="https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190420150936225-1441021270.gif">



<p><strong>8.2 思路分析</strong></p>
<p>　　先来了解下堆的相关概念：堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182750011-675658660.png" alt=""></p>
<p>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182857323-2092264199.png" alt=""></p>
<p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p>
<p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p>
<p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p>
<p>了解了这些定义。接下来看看堆排序的基本思想及基本步骤：</p>
<p>堆排序基本思想及步骤</p>
<blockquote>
<p>　　堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p>
</blockquote>
<p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p>
<p>　　a.假设给定无序序列结构如下</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192038651-934327647.png" alt=""></p>
<p>2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192209433-270379236.png" alt=""></p>
<p>4.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192854636-1823585260.png" alt=""></p>
<p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217193347886-1142194411.png" alt=""></p>
<p>此时，我们就将一个无需序列构造成了一个大顶堆。</p>
<p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p>
<p>a.将堆顶元素9和末尾元素4进行交换</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217194207620-1455153342.png" alt=""></p>
<p>b.重新调整结构，使其继续满足堆定义</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218153110495-1280388728.png" alt=""></p>
<p>c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152929339-1114983222.png" alt=""></p>
<p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152348229-935654830.png" alt=""></p>
<p>再简单总结下堆排序的基本思路：</p>
<p>　　<strong>a.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p>
<p>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p>
<p>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p>
<p><strong>8.3 复杂度分析</strong></p>
<p><strong>1. 时间复杂度：</strong>堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。所以堆排序时间复杂度最好和最坏情况下都是<strong>O(nlogn)</strong>级。</p>
<p><strong>2. 空间复杂度：</strong>堆排序不要任何辅助数组，只需要一个辅助变量，所占空间是常数与n无关，所以<strong>空间复杂度为O(1)</strong>。</p>
<p><strong>8.4 Java 代码如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class duipaixu &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[]&#123;4,6,8,5,9&#125;;</span><br><span class="line">        int length &#x3D; arr.length;</span><br><span class="line">        &#x2F;&#x2F;从最后一个非叶节点开始构建大顶堆</span><br><span class="line">        for (int i &#x3D; arr.length&#x2F;2-1; i &gt;&#x3D;0; i--) &#123;</span><br><span class="line">            maximumHeap(i,arr,length);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;从最小的叶子节点开始与根节点进行交换并重新构建大顶堆</span><br><span class="line">        for (int i &#x3D; arr.length-1; i &gt;&#x3D;0; i--) &#123;</span><br><span class="line">&#x2F;&#x2F;            System.out.println(Arrays.toString(arr));</span><br><span class="line">            swap(arr,0,i);</span><br><span class="line">            length--;</span><br><span class="line">            maximumHeap(0,arr,length);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;构建大顶堆</span><br><span class="line">    public static void maximumHeap(int i,int[] arr,int length)&#123;</span><br><span class="line">        int temp &#x3D; arr[i];</span><br><span class="line">        for (int j &#x3D; i*2+1; j &lt; length; j&#x3D;j*2+1) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果右孩子大于做孩子，则指向右孩子</span><br><span class="line">            if(j+1&lt;length &amp;&amp; arr[j+1]&gt;arr[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果最大的孩子大于当前节点，则将大孩子赋给当前节点，修改当前节点为其大孩子节点，再向下走。</span><br><span class="line">            if(arr[j]&gt;temp)&#123;</span><br><span class="line">                arr[i] &#x3D; arr[j];</span><br><span class="line">                i &#x3D; j;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将temp放到最终位置</span><br><span class="line">        arr[i] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;交换</span><br><span class="line">    public static void swap(int[] arr,int i,int j)&#123;</span><br><span class="line">        int temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Zhenglin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://9pshr3.coding-pages.com/2020/09/16/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/">http://9pshr3.coding-pages.com/2020/09/16/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://9pshr3.coding-pages.com" target="_blank">熊儿老猫的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-2.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="../assets/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/../assets/wechatpay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="../assets/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/../assets/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/16/c-%E5%88%9D%E6%8E%A2%E6%9D%82%E8%AE%B0/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-2.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">c++初探杂记</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E3%80%81%E5%B7%B2%E7%9F%A5%E5%89%8D%E4%B8%AD%E5%BA%8F%E6%B1%82%E5%90%8E%E5%BA%8F%E3%80%81%E5%B7%B2%E7%9F%A5%E4%B8%AD%E5%90%8E%E5%BA%8F%E6%B1%82%E5%89%8D%E5%BA%8F%EF%BC%89/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-2.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">二叉树的遍历</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/useblue/ucdn/imgs/bp-2.webp)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Zhenglin Li</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script defer="defer" id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script></div><script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-90},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.3,"opacityOnHover":0.3,"opacity":0.95},"log":false});</script></body></html>